!function(root, factory) {
    "object" == typeof exports && "object" == typeof module ? module.exports = factory(require("react"), require("react-dom")) : "function" == typeof define && define.amd ? define([ "react", "react-dom" ], factory) : "object" == typeof exports ? exports.ReactPresents = factory(require("react"), require("react-dom")) : root.ReactPresents = factory(root.React, root.ReactDOM);
}(this, function(__WEBPACK_EXTERNAL_MODULE_108__, __WEBPACK_EXTERNAL_MODULE_120__) {
    /******/
    return function(modules) {
        /******/
        /******/
        // The require function
        /******/
        function __webpack_require__(moduleId) {
            /******/
            /******/
            // Check if module is in cache
            /******/
            if (installedModules[moduleId]) /******/
            return installedModules[moduleId].exports;
            /******/
            /******/
            // Create a new module (and put it into the cache)
            /******/
            var module = installedModules[moduleId] = {
                /******/
                exports: {},
                /******/
                id: moduleId,
                /******/
                loaded: !1
            };
            /******/
            /******/
            // Return the exports of the module
            /******/
            /******/
            /******/
            // Execute the module function
            /******/
            /******/
            /******/
            // Flag the module as loaded
            /******/
            return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__), 
            module.loaded = !0, module.exports;
        }
        // webpackBootstrap
        /******/
        // The module cache
        /******/
        var installedModules = {};
        /******/
        /******/
        // Load entry module and return exports
        /******/
        /******/
        /******/
        /******/
        // expose the modules object (__webpack_modules__)
        /******/
        /******/
        /******/
        // expose the module cache
        /******/
        /******/
        /******/
        // __webpack_public_path__
        /******/
        return __webpack_require__.m = modules, __webpack_require__.c = installedModules, 
        __webpack_require__.p = "", __webpack_require__(0);
    }([ /* 0 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) return obj;
            var newObj = {};
            if (null != obj) for (var key in obj) Object.prototype.hasOwnProperty.call(obj, key) && (newObj[key] = obj[key]);
            return newObj.default = obj, newObj;
        }
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.TitleSlide = exports.Step = exports.Slide = exports.PropTypes = exports.PresenterModePlugin = exports.Presentation = exports.IconButton = exports.DropDownNav = exports.ContentSlide = exports.Code = void 0;
        var _Code = __webpack_require__(1), _Code2 = _interopRequireDefault(_Code), _ContentSlide = __webpack_require__(141), _ContentSlide2 = _interopRequireDefault(_ContentSlide), _DropDownNav = __webpack_require__(143), _DropDownNav2 = _interopRequireDefault(_DropDownNav), _IconButton = __webpack_require__(182), _IconButton2 = _interopRequireDefault(_IconButton), _Presentation = __webpack_require__(187), _Presentation2 = _interopRequireDefault(_Presentation), _PresenterModePlugin = __webpack_require__(232), _PresenterModePlugin2 = _interopRequireDefault(_PresenterModePlugin), _PropTypes = __webpack_require__(185), PropTypes = _interopRequireWildcard(_PropTypes), _Slide = __webpack_require__(239), _Slide2 = _interopRequireDefault(_Slide), _Step = __webpack_require__(240), _Step2 = _interopRequireDefault(_Step), _TitleSlide = __webpack_require__(241), _TitleSlide2 = _interopRequireDefault(_TitleSlide);
        exports.Code = _Code2.default, exports.ContentSlide = _ContentSlide2.default, exports.DropDownNav = _DropDownNav2.default, 
        exports.IconButton = _IconButton2.default, exports.Presentation = _Presentation2.default, 
        exports.PresenterModePlugin = _PresenterModePlugin2.default, exports.PropTypes = PropTypes, 
        exports.Slide = _Slide2.default, exports.Step = _Step2.default, exports.TitleSlide = _TitleSlide2.default;
    }, /* 1 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _taggedTemplateLiteral2 = __webpack_require__(2), _taggedTemplateLiteral3 = _interopRequireDefault(_taggedTemplateLiteral2), _slicedToArray2 = __webpack_require__(42), _slicedToArray3 = _interopRequireDefault(_slicedToArray2), _extends2 = __webpack_require__(68), _extends3 = _interopRequireDefault(_extends2), _getPrototypeOf = __webpack_require__(75), _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf), _classCallCheck2 = __webpack_require__(78), _classCallCheck3 = _interopRequireDefault(_classCallCheck2), _createClass2 = __webpack_require__(79), _createClass3 = _interopRequireDefault(_createClass2), _possibleConstructorReturn2 = __webpack_require__(83), _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2), _inherits2 = __webpack_require__(100), _inherits3 = _interopRequireDefault(_inherits2), _templateObject = (0, 
        _taggedTemplateLiteral3.default)([ "\n.cm-s-reactpresents.CodeMirror {\n  height: auto;\n  border-radius: 0.5rem;\n  padding: 1rem;\n  background-color: #222 !important;\n  color: #f8f8f2 !important;\n  font-size: 12px;\n  border: none;\n}\n\n.cm-s-reactpresents.CodeMirror-focused div.CodeMirror-selected {\n  background: rgba(255, 255, 255, 0.10);\n}\n\n.cm-s-reactpresents {\n  .CodeMirror-sizer {\n    min-height: auto !important;\n  }\n\n  .CodeMirror-gutters {\n    background-color: #222 !important;\n    color: #f8f8f2 !important;\n    font-size: 12px;\n    border: none;\n  }\n  .CodeMirror-gutters { color: #222; }\n  .CodeMirror-cursor { border-left: solid thin #ddd; }\n  .CodeMirror-linenumber { cololibr: #75715e; }\n  .CodeMirror-line::selection,\n  .CodeMirror-line > span::selection,\n  .CodeMirror-line > span > span::selection {\n    background: rgba(255, 255, 255, 0.10);\n  }\n  .CodeMirror-line::-moz-selection,\n  .CodeMirror-line > span::-moz-selection,\n  .CodeMirror-line > span > span::-moz-selection {\n    background: rgba(255, 255, 255, 0.10);\n  }\n  span.cm-comment { color: #75715e; }\n  span.cm-string,\n  span.cm-string-2 { color: #f1fa8c; }\n  span.cm-number { color: #bd93f9; }\n  span.cm-variable { color: #ddd; }\n  span.cm-variable-2 { color: white; }\n  span.cm-def { color: #a6e22e; }\n  span.cm-keyword { color: #f92672; }\n  span.cm-operator { color: #f92672; }\n  span.cm-keyword { color: #f92672; }\n  span.cm-atom { color: #bd93f9; }\n  span.cm-meta { color: #f8f8f2; }\n  span.cm-tag { color: #f92672; }\n  span.cm-attribute { color: #ddd; }\n  span.cm-qualifier { color: #a6e22e; }\n  span.cm-property { color: #66d9ef; }\n  span.cm-builtin { color: #a6e22e; }\n  span.cm-variable-3 { color: #a6e22e; }\n\n  .CodeMirror-activeline-background { background: rgba(255,255,255,0.1); }\n  .CodeMirror-matchingbracket { text-decoration: underline; color: white !important; }\n\n  span.cm-bracket { color: #900; }\n\n  span.dim {\n    opacity: 0.5;\n    filter: grayscale(100%);\n    -webkit-filter: grayscale(100%);\n  }\n\n  span.highlight {\n    background-color: rgba(189,147,249, .2);\n  }\n}\n" ], [ "\n.cm-s-reactpresents.CodeMirror {\n  height: auto;\n  border-radius: 0.5rem;\n  padding: 1rem;\n  background-color: #222 !important;\n  color: #f8f8f2 !important;\n  font-size: 12px;\n  border: none;\n}\n\n.cm-s-reactpresents.CodeMirror-focused div.CodeMirror-selected {\n  background: rgba(255, 255, 255, 0.10);\n}\n\n.cm-s-reactpresents {\n  .CodeMirror-sizer {\n    min-height: auto !important;\n  }\n\n  .CodeMirror-gutters {\n    background-color: #222 !important;\n    color: #f8f8f2 !important;\n    font-size: 12px;\n    border: none;\n  }\n  .CodeMirror-gutters { color: #222; }\n  .CodeMirror-cursor { border-left: solid thin #ddd; }\n  .CodeMirror-linenumber { cololibr: #75715e; }\n  .CodeMirror-line::selection,\n  .CodeMirror-line > span::selection,\n  .CodeMirror-line > span > span::selection {\n    background: rgba(255, 255, 255, 0.10);\n  }\n  .CodeMirror-line::-moz-selection,\n  .CodeMirror-line > span::-moz-selection,\n  .CodeMirror-line > span > span::-moz-selection {\n    background: rgba(255, 255, 255, 0.10);\n  }\n  span.cm-comment { color: #75715e; }\n  span.cm-string,\n  span.cm-string-2 { color: #f1fa8c; }\n  span.cm-number { color: #bd93f9; }\n  span.cm-variable { color: #ddd; }\n  span.cm-variable-2 { color: white; }\n  span.cm-def { color: #a6e22e; }\n  span.cm-keyword { color: #f92672; }\n  span.cm-operator { color: #f92672; }\n  span.cm-keyword { color: #f92672; }\n  span.cm-atom { color: #bd93f9; }\n  span.cm-meta { color: #f8f8f2; }\n  span.cm-tag { color: #f92672; }\n  span.cm-attribute { color: #ddd; }\n  span.cm-qualifier { color: #a6e22e; }\n  span.cm-property { color: #66d9ef; }\n  span.cm-builtin { color: #a6e22e; }\n  span.cm-variable-3 { color: #a6e22e; }\n\n  .CodeMirror-activeline-background { background: rgba(255,255,255,0.1); }\n  .CodeMirror-matchingbracket { text-decoration: underline; color: white !important; }\n\n  span.cm-bracket { color: #900; }\n\n  span.dim {\n    opacity: 0.5;\n    filter: grayscale(100%);\n    -webkit-filter: grayscale(100%);\n  }\n\n  span.highlight {\n    background-color: rgba(189,147,249, .2);\n  }\n}\n" ]), _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _propTypes = __webpack_require__(109), _reactCodemirror = (_interopRequireDefault(_propTypes), 
        __webpack_require__(119)), _reactCodemirror2 = _interopRequireDefault(_reactCodemirror), _styledComponents = __webpack_require__(129), _styledComponents2 = _interopRequireDefault(_styledComponents);
        __webpack_require__(138);
        var DEFAULT_CODE_MIRROR_OPTIONS = {
            lineNumbers: !1,
            mode: "jsx",
            readOnly: !0,
            theme: "reactpresents"
        }, Code = function(_Component) {
            function Code() {
                return (0, _classCallCheck3.default)(this, Code), (0, _possibleConstructorReturn3.default)(this, (Code.__proto__ || (0, 
                _getPrototypeOf2.default)(Code)).apply(this, arguments));
            }
            return (0, _inherits3.default)(Code, _Component), (0, _createClass3.default)(Code, [ {
                key: "componentDidMount",
                value: function() {
                    var _props = this.props, dimLines = _props.dimLines, highlightLines = _props.highlightLines;
                    this._textMarks = [], this._addClassNameToLines(dimLines, "dim"), this._addClassNameToLines(highlightLines, "highlight");
                }
            }, {
                key: "componentWillUpdate",
                value: function(nextProps, nextState) {
                    var _props2 = this.props, dimLines = _props2.dimLines, highlightLines = _props2.highlightLines;
                    dimLines === nextProps.dimLines && highlightLines === nextProps.highlightLines || (this._textMarks.forEach(function(textMark) {
                        textMark.clear();
                    }), this._textMarks = [], this._addClassNameToLines(nextProps.dimLines, "dim"), 
                    this._addClassNameToLines(nextProps.highlightLines, "highlight"));
                }
            }, {
                key: "render",
                value: function() {
                    var _this2 = this, _props3 = this.props, codeMirrorOptions = _props3.codeMirrorOptions, value = _props3.value, className = _props3.className, options = (0, 
                    _extends3.default)({}, DEFAULT_CODE_MIRROR_OPTIONS, codeMirrorOptions);
                    return _react2.default.createElement(CodeMirrorTheme, {
                        className: className
                    }, _react2.default.createElement(_reactCodemirror2.default, {
                        options: options,
                        ref: function(_ref) {
                            _this2._codeMirror = _ref;
                        },
                        value: value
                    }));
                }
            }, {
                key: "_addClassNameToLines",
                value: function(lineNumbers, className) {
                    var _this3 = this;
                    lineNumbers.forEach(function(_ref2) {
                        var _ref3 = (0, _slicedToArray3.default)(_ref2, 2), start = _ref3[0], stop = _ref3[1];
                        _this3._textMarks.push(_this3._codeMirror.codeMirror.doc.markText({
                            line: start,
                            ch: 0
                        }, {
                            line: stop + 1,
                            ch: 0
                        }, {
                            className: className
                        }));
                    });
                }
            } ]), Code;
        }(_react.Component);
        Code.defaultProps = {
            codeMirrorOptions: {},
            dimLines: [],
            highlightLines: []
        }, exports.default = Code;
        var CodeMirrorTheme = _styledComponents2.default.div(_templateObject);
    }, /* 2 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0;
        var _defineProperties = __webpack_require__(3), _defineProperties2 = _interopRequireDefault(_defineProperties), _freeze = __webpack_require__(37), _freeze2 = _interopRequireDefault(_freeze);
        exports.default = function(strings, raw) {
            return (0, _freeze2.default)((0, _defineProperties2.default)(strings, {
                raw: {
                    value: (0, _freeze2.default)(raw)
                }
            }));
        };
    }, /* 3 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = {
            default: __webpack_require__(4),
            __esModule: !0
        };
    }, /* 4 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(5);
        var $Object = __webpack_require__(8).Object;
        module.exports = function(T, D) {
            return $Object.defineProperties(T, D);
        };
    }, /* 5 */
    /***/
    function(module, exports, __webpack_require__) {
        var $export = __webpack_require__(6);
        // 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
        $export($export.S + $export.F * !__webpack_require__(16), "Object", {
            defineProperties: __webpack_require__(21)
        });
    }, /* 6 */
    /***/
    function(module, exports, __webpack_require__) {
        var global = __webpack_require__(7), core = __webpack_require__(8), ctx = __webpack_require__(9), hide = __webpack_require__(11), PROTOTYPE = "prototype", $export = function(type, name, source) {
            var key, own, out, IS_FORCED = type & $export.F, IS_GLOBAL = type & $export.G, IS_STATIC = type & $export.S, IS_PROTO = type & $export.P, IS_BIND = type & $export.B, IS_WRAP = type & $export.W, exports = IS_GLOBAL ? core : core[name] || (core[name] = {}), expProto = exports[PROTOTYPE], target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
            IS_GLOBAL && (source = name);
            for (key in source) // contains in native
            own = !IS_FORCED && target && void 0 !== target[key], own && key in exports || (// export native or passed
            out = own ? target[key] : source[key], // prevent global pollution for namespaces
            exports[key] = IS_GLOBAL && "function" != typeof target[key] ? source[key] : IS_BIND && own ? ctx(out, global) : IS_WRAP && target[key] == out ? function(C) {
                var F = function(a, b, c) {
                    if (this instanceof C) {
                        switch (arguments.length) {
                          case 0:
                            return new C();

                          case 1:
                            return new C(a);

                          case 2:
                            return new C(a, b);
                        }
                        return new C(a, b, c);
                    }
                    return C.apply(this, arguments);
                };
                return F[PROTOTYPE] = C[PROTOTYPE], F;
            }(out) : IS_PROTO && "function" == typeof out ? ctx(Function.call, out) : out, // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
            IS_PROTO && ((exports.virtual || (exports.virtual = {}))[key] = out, // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
            type & $export.R && expProto && !expProto[key] && hide(expProto, key, out)));
        };
        // type bitmap
        $export.F = 1, // forced
        $export.G = 2, // global
        $export.S = 4, // static
        $export.P = 8, // proto
        $export.B = 16, // bind
        $export.W = 32, // wrap
        $export.U = 64, // safe
        $export.R = 128, // real proto method for `library`
        module.exports = $export;
    }, /* 7 */
    /***/
    function(module, exports) {
        // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
        var global = module.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")();
        "number" == typeof __g && (__g = global);
    }, /* 8 */
    /***/
    function(module, exports) {
        var core = module.exports = {
            version: "2.5.1"
        };
        "number" == typeof __e && (__e = core);
    }, /* 9 */
    /***/
    function(module, exports, __webpack_require__) {
        // optional / simple context binding
        var aFunction = __webpack_require__(10);
        module.exports = function(fn, that, length) {
            if (aFunction(fn), void 0 === that) return fn;
            switch (length) {
              case 1:
                return function(a) {
                    return fn.call(that, a);
                };

              case 2:
                return function(a, b) {
                    return fn.call(that, a, b);
                };

              case 3:
                return function(a, b, c) {
                    return fn.call(that, a, b, c);
                };
            }
            return function() {
                return fn.apply(that, arguments);
            };
        };
    }, /* 10 */
    /***/
    function(module, exports) {
        module.exports = function(it) {
            if ("function" != typeof it) throw TypeError(it + " is not a function!");
            return it;
        };
    }, /* 11 */
    /***/
    function(module, exports, __webpack_require__) {
        var dP = __webpack_require__(12), createDesc = __webpack_require__(20);
        module.exports = __webpack_require__(16) ? function(object, key, value) {
            return dP.f(object, key, createDesc(1, value));
        } : function(object, key, value) {
            return object[key] = value, object;
        };
    }, /* 12 */
    /***/
    function(module, exports, __webpack_require__) {
        var anObject = __webpack_require__(13), IE8_DOM_DEFINE = __webpack_require__(15), toPrimitive = __webpack_require__(19), dP = Object.defineProperty;
        exports.f = __webpack_require__(16) ? Object.defineProperty : function(O, P, Attributes) {
            if (anObject(O), P = toPrimitive(P, !0), anObject(Attributes), IE8_DOM_DEFINE) try {
                return dP(O, P, Attributes);
            } catch (e) {}
            if ("get" in Attributes || "set" in Attributes) throw TypeError("Accessors not supported!");
            return "value" in Attributes && (O[P] = Attributes.value), O;
        };
    }, /* 13 */
    /***/
    function(module, exports, __webpack_require__) {
        var isObject = __webpack_require__(14);
        module.exports = function(it) {
            if (!isObject(it)) throw TypeError(it + " is not an object!");
            return it;
        };
    }, /* 14 */
    /***/
    function(module, exports) {
        module.exports = function(it) {
            return "object" == typeof it ? null !== it : "function" == typeof it;
        };
    }, /* 15 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = !__webpack_require__(16) && !__webpack_require__(17)(function() {
            return 7 != Object.defineProperty(__webpack_require__(18)("div"), "a", {
                get: function() {
                    return 7;
                }
            }).a;
        });
    }, /* 16 */
    /***/
    function(module, exports, __webpack_require__) {
        // Thank's IE8 for his funny defineProperty
        module.exports = !__webpack_require__(17)(function() {
            return 7 != Object.defineProperty({}, "a", {
                get: function() {
                    return 7;
                }
            }).a;
        });
    }, /* 17 */
    /***/
    function(module, exports) {
        module.exports = function(exec) {
            try {
                return !!exec();
            } catch (e) {
                return !0;
            }
        };
    }, /* 18 */
    /***/
    function(module, exports, __webpack_require__) {
        var isObject = __webpack_require__(14), document = __webpack_require__(7).document, is = isObject(document) && isObject(document.createElement);
        module.exports = function(it) {
            return is ? document.createElement(it) : {};
        };
    }, /* 19 */
    /***/
    function(module, exports, __webpack_require__) {
        // 7.1.1 ToPrimitive(input [, PreferredType])
        var isObject = __webpack_require__(14);
        // instead of the ES6 spec version, we didn't implement @@toPrimitive case
        // and the second argument - flag - preferred type is a string
        module.exports = function(it, S) {
            if (!isObject(it)) return it;
            var fn, val;
            if (S && "function" == typeof (fn = it.toString) && !isObject(val = fn.call(it))) return val;
            if ("function" == typeof (fn = it.valueOf) && !isObject(val = fn.call(it))) return val;
            if (!S && "function" == typeof (fn = it.toString) && !isObject(val = fn.call(it))) return val;
            throw TypeError("Can't convert object to primitive value");
        };
    }, /* 20 */
    /***/
    function(module, exports) {
        module.exports = function(bitmap, value) {
            return {
                enumerable: !(1 & bitmap),
                configurable: !(2 & bitmap),
                writable: !(4 & bitmap),
                value: value
            };
        };
    }, /* 21 */
    /***/
    function(module, exports, __webpack_require__) {
        var dP = __webpack_require__(12), anObject = __webpack_require__(13), getKeys = __webpack_require__(22);
        module.exports = __webpack_require__(16) ? Object.defineProperties : function(O, Properties) {
            anObject(O);
            for (var P, keys = getKeys(Properties), length = keys.length, i = 0; length > i; ) dP.f(O, P = keys[i++], Properties[P]);
            return O;
        };
    }, /* 22 */
    /***/
    function(module, exports, __webpack_require__) {
        // 19.1.2.14 / 15.2.3.14 Object.keys(O)
        var $keys = __webpack_require__(23), enumBugKeys = __webpack_require__(36);
        module.exports = Object.keys || function(O) {
            return $keys(O, enumBugKeys);
        };
    }, /* 23 */
    /***/
    function(module, exports, __webpack_require__) {
        var has = __webpack_require__(24), toIObject = __webpack_require__(25), arrayIndexOf = __webpack_require__(29)(!1), IE_PROTO = __webpack_require__(33)("IE_PROTO");
        module.exports = function(object, names) {
            var key, O = toIObject(object), i = 0, result = [];
            for (key in O) key != IE_PROTO && has(O, key) && result.push(key);
            // Don't enum bug & hidden keys
            for (;names.length > i; ) has(O, key = names[i++]) && (~arrayIndexOf(result, key) || result.push(key));
            return result;
        };
    }, /* 24 */
    /***/
    function(module, exports) {
        var hasOwnProperty = {}.hasOwnProperty;
        module.exports = function(it, key) {
            return hasOwnProperty.call(it, key);
        };
    }, /* 25 */
    /***/
    function(module, exports, __webpack_require__) {
        // to indexed object, toObject with fallback for non-array-like ES3 strings
        var IObject = __webpack_require__(26), defined = __webpack_require__(28);
        module.exports = function(it) {
            return IObject(defined(it));
        };
    }, /* 26 */
    /***/
    function(module, exports, __webpack_require__) {
        // fallback for non-array-like ES3 and non-enumerable old V8 strings
        var cof = __webpack_require__(27);
        // eslint-disable-next-line no-prototype-builtins
        module.exports = Object("z").propertyIsEnumerable(0) ? Object : function(it) {
            return "String" == cof(it) ? it.split("") : Object(it);
        };
    }, /* 27 */
    /***/
    function(module, exports) {
        var toString = {}.toString;
        module.exports = function(it) {
            return toString.call(it).slice(8, -1);
        };
    }, /* 28 */
    /***/
    function(module, exports) {
        // 7.2.1 RequireObjectCoercible(argument)
        module.exports = function(it) {
            if (void 0 == it) throw TypeError("Can't call method on  " + it);
            return it;
        };
    }, /* 29 */
    /***/
    function(module, exports, __webpack_require__) {
        // false -> Array#indexOf
        // true  -> Array#includes
        var toIObject = __webpack_require__(25), toLength = __webpack_require__(30), toAbsoluteIndex = __webpack_require__(32);
        module.exports = function(IS_INCLUDES) {
            return function($this, el, fromIndex) {
                var value, O = toIObject($this), length = toLength(O.length), index = toAbsoluteIndex(fromIndex, length);
                // Array#includes uses SameValueZero equality algorithm
                // eslint-disable-next-line no-self-compare
                if (IS_INCLUDES && el != el) {
                    for (;length > index; ) // eslint-disable-next-line no-self-compare
                    if (value = O[index++], value != value) return !0;
                } else for (;length > index; index++) if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
                return !IS_INCLUDES && -1;
            };
        };
    }, /* 30 */
    /***/
    function(module, exports, __webpack_require__) {
        // 7.1.15 ToLength
        var toInteger = __webpack_require__(31), min = Math.min;
        module.exports = function(it) {
            return it > 0 ? min(toInteger(it), 9007199254740991) : 0;
        };
    }, /* 31 */
    /***/
    function(module, exports) {
        // 7.1.4 ToInteger
        var ceil = Math.ceil, floor = Math.floor;
        module.exports = function(it) {
            return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
        };
    }, /* 32 */
    /***/
    function(module, exports, __webpack_require__) {
        var toInteger = __webpack_require__(31), max = Math.max, min = Math.min;
        module.exports = function(index, length) {
            return index = toInteger(index), index < 0 ? max(index + length, 0) : min(index, length);
        };
    }, /* 33 */
    /***/
    function(module, exports, __webpack_require__) {
        var shared = __webpack_require__(34)("keys"), uid = __webpack_require__(35);
        module.exports = function(key) {
            return shared[key] || (shared[key] = uid(key));
        };
    }, /* 34 */
    /***/
    function(module, exports, __webpack_require__) {
        var global = __webpack_require__(7), SHARED = "__core-js_shared__", store = global[SHARED] || (global[SHARED] = {});
        module.exports = function(key) {
            return store[key] || (store[key] = {});
        };
    }, /* 35 */
    /***/
    function(module, exports) {
        var id = 0, px = Math.random();
        module.exports = function(key) {
            return "Symbol(".concat(void 0 === key ? "" : key, ")_", (++id + px).toString(36));
        };
    }, /* 36 */
    /***/
    function(module, exports) {
        // IE 8- don't enum bug keys
        module.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
    }, /* 37 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = {
            default: __webpack_require__(38),
            __esModule: !0
        };
    }, /* 38 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(39), module.exports = __webpack_require__(8).Object.freeze;
    }, /* 39 */
    /***/
    function(module, exports, __webpack_require__) {
        // 19.1.2.5 Object.freeze(O)
        var isObject = __webpack_require__(14), meta = __webpack_require__(40).onFreeze;
        __webpack_require__(41)("freeze", function($freeze) {
            return function(it) {
                return $freeze && isObject(it) ? $freeze(meta(it)) : it;
            };
        });
    }, /* 40 */
    /***/
    function(module, exports, __webpack_require__) {
        var META = __webpack_require__(35)("meta"), isObject = __webpack_require__(14), has = __webpack_require__(24), setDesc = __webpack_require__(12).f, id = 0, isExtensible = Object.isExtensible || function() {
            return !0;
        }, FREEZE = !__webpack_require__(17)(function() {
            return isExtensible(Object.preventExtensions({}));
        }), setMeta = function(it) {
            setDesc(it, META, {
                value: {
                    i: "O" + ++id,
                    // object ID
                    w: {}
                }
            });
        }, fastKey = function(it, create) {
            // return primitive with prefix
            if (!isObject(it)) return "symbol" == typeof it ? it : ("string" == typeof it ? "S" : "P") + it;
            if (!has(it, META)) {
                // can't set metadata to uncaught frozen object
                if (!isExtensible(it)) return "F";
                // not necessary to add metadata
                if (!create) return "E";
                // add missing metadata
                setMeta(it);
            }
            return it[META].i;
        }, getWeak = function(it, create) {
            if (!has(it, META)) {
                // can't set metadata to uncaught frozen object
                if (!isExtensible(it)) return !0;
                // not necessary to add metadata
                if (!create) return !1;
                // add missing metadata
                setMeta(it);
            }
            return it[META].w;
        }, onFreeze = function(it) {
            return FREEZE && meta.NEED && isExtensible(it) && !has(it, META) && setMeta(it), 
            it;
        }, meta = module.exports = {
            KEY: META,
            NEED: !1,
            fastKey: fastKey,
            getWeak: getWeak,
            onFreeze: onFreeze
        };
    }, /* 41 */
    /***/
    function(module, exports, __webpack_require__) {
        // most Object methods by ES6 should accept primitives
        var $export = __webpack_require__(6), core = __webpack_require__(8), fails = __webpack_require__(17);
        module.exports = function(KEY, exec) {
            var fn = (core.Object || {})[KEY] || Object[KEY], exp = {};
            exp[KEY] = exec(fn), $export($export.S + $export.F * fails(function() {
                fn(1);
            }), "Object", exp);
        };
    }, /* 42 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0;
        var _isIterable2 = __webpack_require__(43), _isIterable3 = _interopRequireDefault(_isIterable2), _getIterator2 = __webpack_require__(64), _getIterator3 = _interopRequireDefault(_getIterator2);
        exports.default = function() {
            function sliceIterator(arr, i) {
                var _arr = [], _n = !0, _d = !1, _e = void 0;
                try {
                    for (var _s, _i = (0, _getIterator3.default)(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), 
                    !i || _arr.length !== i); _n = !0) ;
                } catch (err) {
                    _d = !0, _e = err;
                } finally {
                    try {
                        !_n && _i.return && _i.return();
                    } finally {
                        if (_d) throw _e;
                    }
                }
                return _arr;
            }
            return function(arr, i) {
                if (Array.isArray(arr)) return arr;
                if ((0, _isIterable3.default)(Object(arr))) return sliceIterator(arr, i);
                throw new TypeError("Invalid attempt to destructure non-iterable instance");
            };
        }();
    }, /* 43 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = {
            default: __webpack_require__(44),
            __esModule: !0
        };
    }, /* 44 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(45), __webpack_require__(60), module.exports = __webpack_require__(62);
    }, /* 45 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(46);
        for (var global = __webpack_require__(7), hide = __webpack_require__(11), Iterators = __webpack_require__(49), TO_STRING_TAG = __webpack_require__(57)("toStringTag"), DOMIterables = "CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,TextTrackList,TouchList".split(","), i = 0; i < DOMIterables.length; i++) {
            var NAME = DOMIterables[i], Collection = global[NAME], proto = Collection && Collection.prototype;
            proto && !proto[TO_STRING_TAG] && hide(proto, TO_STRING_TAG, NAME), Iterators[NAME] = Iterators.Array;
        }
    }, /* 46 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        var addToUnscopables = __webpack_require__(47), step = __webpack_require__(48), Iterators = __webpack_require__(49), toIObject = __webpack_require__(25);
        // 22.1.3.4 Array.prototype.entries()
        // 22.1.3.13 Array.prototype.keys()
        // 22.1.3.29 Array.prototype.values()
        // 22.1.3.30 Array.prototype[@@iterator]()
        module.exports = __webpack_require__(50)(Array, "Array", function(iterated, kind) {
            this._t = toIObject(iterated), // target
            this._i = 0, // next index
            this._k = kind;
        }, function() {
            var O = this._t, kind = this._k, index = this._i++;
            return !O || index >= O.length ? (this._t = void 0, step(1)) : "keys" == kind ? step(0, index) : "values" == kind ? step(0, O[index]) : step(0, [ index, O[index] ]);
        }, "values"), // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
        Iterators.Arguments = Iterators.Array, addToUnscopables("keys"), addToUnscopables("values"), 
        addToUnscopables("entries");
    }, /* 47 */
    /***/
    function(module, exports) {
        module.exports = function() {};
    }, /* 48 */
    /***/
    function(module, exports) {
        module.exports = function(done, value) {
            return {
                value: value,
                done: !!done
            };
        };
    }, /* 49 */
    /***/
    function(module, exports) {
        module.exports = {};
    }, /* 50 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        var LIBRARY = __webpack_require__(51), $export = __webpack_require__(6), redefine = __webpack_require__(52), hide = __webpack_require__(11), has = __webpack_require__(24), Iterators = __webpack_require__(49), $iterCreate = __webpack_require__(53), setToStringTag = __webpack_require__(56), getPrototypeOf = __webpack_require__(58), ITERATOR = __webpack_require__(57)("iterator"), BUGGY = !([].keys && "next" in [].keys()), FF_ITERATOR = "@@iterator", KEYS = "keys", VALUES = "values", returnThis = function() {
            return this;
        };
        module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
            $iterCreate(Constructor, NAME, next);
            var methods, key, IteratorPrototype, getMethod = function(kind) {
                if (!BUGGY && kind in proto) return proto[kind];
                switch (kind) {
                  case KEYS:
                    return function() {
                        return new Constructor(this, kind);
                    };

                  case VALUES:
                    return function() {
                        return new Constructor(this, kind);
                    };
                }
                return function() {
                    return new Constructor(this, kind);
                };
            }, TAG = NAME + " Iterator", DEF_VALUES = DEFAULT == VALUES, VALUES_BUG = !1, proto = Base.prototype, $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT], $default = $native || getMethod(DEFAULT), $entries = DEFAULT ? DEF_VALUES ? getMethod("entries") : $default : void 0, $anyNative = "Array" == NAME ? proto.entries || $native : $native;
            if (// Fix native
            $anyNative && (IteratorPrototype = getPrototypeOf($anyNative.call(new Base())), 
            IteratorPrototype !== Object.prototype && IteratorPrototype.next && (// Set @@toStringTag to native iterators
            setToStringTag(IteratorPrototype, TAG, !0), // fix for some old engines
            LIBRARY || has(IteratorPrototype, ITERATOR) || hide(IteratorPrototype, ITERATOR, returnThis))), 
            // fix Array#{values, @@iterator}.name in V8 / FF
            DEF_VALUES && $native && $native.name !== VALUES && (VALUES_BUG = !0, $default = function() {
                return $native.call(this);
            }), // Define iterator
            LIBRARY && !FORCED || !BUGGY && !VALUES_BUG && proto[ITERATOR] || hide(proto, ITERATOR, $default), 
            // Plug for library
            Iterators[NAME] = $default, Iterators[TAG] = returnThis, DEFAULT) if (methods = {
                values: DEF_VALUES ? $default : getMethod(VALUES),
                keys: IS_SET ? $default : getMethod(KEYS),
                entries: $entries
            }, FORCED) for (key in methods) key in proto || redefine(proto, key, methods[key]); else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
            return methods;
        };
    }, /* 51 */
    /***/
    function(module, exports) {
        module.exports = !0;
    }, /* 52 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = __webpack_require__(11);
    }, /* 53 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        var create = __webpack_require__(54), descriptor = __webpack_require__(20), setToStringTag = __webpack_require__(56), IteratorPrototype = {};
        // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
        __webpack_require__(11)(IteratorPrototype, __webpack_require__(57)("iterator"), function() {
            return this;
        }), module.exports = function(Constructor, NAME, next) {
            Constructor.prototype = create(IteratorPrototype, {
                next: descriptor(1, next)
            }), setToStringTag(Constructor, NAME + " Iterator");
        };
    }, /* 54 */
    /***/
    function(module, exports, __webpack_require__) {
        // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
        var anObject = __webpack_require__(13), dPs = __webpack_require__(21), enumBugKeys = __webpack_require__(36), IE_PROTO = __webpack_require__(33)("IE_PROTO"), Empty = function() {}, PROTOTYPE = "prototype", createDict = function() {
            // Thrash, waste and sodomy: IE GC bug
            var iframeDocument, iframe = __webpack_require__(18)("iframe"), i = enumBugKeys.length, lt = "<", gt = ">";
            for (iframe.style.display = "none", __webpack_require__(55).appendChild(iframe), 
            iframe.src = "javascript:", // eslint-disable-line no-script-url
            // createDict = iframe.contentWindow.Object;
            // html.removeChild(iframe);
            iframeDocument = iframe.contentWindow.document, iframeDocument.open(), iframeDocument.write(lt + "script" + gt + "document.F=Object" + lt + "/script" + gt), 
            iframeDocument.close(), createDict = iframeDocument.F; i--; ) delete createDict[PROTOTYPE][enumBugKeys[i]];
            return createDict();
        };
        module.exports = Object.create || function(O, Properties) {
            var result;
            // add "__proto__" for Object.getPrototypeOf polyfill
            return null !== O ? (Empty[PROTOTYPE] = anObject(O), result = new Empty(), Empty[PROTOTYPE] = null, 
            result[IE_PROTO] = O) : result = createDict(), void 0 === Properties ? result : dPs(result, Properties);
        };
    }, /* 55 */
    /***/
    function(module, exports, __webpack_require__) {
        var document = __webpack_require__(7).document;
        module.exports = document && document.documentElement;
    }, /* 56 */
    /***/
    function(module, exports, __webpack_require__) {
        var def = __webpack_require__(12).f, has = __webpack_require__(24), TAG = __webpack_require__(57)("toStringTag");
        module.exports = function(it, tag, stat) {
            it && !has(it = stat ? it : it.prototype, TAG) && def(it, TAG, {
                configurable: !0,
                value: tag
            });
        };
    }, /* 57 */
    /***/
    function(module, exports, __webpack_require__) {
        var store = __webpack_require__(34)("wks"), uid = __webpack_require__(35), Symbol = __webpack_require__(7).Symbol, USE_SYMBOL = "function" == typeof Symbol, $exports = module.exports = function(name) {
            return store[name] || (store[name] = USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)("Symbol." + name));
        };
        $exports.store = store;
    }, /* 58 */
    /***/
    function(module, exports, __webpack_require__) {
        // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
        var has = __webpack_require__(24), toObject = __webpack_require__(59), IE_PROTO = __webpack_require__(33)("IE_PROTO"), ObjectProto = Object.prototype;
        module.exports = Object.getPrototypeOf || function(O) {
            return O = toObject(O), has(O, IE_PROTO) ? O[IE_PROTO] : "function" == typeof O.constructor && O instanceof O.constructor ? O.constructor.prototype : O instanceof Object ? ObjectProto : null;
        };
    }, /* 59 */
    /***/
    function(module, exports, __webpack_require__) {
        // 7.1.13 ToObject(argument)
        var defined = __webpack_require__(28);
        module.exports = function(it) {
            return Object(defined(it));
        };
    }, /* 60 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        var $at = __webpack_require__(61)(!0);
        // 21.1.3.27 String.prototype[@@iterator]()
        __webpack_require__(50)(String, "String", function(iterated) {
            this._t = String(iterated), // target
            this._i = 0;
        }, function() {
            var point, O = this._t, index = this._i;
            return index >= O.length ? {
                value: void 0,
                done: !0
            } : (point = $at(O, index), this._i += point.length, {
                value: point,
                done: !1
            });
        });
    }, /* 61 */
    /***/
    function(module, exports, __webpack_require__) {
        var toInteger = __webpack_require__(31), defined = __webpack_require__(28);
        // true  -> String#at
        // false -> String#codePointAt
        module.exports = function(TO_STRING) {
            return function(that, pos) {
                var a, b, s = String(defined(that)), i = toInteger(pos), l = s.length;
                return i < 0 || i >= l ? TO_STRING ? "" : void 0 : (a = s.charCodeAt(i), a < 55296 || a > 56319 || i + 1 === l || (b = s.charCodeAt(i + 1)) < 56320 || b > 57343 ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 55296 << 10) + (b - 56320) + 65536);
            };
        };
    }, /* 62 */
    /***/
    function(module, exports, __webpack_require__) {
        var classof = __webpack_require__(63), ITERATOR = __webpack_require__(57)("iterator"), Iterators = __webpack_require__(49);
        module.exports = __webpack_require__(8).isIterable = function(it) {
            var O = Object(it);
            return void 0 !== O[ITERATOR] || "@@iterator" in O || Iterators.hasOwnProperty(classof(O));
        };
    }, /* 63 */
    /***/
    function(module, exports, __webpack_require__) {
        // getting tag from 19.1.3.6 Object.prototype.toString()
        var cof = __webpack_require__(27), TAG = __webpack_require__(57)("toStringTag"), ARG = "Arguments" == cof(function() {
            return arguments;
        }()), tryGet = function(it, key) {
            try {
                return it[key];
            } catch (e) {}
        };
        module.exports = function(it) {
            var O, T, B;
            return void 0 === it ? "Undefined" : null === it ? "Null" : "string" == typeof (T = tryGet(O = Object(it), TAG)) ? T : ARG ? cof(O) : "Object" == (B = cof(O)) && "function" == typeof O.callee ? "Arguments" : B;
        };
    }, /* 64 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = {
            default: __webpack_require__(65),
            __esModule: !0
        };
    }, /* 65 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(45), __webpack_require__(60), module.exports = __webpack_require__(66);
    }, /* 66 */
    /***/
    function(module, exports, __webpack_require__) {
        var anObject = __webpack_require__(13), get = __webpack_require__(67);
        module.exports = __webpack_require__(8).getIterator = function(it) {
            var iterFn = get(it);
            if ("function" != typeof iterFn) throw TypeError(it + " is not iterable!");
            return anObject(iterFn.call(it));
        };
    }, /* 67 */
    /***/
    function(module, exports, __webpack_require__) {
        var classof = __webpack_require__(63), ITERATOR = __webpack_require__(57)("iterator"), Iterators = __webpack_require__(49);
        module.exports = __webpack_require__(8).getIteratorMethod = function(it) {
            if (void 0 != it) return it[ITERATOR] || it["@@iterator"] || Iterators[classof(it)];
        };
    }, /* 68 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0;
        var _assign = __webpack_require__(69), _assign2 = _interopRequireDefault(_assign);
        exports.default = _assign2.default || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        };
    }, /* 69 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = {
            default: __webpack_require__(70),
            __esModule: !0
        };
    }, /* 70 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(71), module.exports = __webpack_require__(8).Object.assign;
    }, /* 71 */
    /***/
    function(module, exports, __webpack_require__) {
        // 19.1.3.1 Object.assign(target, source)
        var $export = __webpack_require__(6);
        $export($export.S + $export.F, "Object", {
            assign: __webpack_require__(72)
        });
    }, /* 72 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        // 19.1.2.1 Object.assign(target, source, ...)
        var getKeys = __webpack_require__(22), gOPS = __webpack_require__(73), pIE = __webpack_require__(74), toObject = __webpack_require__(59), IObject = __webpack_require__(26), $assign = Object.assign;
        // should work with symbols and should have deterministic property order (V8 bug)
        module.exports = !$assign || __webpack_require__(17)(function() {
            var A = {}, B = {}, S = Symbol(), K = "abcdefghijklmnopqrst";
            return A[S] = 7, K.split("").forEach(function(k) {
                B[k] = k;
            }), 7 != $assign({}, A)[S] || Object.keys($assign({}, B)).join("") != K;
        }) ? function(target, source) {
            for (// eslint-disable-line no-unused-vars
            var T = toObject(target), aLen = arguments.length, index = 1, getSymbols = gOPS.f, isEnum = pIE.f; aLen > index; ) for (var key, S = IObject(arguments[index++]), keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S), length = keys.length, j = 0; length > j; ) isEnum.call(S, key = keys[j++]) && (T[key] = S[key]);
            return T;
        } : $assign;
    }, /* 73 */
    /***/
    function(module, exports) {
        exports.f = Object.getOwnPropertySymbols;
    }, /* 74 */
    /***/
    function(module, exports) {
        exports.f = {}.propertyIsEnumerable;
    }, /* 75 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = {
            default: __webpack_require__(76),
            __esModule: !0
        };
    }, /* 76 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(77), module.exports = __webpack_require__(8).Object.getPrototypeOf;
    }, /* 77 */
    /***/
    function(module, exports, __webpack_require__) {
        // 19.1.2.9 Object.getPrototypeOf(O)
        var toObject = __webpack_require__(59), $getPrototypeOf = __webpack_require__(58);
        __webpack_require__(41)("getPrototypeOf", function() {
            return function(it) {
                return $getPrototypeOf(toObject(it));
            };
        });
    }, /* 78 */
    /***/
    function(module, exports) {
        "use strict";
        exports.__esModule = !0, exports.default = function(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        };
    }, /* 79 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0;
        var _defineProperty = __webpack_require__(80), _defineProperty2 = _interopRequireDefault(_defineProperty);
        exports.default = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), (0, _defineProperty2.default)(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }();
    }, /* 80 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = {
            default: __webpack_require__(81),
            __esModule: !0
        };
    }, /* 81 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(82);
        var $Object = __webpack_require__(8).Object;
        module.exports = function(it, key, desc) {
            return $Object.defineProperty(it, key, desc);
        };
    }, /* 82 */
    /***/
    function(module, exports, __webpack_require__) {
        var $export = __webpack_require__(6);
        // 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
        $export($export.S + $export.F * !__webpack_require__(16), "Object", {
            defineProperty: __webpack_require__(12).f
        });
    }, /* 83 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0;
        var _typeof2 = __webpack_require__(84), _typeof3 = _interopRequireDefault(_typeof2);
        exports.default = function(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" !== ("undefined" == typeof call ? "undefined" : (0, _typeof3.default)(call)) && "function" != typeof call ? self : call;
        };
    }, /* 84 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0;
        var _iterator = __webpack_require__(85), _iterator2 = _interopRequireDefault(_iterator), _symbol = __webpack_require__(88), _symbol2 = _interopRequireDefault(_symbol), _typeof = "function" == typeof _symbol2.default && "symbol" == typeof _iterator2.default ? function(obj) {
            return typeof obj;
        } : function(obj) {
            return obj && "function" == typeof _symbol2.default && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj;
        };
        exports.default = "function" == typeof _symbol2.default && "symbol" === _typeof(_iterator2.default) ? function(obj) {
            return "undefined" == typeof obj ? "undefined" : _typeof(obj);
        } : function(obj) {
            return obj && "function" == typeof _symbol2.default && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : "undefined" == typeof obj ? "undefined" : _typeof(obj);
        };
    }, /* 85 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = {
            default: __webpack_require__(86),
            __esModule: !0
        };
    }, /* 86 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(60), __webpack_require__(45), module.exports = __webpack_require__(87).f("iterator");
    }, /* 87 */
    /***/
    function(module, exports, __webpack_require__) {
        exports.f = __webpack_require__(57);
    }, /* 88 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = {
            default: __webpack_require__(89),
            __esModule: !0
        };
    }, /* 89 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(90), __webpack_require__(97), __webpack_require__(98), __webpack_require__(99), 
        module.exports = __webpack_require__(8).Symbol;
    }, /* 90 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        // ECMAScript 6 symbols shim
        var global = __webpack_require__(7), has = __webpack_require__(24), DESCRIPTORS = __webpack_require__(16), $export = __webpack_require__(6), redefine = __webpack_require__(52), META = __webpack_require__(40).KEY, $fails = __webpack_require__(17), shared = __webpack_require__(34), setToStringTag = __webpack_require__(56), uid = __webpack_require__(35), wks = __webpack_require__(57), wksExt = __webpack_require__(87), wksDefine = __webpack_require__(91), enumKeys = __webpack_require__(92), isArray = __webpack_require__(93), anObject = __webpack_require__(13), toIObject = __webpack_require__(25), toPrimitive = __webpack_require__(19), createDesc = __webpack_require__(20), _create = __webpack_require__(54), gOPNExt = __webpack_require__(94), $GOPD = __webpack_require__(96), $DP = __webpack_require__(12), $keys = __webpack_require__(22), gOPD = $GOPD.f, dP = $DP.f, gOPN = gOPNExt.f, $Symbol = global.Symbol, $JSON = global.JSON, _stringify = $JSON && $JSON.stringify, PROTOTYPE = "prototype", HIDDEN = wks("_hidden"), TO_PRIMITIVE = wks("toPrimitive"), isEnum = {}.propertyIsEnumerable, SymbolRegistry = shared("symbol-registry"), AllSymbols = shared("symbols"), OPSymbols = shared("op-symbols"), ObjectProto = Object[PROTOTYPE], USE_NATIVE = "function" == typeof $Symbol, QObject = global.QObject, setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild, setSymbolDesc = DESCRIPTORS && $fails(function() {
            return 7 != _create(dP({}, "a", {
                get: function() {
                    return dP(this, "a", {
                        value: 7
                    }).a;
                }
            })).a;
        }) ? function(it, key, D) {
            var protoDesc = gOPD(ObjectProto, key);
            protoDesc && delete ObjectProto[key], dP(it, key, D), protoDesc && it !== ObjectProto && dP(ObjectProto, key, protoDesc);
        } : dP, wrap = function(tag) {
            var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
            return sym._k = tag, sym;
        }, isSymbol = USE_NATIVE && "symbol" == typeof $Symbol.iterator ? function(it) {
            return "symbol" == typeof it;
        } : function(it) {
            return it instanceof $Symbol;
        }, $defineProperty = function(it, key, D) {
            return it === ObjectProto && $defineProperty(OPSymbols, key, D), anObject(it), key = toPrimitive(key, !0), 
            anObject(D), has(AllSymbols, key) ? (D.enumerable ? (has(it, HIDDEN) && it[HIDDEN][key] && (it[HIDDEN][key] = !1), 
            D = _create(D, {
                enumerable: createDesc(0, !1)
            })) : (has(it, HIDDEN) || dP(it, HIDDEN, createDesc(1, {})), it[HIDDEN][key] = !0), 
            setSymbolDesc(it, key, D)) : dP(it, key, D);
        }, $defineProperties = function(it, P) {
            anObject(it);
            for (var key, keys = enumKeys(P = toIObject(P)), i = 0, l = keys.length; l > i; ) $defineProperty(it, key = keys[i++], P[key]);
            return it;
        }, $create = function(it, P) {
            return void 0 === P ? _create(it) : $defineProperties(_create(it), P);
        }, $propertyIsEnumerable = function(key) {
            var E = isEnum.call(this, key = toPrimitive(key, !0));
            return !(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) && (!(E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key]) || E);
        }, $getOwnPropertyDescriptor = function(it, key) {
            if (it = toIObject(it), key = toPrimitive(key, !0), it !== ObjectProto || !has(AllSymbols, key) || has(OPSymbols, key)) {
                var D = gOPD(it, key);
                return !D || !has(AllSymbols, key) || has(it, HIDDEN) && it[HIDDEN][key] || (D.enumerable = !0), 
                D;
            }
        }, $getOwnPropertyNames = function(it) {
            for (var key, names = gOPN(toIObject(it)), result = [], i = 0; names.length > i; ) has(AllSymbols, key = names[i++]) || key == HIDDEN || key == META || result.push(key);
            return result;
        }, $getOwnPropertySymbols = function(it) {
            for (var key, IS_OP = it === ObjectProto, names = gOPN(IS_OP ? OPSymbols : toIObject(it)), result = [], i = 0; names.length > i; ) !has(AllSymbols, key = names[i++]) || IS_OP && !has(ObjectProto, key) || result.push(AllSymbols[key]);
            return result;
        };
        // 19.4.1.1 Symbol([description])
        USE_NATIVE || ($Symbol = function() {
            if (this instanceof $Symbol) throw TypeError("Symbol is not a constructor!");
            var tag = uid(arguments.length > 0 ? arguments[0] : void 0), $set = function(value) {
                this === ObjectProto && $set.call(OPSymbols, value), has(this, HIDDEN) && has(this[HIDDEN], tag) && (this[HIDDEN][tag] = !1), 
                setSymbolDesc(this, tag, createDesc(1, value));
            };
            return DESCRIPTORS && setter && setSymbolDesc(ObjectProto, tag, {
                configurable: !0,
                set: $set
            }), wrap(tag);
        }, redefine($Symbol[PROTOTYPE], "toString", function() {
            return this._k;
        }), $GOPD.f = $getOwnPropertyDescriptor, $DP.f = $defineProperty, __webpack_require__(95).f = gOPNExt.f = $getOwnPropertyNames, 
        __webpack_require__(74).f = $propertyIsEnumerable, __webpack_require__(73).f = $getOwnPropertySymbols, 
        DESCRIPTORS && !__webpack_require__(51) && redefine(ObjectProto, "propertyIsEnumerable", $propertyIsEnumerable, !0), 
        wksExt.f = function(name) {
            return wrap(wks(name));
        }), $export($export.G + $export.W + $export.F * !USE_NATIVE, {
            Symbol: $Symbol
        });
        for (var es6Symbols = "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), j = 0; es6Symbols.length > j; ) wks(es6Symbols[j++]);
        for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k; ) wksDefine(wellKnownSymbols[k++]);
        $export($export.S + $export.F * !USE_NATIVE, "Symbol", {
            // 19.4.2.1 Symbol.for(key)
            for: function(key) {
                return has(SymbolRegistry, key += "") ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
            },
            // 19.4.2.5 Symbol.keyFor(sym)
            keyFor: function(sym) {
                if (!isSymbol(sym)) throw TypeError(sym + " is not a symbol!");
                for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
            },
            useSetter: function() {
                setter = !0;
            },
            useSimple: function() {
                setter = !1;
            }
        }), $export($export.S + $export.F * !USE_NATIVE, "Object", {
            // 19.1.2.2 Object.create(O [, Properties])
            create: $create,
            // 19.1.2.4 Object.defineProperty(O, P, Attributes)
            defineProperty: $defineProperty,
            // 19.1.2.3 Object.defineProperties(O, Properties)
            defineProperties: $defineProperties,
            // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
            getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
            // 19.1.2.7 Object.getOwnPropertyNames(O)
            getOwnPropertyNames: $getOwnPropertyNames,
            // 19.1.2.8 Object.getOwnPropertySymbols(O)
            getOwnPropertySymbols: $getOwnPropertySymbols
        }), // 24.3.2 JSON.stringify(value [, replacer [, space]])
        $JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function() {
            var S = $Symbol();
            // MS Edge converts symbol values to JSON as {}
            // WebKit converts symbol values to JSON as null
            // V8 throws on boxed symbols
            return "[null]" != _stringify([ S ]) || "{}" != _stringify({
                a: S
            }) || "{}" != _stringify(Object(S));
        })), "JSON", {
            stringify: function(it) {
                if (void 0 !== it && !isSymbol(it)) {
                    for (// IE8 returns string on undefined
                    var replacer, $replacer, args = [ it ], i = 1; arguments.length > i; ) args.push(arguments[i++]);
                    return replacer = args[1], "function" == typeof replacer && ($replacer = replacer), 
                    !$replacer && isArray(replacer) || (replacer = function(key, value) {
                        if ($replacer && (value = $replacer.call(this, key, value)), !isSymbol(value)) return value;
                    }), args[1] = replacer, _stringify.apply($JSON, args);
                }
            }
        }), // 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
        $Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(11)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf), 
        // 19.4.3.5 Symbol.prototype[@@toStringTag]
        setToStringTag($Symbol, "Symbol"), // 20.2.1.9 Math[@@toStringTag]
        setToStringTag(Math, "Math", !0), // 24.3.3 JSON[@@toStringTag]
        setToStringTag(global.JSON, "JSON", !0);
    }, /* 91 */
    /***/
    function(module, exports, __webpack_require__) {
        var global = __webpack_require__(7), core = __webpack_require__(8), LIBRARY = __webpack_require__(51), wksExt = __webpack_require__(87), defineProperty = __webpack_require__(12).f;
        module.exports = function(name) {
            var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
            "_" == name.charAt(0) || name in $Symbol || defineProperty($Symbol, name, {
                value: wksExt.f(name)
            });
        };
    }, /* 92 */
    /***/
    function(module, exports, __webpack_require__) {
        // all enumerable object keys, includes symbols
        var getKeys = __webpack_require__(22), gOPS = __webpack_require__(73), pIE = __webpack_require__(74);
        module.exports = function(it) {
            var result = getKeys(it), getSymbols = gOPS.f;
            if (getSymbols) for (var key, symbols = getSymbols(it), isEnum = pIE.f, i = 0; symbols.length > i; ) isEnum.call(it, key = symbols[i++]) && result.push(key);
            return result;
        };
    }, /* 93 */
    /***/
    function(module, exports, __webpack_require__) {
        // 7.2.2 IsArray(argument)
        var cof = __webpack_require__(27);
        module.exports = Array.isArray || function(arg) {
            return "Array" == cof(arg);
        };
    }, /* 94 */
    /***/
    function(module, exports, __webpack_require__) {
        // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
        var toIObject = __webpack_require__(25), gOPN = __webpack_require__(95).f, toString = {}.toString, windowNames = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [], getWindowNames = function(it) {
            try {
                return gOPN(it);
            } catch (e) {
                return windowNames.slice();
            }
        };
        module.exports.f = function(it) {
            return windowNames && "[object Window]" == toString.call(it) ? getWindowNames(it) : gOPN(toIObject(it));
        };
    }, /* 95 */
    /***/
    function(module, exports, __webpack_require__) {
        // 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
        var $keys = __webpack_require__(23), hiddenKeys = __webpack_require__(36).concat("length", "prototype");
        exports.f = Object.getOwnPropertyNames || function(O) {
            return $keys(O, hiddenKeys);
        };
    }, /* 96 */
    /***/
    function(module, exports, __webpack_require__) {
        var pIE = __webpack_require__(74), createDesc = __webpack_require__(20), toIObject = __webpack_require__(25), toPrimitive = __webpack_require__(19), has = __webpack_require__(24), IE8_DOM_DEFINE = __webpack_require__(15), gOPD = Object.getOwnPropertyDescriptor;
        exports.f = __webpack_require__(16) ? gOPD : function(O, P) {
            if (O = toIObject(O), P = toPrimitive(P, !0), IE8_DOM_DEFINE) try {
                return gOPD(O, P);
            } catch (e) {}
            if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
        };
    }, /* 97 */
    /***/
    function(module, exports) {}, /* 98 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(91)("asyncIterator");
    }, /* 99 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(91)("observable");
    }, /* 100 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0;
        var _setPrototypeOf = __webpack_require__(101), _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf), _create = __webpack_require__(105), _create2 = _interopRequireDefault(_create), _typeof2 = __webpack_require__(84), _typeof3 = _interopRequireDefault(_typeof2);
        exports.default = function(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + ("undefined" == typeof superClass ? "undefined" : (0, 
            _typeof3.default)(superClass)));
            subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (_setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass);
        };
    }, /* 101 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = {
            default: __webpack_require__(102),
            __esModule: !0
        };
    }, /* 102 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(103), module.exports = __webpack_require__(8).Object.setPrototypeOf;
    }, /* 103 */
    /***/
    function(module, exports, __webpack_require__) {
        // 19.1.3.19 Object.setPrototypeOf(O, proto)
        var $export = __webpack_require__(6);
        $export($export.S, "Object", {
            setPrototypeOf: __webpack_require__(104).set
        });
    }, /* 104 */
    /***/
    function(module, exports, __webpack_require__) {
        // Works with __proto__ only. Old v8 can't work with null proto objects.
        /* eslint-disable no-proto */
        var isObject = __webpack_require__(14), anObject = __webpack_require__(13), check = function(O, proto) {
            if (anObject(O), !isObject(proto) && null !== proto) throw TypeError(proto + ": can't set as prototype!");
        };
        module.exports = {
            set: Object.setPrototypeOf || ("__proto__" in {} ? // eslint-disable-line
            function(test, buggy, set) {
                try {
                    set = __webpack_require__(9)(Function.call, __webpack_require__(96).f(Object.prototype, "__proto__").set, 2), 
                    set(test, []), buggy = !(test instanceof Array);
                } catch (e) {
                    buggy = !0;
                }
                return function(O, proto) {
                    return check(O, proto), buggy ? O.__proto__ = proto : set(O, proto), O;
                };
            }({}, !1) : void 0),
            check: check
        };
    }, /* 105 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = {
            default: __webpack_require__(106),
            __esModule: !0
        };
    }, /* 106 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(107);
        var $Object = __webpack_require__(8).Object;
        module.exports = function(P, D) {
            return $Object.create(P, D);
        };
    }, /* 107 */
    /***/
    function(module, exports, __webpack_require__) {
        var $export = __webpack_require__(6);
        // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
        $export($export.S, "Object", {
            create: __webpack_require__(54)
        });
    }, /* 108 */
    /***/
    function(module, exports) {
        module.exports = __WEBPACK_EXTERNAL_MODULE_108__;
    }, /* 109 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(process) {
            /**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
            if ("production" !== process.env.NODE_ENV) {
                var REACT_ELEMENT_TYPE = "function" == typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103, isValidElement = function(object) {
                    return "object" == typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
                }, throwOnDirectAccess = !0;
                module.exports = __webpack_require__(111)(isValidElement, throwOnDirectAccess);
            } else // By explicitly using `prop-types` you are opting into new production behavior.
            // http://fb.me/prop-types-in-prod
            module.exports = __webpack_require__(118)();
        }).call(exports, __webpack_require__(110));
    }, /* 110 */
    /***/
    function(module, exports) {
        function defaultSetTimout() {
            throw new Error("setTimeout has not been defined");
        }
        function defaultClearTimeout() {
            throw new Error("clearTimeout has not been defined");
        }
        function runTimeout(fun) {
            if (cachedSetTimeout === setTimeout) //normal enviroments in sane situations
            return setTimeout(fun, 0);
            // if setTimeout wasn't available but was latter defined
            if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) return cachedSetTimeout = setTimeout, 
            setTimeout(fun, 0);
            try {
                // when when somebody has screwed with setTimeout but no I.E. maddness
                return cachedSetTimeout(fun, 0);
            } catch (e) {
                try {
                    // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                    return cachedSetTimeout.call(null, fun, 0);
                } catch (e) {
                    // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                    return cachedSetTimeout.call(this, fun, 0);
                }
            }
        }
        function runClearTimeout(marker) {
            if (cachedClearTimeout === clearTimeout) //normal enviroments in sane situations
            return clearTimeout(marker);
            // if clearTimeout wasn't available but was latter defined
            if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) return cachedClearTimeout = clearTimeout, 
            clearTimeout(marker);
            try {
                // when when somebody has screwed with setTimeout but no I.E. maddness
                return cachedClearTimeout(marker);
            } catch (e) {
                try {
                    // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                    return cachedClearTimeout.call(null, marker);
                } catch (e) {
                    // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                    // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                    return cachedClearTimeout.call(this, marker);
                }
            }
        }
        function cleanUpNextTick() {
            draining && currentQueue && (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, 
            queue.length && drainQueue());
        }
        function drainQueue() {
            if (!draining) {
                var timeout = runTimeout(cleanUpNextTick);
                draining = !0;
                for (var len = queue.length; len; ) {
                    for (currentQueue = queue, queue = []; ++queueIndex < len; ) currentQueue && currentQueue[queueIndex].run();
                    queueIndex = -1, len = queue.length;
                }
                currentQueue = null, draining = !1, runClearTimeout(timeout);
            }
        }
        // v8 likes predictible objects
        function Item(fun, array) {
            this.fun = fun, this.array = array;
        }
        function noop() {}
        // shim for using process in browser
        var cachedSetTimeout, cachedClearTimeout, process = module.exports = {};
        !function() {
            try {
                cachedSetTimeout = "function" == typeof setTimeout ? setTimeout : defaultSetTimout;
            } catch (e) {
                cachedSetTimeout = defaultSetTimout;
            }
            try {
                cachedClearTimeout = "function" == typeof clearTimeout ? clearTimeout : defaultClearTimeout;
            } catch (e) {
                cachedClearTimeout = defaultClearTimeout;
            }
        }();
        var currentQueue, queue = [], draining = !1, queueIndex = -1;
        process.nextTick = function(fun) {
            var args = new Array(arguments.length - 1);
            if (arguments.length > 1) for (var i = 1; i < arguments.length; i++) args[i - 1] = arguments[i];
            queue.push(new Item(fun, args)), 1 !== queue.length || draining || runTimeout(drainQueue);
        }, Item.prototype.run = function() {
            this.fun.apply(null, this.array);
        }, process.title = "browser", process.browser = !0, process.env = {}, process.argv = [], 
        process.version = "", // empty string to avoid regexp issues
        process.versions = {}, process.on = noop, process.addListener = noop, process.once = noop, 
        process.off = noop, process.removeListener = noop, process.removeAllListeners = noop, 
        process.emit = noop, process.prependListener = noop, process.prependOnceListener = noop, 
        process.listeners = function(name) {
            return [];
        }, process.binding = function(name) {
            throw new Error("process.binding is not supported");
        }, process.cwd = function() {
            return "/";
        }, process.chdir = function(dir) {
            throw new Error("process.chdir is not supported");
        }, process.umask = function() {
            return 0;
        };
    }, /* 111 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(process) {
            /**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
            "use strict";
            var emptyFunction = __webpack_require__(112), invariant = __webpack_require__(113), warning = __webpack_require__(114), assign = __webpack_require__(115), ReactPropTypesSecret = __webpack_require__(116), checkPropTypes = __webpack_require__(117);
            module.exports = function(isValidElement, throwOnDirectAccess) {
                // Before Symbol spec.
                /**
	   * Returns the iterator method function contained on the iterable object.
	   *
	   * Be sure to invoke the function with the iterable as context:
	   *
	   *     var iteratorFn = getIteratorFn(myIterable);
	   *     if (iteratorFn) {
	   *       var iterator = iteratorFn.call(myIterable);
	   *       ...
	   *     }
	   *
	   * @param {?object} maybeIterable
	   * @return {?function}
	   */
                function getIteratorFn(maybeIterable) {
                    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
                    if ("function" == typeof iteratorFn) return iteratorFn;
                }
                /**
	   * inlined Object.is polyfill to avoid requiring consumers ship their own
	   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	   */
                /*eslint-disable no-self-compare*/
                function is(x, y) {
                    // SameValue algorithm
                    // SameValue algorithm
                    return x === y ? 0 !== x || 1 / x === 1 / y : x !== x && y !== y;
                }
                /*eslint-enable no-self-compare*/
                /**
	   * We use an Error-like object for backward compatibility as people may call
	   * PropTypes directly and inspect their output. However, we don't use real
	   * Errors anymore. We don't inspect their stack anyway, and creating them
	   * is prohibitively expensive if they are created too often, such as what
	   * happens in oneOfType() for any type before the one that matched.
	   */
                function PropTypeError(message) {
                    this.message = message, this.stack = "";
                }
                function createChainableTypeChecker(validate) {
                    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
                        if (componentName = componentName || ANONYMOUS, propFullName = propFullName || propName, 
                        secret !== ReactPropTypesSecret) if (throwOnDirectAccess) // New behavior only for users of `prop-types` package
                        invariant(!1, "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"); else if ("production" !== process.env.NODE_ENV && "undefined" != typeof console) {
                            // Old behavior for people using React.PropTypes
                            var cacheKey = componentName + ":" + propName;
                            !manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
                            manualPropTypeWarningCount < 3 && (warning(!1, "You are manually calling a React.PropTypes validation function for the `%s` prop on `%s`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details.", propFullName, componentName), 
                            manualPropTypeCallCache[cacheKey] = !0, manualPropTypeWarningCount++);
                        }
                        return null == props[propName] ? isRequired ? new PropTypeError(null === props[propName] ? "The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`.") : "The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`.")) : null : validate(props, propName, componentName, location, propFullName);
                    }
                    if ("production" !== process.env.NODE_ENV) var manualPropTypeCallCache = {}, manualPropTypeWarningCount = 0;
                    var chainedCheckType = checkType.bind(null, !1);
                    return chainedCheckType.isRequired = checkType.bind(null, !0), chainedCheckType;
                }
                function createPrimitiveTypeChecker(expectedType) {
                    function validate(props, propName, componentName, location, propFullName, secret) {
                        var propValue = props[propName], propType = getPropType(propValue);
                        if (propType !== expectedType) {
                            // `propValue` being instance of, say, date/regexp, pass the 'object'
                            // check, but we can offer a more precise error message here rather than
                            // 'of type `object`'.
                            var preciseType = getPreciseType(propValue);
                            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."));
                        }
                        return null;
                    }
                    return createChainableTypeChecker(validate);
                }
                function createAnyTypeChecker() {
                    return createChainableTypeChecker(emptyFunction.thatReturnsNull);
                }
                function createArrayOfTypeChecker(typeChecker) {
                    function validate(props, propName, componentName, location, propFullName) {
                        if ("function" != typeof typeChecker) return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
                        var propValue = props[propName];
                        if (!Array.isArray(propValue)) {
                            var propType = getPropType(propValue);
                            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
                        }
                        for (var i = 0; i < propValue.length; i++) {
                            var error = typeChecker(propValue, i, componentName, location, propFullName + "[" + i + "]", ReactPropTypesSecret);
                            if (error instanceof Error) return error;
                        }
                        return null;
                    }
                    return createChainableTypeChecker(validate);
                }
                function createElementTypeChecker() {
                    function validate(props, propName, componentName, location, propFullName) {
                        var propValue = props[propName];
                        if (!isValidElement(propValue)) {
                            var propType = getPropType(propValue);
                            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
                        }
                        return null;
                    }
                    return createChainableTypeChecker(validate);
                }
                function createInstanceTypeChecker(expectedClass) {
                    function validate(props, propName, componentName, location, propFullName) {
                        if (!(props[propName] instanceof expectedClass)) {
                            var expectedClassName = expectedClass.name || ANONYMOUS, actualClassName = getClassName(props[propName]);
                            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
                        }
                        return null;
                    }
                    return createChainableTypeChecker(validate);
                }
                function createEnumTypeChecker(expectedValues) {
                    function validate(props, propName, componentName, location, propFullName) {
                        for (var propValue = props[propName], i = 0; i < expectedValues.length; i++) if (is(propValue, expectedValues[i])) return null;
                        var valuesString = JSON.stringify(expectedValues);
                        return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + propValue + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
                    }
                    return Array.isArray(expectedValues) ? createChainableTypeChecker(validate) : ("production" !== process.env.NODE_ENV ? warning(!1, "Invalid argument supplied to oneOf, expected an instance of array.") : void 0, 
                    emptyFunction.thatReturnsNull);
                }
                function createObjectOfTypeChecker(typeChecker) {
                    function validate(props, propName, componentName, location, propFullName) {
                        if ("function" != typeof typeChecker) return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
                        var propValue = props[propName], propType = getPropType(propValue);
                        if ("object" !== propType) return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
                        for (var key in propValue) if (propValue.hasOwnProperty(key)) {
                            var error = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
                            if (error instanceof Error) return error;
                        }
                        return null;
                    }
                    return createChainableTypeChecker(validate);
                }
                function createUnionTypeChecker(arrayOfTypeCheckers) {
                    function validate(props, propName, componentName, location, propFullName) {
                        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
                            var checker = arrayOfTypeCheckers[i];
                            if (null == checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret)) return null;
                        }
                        return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`."));
                    }
                    if (!Array.isArray(arrayOfTypeCheckers)) return "production" !== process.env.NODE_ENV ? warning(!1, "Invalid argument supplied to oneOfType, expected an instance of array.") : void 0, 
                    emptyFunction.thatReturnsNull;
                    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
                        var checker = arrayOfTypeCheckers[i];
                        if ("function" != typeof checker) return warning(!1, "Invalid argument supplied to oneOfType. Expected an array of check functions, but received %s at index %s.", getPostfixForTypeWarning(checker), i), 
                        emptyFunction.thatReturnsNull;
                    }
                    return createChainableTypeChecker(validate);
                }
                function createNodeChecker() {
                    function validate(props, propName, componentName, location, propFullName) {
                        return isNode(props[propName]) ? null : new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
                    }
                    return createChainableTypeChecker(validate);
                }
                function createShapeTypeChecker(shapeTypes) {
                    function validate(props, propName, componentName, location, propFullName) {
                        var propValue = props[propName], propType = getPropType(propValue);
                        if ("object" !== propType) return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
                        for (var key in shapeTypes) {
                            var checker = shapeTypes[key];
                            if (checker) {
                                var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
                                if (error) return error;
                            }
                        }
                        return null;
                    }
                    return createChainableTypeChecker(validate);
                }
                function createStrictShapeTypeChecker(shapeTypes) {
                    function validate(props, propName, componentName, location, propFullName) {
                        var propValue = props[propName], propType = getPropType(propValue);
                        if ("object" !== propType) return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
                        // We need to check all keys in case some are required but missing from
                        // props.
                        var allKeys = assign({}, props[propName], shapeTypes);
                        for (var key in allKeys) {
                            var checker = shapeTypes[key];
                            if (!checker) return new PropTypeError("Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  "));
                            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
                            if (error) return error;
                        }
                        return null;
                    }
                    return createChainableTypeChecker(validate);
                }
                function isNode(propValue) {
                    switch (typeof propValue) {
                      case "number":
                      case "string":
                      case "undefined":
                        return !0;

                      case "boolean":
                        return !propValue;

                      case "object":
                        if (Array.isArray(propValue)) return propValue.every(isNode);
                        if (null === propValue || isValidElement(propValue)) return !0;
                        var iteratorFn = getIteratorFn(propValue);
                        if (!iteratorFn) return !1;
                        var step, iterator = iteratorFn.call(propValue);
                        if (iteratorFn !== propValue.entries) {
                            for (;!(step = iterator.next()).done; ) if (!isNode(step.value)) return !1;
                        } else // Iterator will provide entry [k,v] tuples rather than values.
                        for (;!(step = iterator.next()).done; ) {
                            var entry = step.value;
                            if (entry && !isNode(entry[1])) return !1;
                        }
                        return !0;

                      default:
                        return !1;
                    }
                }
                function isSymbol(propType, propValue) {
                    // Native Symbol.
                    // Native Symbol.
                    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
                    return "symbol" === propType || ("Symbol" === propValue["@@toStringTag"] || "function" == typeof Symbol && propValue instanceof Symbol);
                }
                // Equivalent of `typeof` but with special handling for array and regexp.
                function getPropType(propValue) {
                    var propType = typeof propValue;
                    return Array.isArray(propValue) ? "array" : propValue instanceof RegExp ? "object" : isSymbol(propType, propValue) ? "symbol" : propType;
                }
                // This handles more types than `getPropType`. Only used for error messages.
                // See `createPrimitiveTypeChecker`.
                function getPreciseType(propValue) {
                    if ("undefined" == typeof propValue || null === propValue) return "" + propValue;
                    var propType = getPropType(propValue);
                    if ("object" === propType) {
                        if (propValue instanceof Date) return "date";
                        if (propValue instanceof RegExp) return "regexp";
                    }
                    return propType;
                }
                // Returns a string that is postfixed to a warning about an invalid type.
                // For example, "undefined" or "of type array"
                function getPostfixForTypeWarning(value) {
                    var type = getPreciseType(value);
                    switch (type) {
                      case "array":
                      case "object":
                        return "an " + type;

                      case "boolean":
                      case "date":
                      case "regexp":
                        return "a " + type;

                      default:
                        return type;
                    }
                }
                // Returns class name of the object, if any.
                function getClassName(propValue) {
                    return propValue.constructor && propValue.constructor.name ? propValue.constructor.name : ANONYMOUS;
                }
                /* global Symbol */
                var ITERATOR_SYMBOL = "function" == typeof Symbol && Symbol.iterator, FAUX_ITERATOR_SYMBOL = "@@iterator", ANONYMOUS = "<<anonymous>>", ReactPropTypes = {
                    array: createPrimitiveTypeChecker("array"),
                    bool: createPrimitiveTypeChecker("boolean"),
                    func: createPrimitiveTypeChecker("function"),
                    number: createPrimitiveTypeChecker("number"),
                    object: createPrimitiveTypeChecker("object"),
                    string: createPrimitiveTypeChecker("string"),
                    symbol: createPrimitiveTypeChecker("symbol"),
                    any: createAnyTypeChecker(),
                    arrayOf: createArrayOfTypeChecker,
                    element: createElementTypeChecker(),
                    instanceOf: createInstanceTypeChecker,
                    node: createNodeChecker(),
                    objectOf: createObjectOfTypeChecker,
                    oneOf: createEnumTypeChecker,
                    oneOfType: createUnionTypeChecker,
                    shape: createShapeTypeChecker,
                    exact: createStrictShapeTypeChecker
                };
                // Make `instanceof Error` still work for returned errors.
                return PropTypeError.prototype = Error.prototype, ReactPropTypes.checkPropTypes = checkPropTypes, 
                ReactPropTypes.PropTypes = ReactPropTypes, ReactPropTypes;
            };
        }).call(exports, __webpack_require__(110));
    }, /* 112 */
    /***/
    function(module, exports) {
        "use strict";
        /**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
        function makeEmptyFunction(arg) {
            return function() {
                return arg;
            };
        }
        /**
	 * This function accepts and discards inputs; it has no side effects. This is
	 * primarily useful idiomatically for overridable function endpoints which
	 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
	 */
        var emptyFunction = function() {};
        emptyFunction.thatReturns = makeEmptyFunction, emptyFunction.thatReturnsFalse = makeEmptyFunction(!1), 
        emptyFunction.thatReturnsTrue = makeEmptyFunction(!0), emptyFunction.thatReturnsNull = makeEmptyFunction(null), 
        emptyFunction.thatReturnsThis = function() {
            return this;
        }, emptyFunction.thatReturnsArgument = function(arg) {
            return arg;
        }, module.exports = emptyFunction;
    }, /* 113 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(process) {
            /**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
            "use strict";
            function invariant(condition, format, a, b, c, d, e, f) {
                if (validateFormat(format), !condition) {
                    var error;
                    if (void 0 === format) error = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."); else {
                        var args = [ a, b, c, d, e, f ], argIndex = 0;
                        error = new Error(format.replace(/%s/g, function() {
                            return args[argIndex++];
                        })), error.name = "Invariant Violation";
                    }
                    // we don't care about invariant's own frame
                    throw error.framesToPop = 1, error;
                }
            }
            /**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */
            var validateFormat = function(format) {};
            "production" !== process.env.NODE_ENV && (validateFormat = function(format) {
                if (void 0 === format) throw new Error("invariant requires an error message argument");
            }), module.exports = invariant;
        }).call(exports, __webpack_require__(110));
    }, /* 114 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(process) {
            /**
	 * Copyright (c) 2014-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
            "use strict";
            var emptyFunction = __webpack_require__(112), warning = emptyFunction;
            if ("production" !== process.env.NODE_ENV) {
                var printWarning = function(format) {
                    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];
                    var argIndex = 0, message = "Warning: " + format.replace(/%s/g, function() {
                        return args[argIndex++];
                    });
                    "undefined" != typeof console && console.error(message);
                    try {
                        // --- Welcome to debugging React ---
                        // This error was thrown as a convenience so that you can use this stack
                        // to find the callsite that caused this warning to fire.
                        throw new Error(message);
                    } catch (x) {}
                };
                warning = function(condition, format) {
                    if (void 0 === format) throw new Error("`warning(condition, format, ...args)` requires a warning message argument");
                    if (0 !== format.indexOf("Failed Composite propType: ") && !condition) {
                        for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) args[_key2 - 2] = arguments[_key2];
                        printWarning.apply(void 0, [ format ].concat(args));
                    }
                };
            }
            module.exports = warning;
        }).call(exports, __webpack_require__(110));
    }, /* 115 */
    /***/
    function(module, exports) {
        /*
	object-assign
	(c) Sindre Sorhus
	@license MIT
	*/
        "use strict";
        function toObject(val) {
            if (null === val || void 0 === val) throw new TypeError("Object.assign cannot be called with null or undefined");
            return Object(val);
        }
        function shouldUseNative() {
            try {
                if (!Object.assign) return !1;
                // Detect buggy property enumeration order in older V8 versions.
                // https://bugs.chromium.org/p/v8/issues/detail?id=4118
                var test1 = new String("abc");
                if (// eslint-disable-line no-new-wrappers
                test1[5] = "de", "5" === Object.getOwnPropertyNames(test1)[0]) return !1;
                for (var test2 = {}, i = 0; i < 10; i++) test2["_" + String.fromCharCode(i)] = i;
                var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
                    return test2[n];
                });
                if ("0123456789" !== order2.join("")) return !1;
                // https://bugs.chromium.org/p/v8/issues/detail?id=3056
                var test3 = {};
                return "abcdefghijklmnopqrst".split("").forEach(function(letter) {
                    test3[letter] = letter;
                }), "abcdefghijklmnopqrst" === Object.keys(Object.assign({}, test3)).join("");
            } catch (err) {
                // We don't expect any of the above to throw, but better to be safe.
                return !1;
            }
        }
        /* eslint-disable no-unused-vars */
        var getOwnPropertySymbols = Object.getOwnPropertySymbols, hasOwnProperty = Object.prototype.hasOwnProperty, propIsEnumerable = Object.prototype.propertyIsEnumerable;
        module.exports = shouldUseNative() ? Object.assign : function(target, source) {
            for (var from, symbols, to = toObject(target), s = 1; s < arguments.length; s++) {
                from = Object(arguments[s]);
                for (var key in from) hasOwnProperty.call(from, key) && (to[key] = from[key]);
                if (getOwnPropertySymbols) {
                    symbols = getOwnPropertySymbols(from);
                    for (var i = 0; i < symbols.length; i++) propIsEnumerable.call(from, symbols[i]) && (to[symbols[i]] = from[symbols[i]]);
                }
            }
            return to;
        };
    }, /* 116 */
    /***/
    function(module, exports) {
        /**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
        "use strict";
        var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
        module.exports = ReactPropTypesSecret;
    }, /* 117 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(process) {
            /**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
            "use strict";
            /**
	 * Assert that the values match with the type specs.
	 * Error messages are memorized and will only be shown once.
	 *
	 * @param {object} typeSpecs Map of name to a ReactPropType
	 * @param {object} values Runtime values that need to be type-checked
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @param {string} componentName Name of the component for error messages.
	 * @param {?Function} getStack Returns the component stack.
	 * @private
	 */
            function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
                if ("production" !== process.env.NODE_ENV) for (var typeSpecName in typeSpecs) if (typeSpecs.hasOwnProperty(typeSpecName)) {
                    var error;
                    // Prop type validation may throw. In case they do, we don't want to
                    // fail the render phase where it didn't fail before. So we log it.
                    // After these have been cleaned up, we'll let them throw.
                    try {
                        // This is intentionally an invariant that gets caught. It's the same
                        // behavior as without this statement except with a better message.
                        invariant("function" == typeof typeSpecs[typeSpecName], "%s: %s type `%s` is invalid; it must be a function, usually from the `prop-types` package, but received `%s`.", componentName || "React class", location, typeSpecName, typeof typeSpecs[typeSpecName]), 
                        error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
                    } catch (ex) {
                        error = ex;
                    }
                    if (warning(!error || error instanceof Error, "%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error), 
                    error instanceof Error && !(error.message in loggedTypeFailures)) {
                        // Only monitor this failure once because there tends to be a lot of the
                        // same error.
                        loggedTypeFailures[error.message] = !0;
                        var stack = getStack ? getStack() : "";
                        warning(!1, "Failed %s type: %s%s", location, error.message, null != stack ? stack : "");
                    }
                }
            }
            if ("production" !== process.env.NODE_ENV) var invariant = __webpack_require__(113), warning = __webpack_require__(114), ReactPropTypesSecret = __webpack_require__(116), loggedTypeFailures = {};
            module.exports = checkPropTypes;
        }).call(exports, __webpack_require__(110));
    }, /* 118 */
    /***/
    function(module, exports, __webpack_require__) {
        /**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
        "use strict";
        var emptyFunction = __webpack_require__(112), invariant = __webpack_require__(113), ReactPropTypesSecret = __webpack_require__(116);
        module.exports = function() {
            function shim(props, propName, componentName, location, propFullName, secret) {
                secret !== ReactPropTypesSecret && invariant(!1, "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
            }
            function getShim() {
                return shim;
            }
            shim.isRequired = shim;
            // Important!
            // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
            var ReactPropTypes = {
                array: shim,
                bool: shim,
                func: shim,
                number: shim,
                object: shim,
                string: shim,
                symbol: shim,
                any: shim,
                arrayOf: getShim,
                element: shim,
                instanceOf: getShim,
                node: shim,
                objectOf: getShim,
                oneOf: getShim,
                oneOfType: getShim,
                shape: getShim,
                exact: getShim
            };
            return ReactPropTypes.checkPropTypes = emptyFunction, ReactPropTypes.PropTypes = ReactPropTypes, 
            ReactPropTypes;
        };
    }, /* 119 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function normalizeLineEndings(str) {
            return str ? str.replace(/\r\n|\r/g, "\n") : str;
        }
        var React = __webpack_require__(108), PropTypes = (__webpack_require__(120), __webpack_require__(109)), className = __webpack_require__(121), debounce = __webpack_require__(122), isEqual = __webpack_require__(123), createReactClass = __webpack_require__(125), CodeMirror = createReactClass({
            propTypes: {
                autoFocus: PropTypes.bool,
                className: PropTypes.any,
                codeMirrorInstance: PropTypes.func,
                defaultValue: PropTypes.string,
                name: PropTypes.string,
                onChange: PropTypes.func,
                onCursorActivity: PropTypes.func,
                onFocusChange: PropTypes.func,
                onScroll: PropTypes.func,
                options: PropTypes.object,
                path: PropTypes.string,
                value: PropTypes.string,
                preserveScrollPosition: PropTypes.bool
            },
            getDefaultProps: function() {
                return {
                    preserveScrollPosition: !1
                };
            },
            getCodeMirrorInstance: function() {
                return this.props.codeMirrorInstance || __webpack_require__(128);
            },
            getInitialState: function() {
                return {
                    isFocused: !1
                };
            },
            componentWillMount: function() {
                this.componentWillReceiveProps = debounce(this.componentWillReceiveProps, 0), this.props.path && console.error("Warning: react-codemirror: the `path` prop has been changed to `name`");
            },
            componentDidMount: function() {
                var codeMirrorInstance = this.getCodeMirrorInstance();
                this.codeMirror = codeMirrorInstance.fromTextArea(this.textareaNode, this.props.options), 
                this.codeMirror.on("change", this.codemirrorValueChanged), this.codeMirror.on("cursorActivity", this.cursorActivity), 
                this.codeMirror.on("focus", this.focusChanged.bind(this, !0)), this.codeMirror.on("blur", this.focusChanged.bind(this, !1)), 
                this.codeMirror.on("scroll", this.scrollChanged), this.codeMirror.setValue(this.props.defaultValue || this.props.value || "");
            },
            componentWillUnmount: function() {
                // is there a lighter-weight way to remove the cm instance?
                this.codeMirror && this.codeMirror.toTextArea();
            },
            componentWillReceiveProps: function(nextProps) {
                if (this.codeMirror && void 0 !== nextProps.value && nextProps.value !== this.props.value && normalizeLineEndings(this.codeMirror.getValue()) !== normalizeLineEndings(nextProps.value)) if (this.props.preserveScrollPosition) {
                    var prevScrollPosition = this.codeMirror.getScrollInfo();
                    this.codeMirror.setValue(nextProps.value), this.codeMirror.scrollTo(prevScrollPosition.left, prevScrollPosition.top);
                } else this.codeMirror.setValue(nextProps.value);
                if ("object" == typeof nextProps.options) for (var optionName in nextProps.options) nextProps.options.hasOwnProperty(optionName) && this.setOptionIfChanged(optionName, nextProps.options[optionName]);
            },
            setOptionIfChanged: function(optionName, newValue) {
                var oldValue = this.codeMirror.getOption(optionName);
                isEqual(oldValue, newValue) || this.codeMirror.setOption(optionName, newValue);
            },
            getCodeMirror: function() {
                return this.codeMirror;
            },
            focus: function() {
                this.codeMirror && this.codeMirror.focus();
            },
            focusChanged: function(focused) {
                this.setState({
                    isFocused: focused
                }), this.props.onFocusChange && this.props.onFocusChange(focused);
            },
            cursorActivity: function(cm) {
                this.props.onCursorActivity && this.props.onCursorActivity(cm);
            },
            scrollChanged: function(cm) {
                this.props.onScroll && this.props.onScroll(cm.getScrollInfo());
            },
            codemirrorValueChanged: function(doc, change) {
                this.props.onChange && "setValue" !== change.origin && this.props.onChange(doc.getValue(), change);
            },
            render: function() {
                var _this = this, editorClassName = className("ReactCodeMirror", this.state.isFocused ? "ReactCodeMirror--focused" : null, this.props.className);
                return React.createElement("div", {
                    className: editorClassName
                }, React.createElement("textarea", {
                    ref: function(ref) {
                        return _this.textareaNode = ref;
                    },
                    name: this.props.name || this.props.path,
                    defaultValue: this.props.value,
                    autoComplete: "off",
                    autoFocus: this.props.autoFocus
                }));
            }
        });
        module.exports = CodeMirror;
    }, /* 120 */
    /***/
    function(module, exports) {
        module.exports = __WEBPACK_EXTERNAL_MODULE_120__;
    }, /* 121 */
    /***/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
        /*!
	  Copyright (c) 2016 Jed Watson.
	  Licensed under the MIT License (MIT), see
	  http://jedwatson.github.io/classnames
	*/
        /* global define */
        !function() {
            "use strict";
            function classNames() {
                for (var classes = [], i = 0; i < arguments.length; i++) {
                    var arg = arguments[i];
                    if (arg) {
                        var argType = typeof arg;
                        if ("string" === argType || "number" === argType) classes.push(arg); else if (Array.isArray(arg)) classes.push(classNames.apply(null, arg)); else if ("object" === argType) for (var key in arg) hasOwn.call(arg, key) && arg[key] && classes.push(key);
                    }
                }
                return classes.join(" ");
            }
            var hasOwn = {}.hasOwnProperty;
            "undefined" != typeof module && module.exports ? module.exports = classNames : (__WEBPACK_AMD_DEFINE_ARRAY__ = [], 
            __WEBPACK_AMD_DEFINE_RESULT__ = function() {
                return classNames;
            }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), // register as 'classnames', consistent with npm package name
            !(void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)));
        }();
    }, /* 122 */
    /***/
    function(module, exports) {
        /* WEBPACK VAR INJECTION */
        (function(global) {
            /**
	 * Creates a debounced function that delays invoking `func` until after `wait`
	 * milliseconds have elapsed since the last time the debounced function was
	 * invoked. The debounced function comes with a `cancel` method to cancel
	 * delayed `func` invocations and a `flush` method to immediately invoke them.
	 * Provide `options` to indicate whether `func` should be invoked on the
	 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
	 * with the last arguments provided to the debounced function. Subsequent
	 * calls to the debounced function return the result of the last `func`
	 * invocation.
	 *
	 * **Note:** If `leading` and `trailing` options are `true`, `func` is
	 * invoked on the trailing edge of the timeout only if the debounced function
	 * is invoked more than once during the `wait` timeout.
	 *
	 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
	 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
	 *
	 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	 * for details over the differences between `_.debounce` and `_.throttle`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to debounce.
	 * @param {number} [wait=0] The number of milliseconds to delay.
	 * @param {Object} [options={}] The options object.
	 * @param {boolean} [options.leading=false]
	 *  Specify invoking on the leading edge of the timeout.
	 * @param {number} [options.maxWait]
	 *  The maximum time `func` is allowed to be delayed before it's invoked.
	 * @param {boolean} [options.trailing=true]
	 *  Specify invoking on the trailing edge of the timeout.
	 * @returns {Function} Returns the new debounced function.
	 * @example
	 *
	 * // Avoid costly calculations while the window size is in flux.
	 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
	 *
	 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
	 * jQuery(element).on('click', _.debounce(sendMail, 300, {
	 *   'leading': true,
	 *   'trailing': false
	 * }));
	 *
	 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
	 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
	 * var source = new EventSource('/stream');
	 * jQuery(source).on('message', debounced);
	 *
	 * // Cancel the trailing debounced invocation.
	 * jQuery(window).on('popstate', debounced.cancel);
	 */
            function debounce(func, wait, options) {
                function invokeFunc(time) {
                    var args = lastArgs, thisArg = lastThis;
                    return lastArgs = lastThis = void 0, lastInvokeTime = time, result = func.apply(thisArg, args);
                }
                function leadingEdge(time) {
                    // Invoke the leading edge.
                    // Reset any `maxWait` timer.
                    // Start the timer for the trailing edge.
                    return lastInvokeTime = time, timerId = setTimeout(timerExpired, wait), leading ? invokeFunc(time) : result;
                }
                function remainingWait(time) {
                    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result = wait - timeSinceLastCall;
                    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
                }
                function shouldInvoke(time) {
                    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
                    // Either this is the first call, activity has stopped and we're at the
                    // trailing edge, the system time has gone backwards and we're treating
                    // it as the trailing edge, or we've hit the `maxWait` limit.
                    return void 0 === lastCallTime || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
                }
                function timerExpired() {
                    var time = now();
                    // Restart the timer.
                    return shouldInvoke(time) ? trailingEdge(time) : void (timerId = setTimeout(timerExpired, remainingWait(time)));
                }
                function trailingEdge(time) {
                    // Only invoke if we have `lastArgs` which means `func` has been
                    // debounced at least once.
                    // Only invoke if we have `lastArgs` which means `func` has been
                    // debounced at least once.
                    return timerId = void 0, trailing && lastArgs ? invokeFunc(time) : (lastArgs = lastThis = void 0, 
                    result);
                }
                function cancel() {
                    void 0 !== timerId && clearTimeout(timerId), lastInvokeTime = 0, lastArgs = lastCallTime = lastThis = timerId = void 0;
                }
                function flush() {
                    return void 0 === timerId ? result : trailingEdge(now());
                }
                function debounced() {
                    var time = now(), isInvoking = shouldInvoke(time);
                    if (lastArgs = arguments, lastThis = this, lastCallTime = time, isInvoking) {
                        if (void 0 === timerId) return leadingEdge(lastCallTime);
                        if (maxing) // Handle invocations in a tight loop.
                        return timerId = setTimeout(timerExpired, wait), invokeFunc(lastCallTime);
                    }
                    return void 0 === timerId && (timerId = setTimeout(timerExpired, wait)), result;
                }
                var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = !1, maxing = !1, trailing = !0;
                if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
                return wait = toNumber(wait) || 0, isObject(options) && (leading = !!options.leading, 
                maxing = "maxWait" in options, maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait, 
                trailing = "trailing" in options ? !!options.trailing : trailing), debounced.cancel = cancel, 
                debounced.flush = flush, debounced;
            }
            /**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
            function isObject(value) {
                var type = typeof value;
                return !!value && ("object" == type || "function" == type);
            }
            /**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
            function isObjectLike(value) {
                return !!value && "object" == typeof value;
            }
            /**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
            function isSymbol(value) {
                return "symbol" == typeof value || isObjectLike(value) && objectToString.call(value) == symbolTag;
            }
            /**
	 * Converts `value` to a number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {number} Returns the number.
	 * @example
	 *
	 * _.toNumber(3.2);
	 * // => 3.2
	 *
	 * _.toNumber(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toNumber(Infinity);
	 * // => Infinity
	 *
	 * _.toNumber('3.2');
	 * // => 3.2
	 */
            function toNumber(value) {
                if ("number" == typeof value) return value;
                if (isSymbol(value)) return NAN;
                if (isObject(value)) {
                    var other = "function" == typeof value.valueOf ? value.valueOf() : value;
                    value = isObject(other) ? other + "" : other;
                }
                if ("string" != typeof value) return 0 === value ? value : +value;
                value = value.replace(reTrim, "");
                var isBinary = reIsBinary.test(value);
                return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
            }
            /**
	 * lodash (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */
            /** Used as the `TypeError` message for "Functions" methods. */
            var FUNC_ERROR_TEXT = "Expected a function", NAN = NaN, symbolTag = "[object Symbol]", reTrim = /^\s+|\s+$/g, reIsBadHex = /^[-+]0x[0-9a-f]+$/i, reIsBinary = /^0b[01]+$/i, reIsOctal = /^0o[0-7]+$/i, freeParseInt = parseInt, freeGlobal = "object" == typeof global && global && global.Object === Object && global, freeSelf = "object" == typeof self && self && self.Object === Object && self, root = freeGlobal || freeSelf || Function("return this")(), objectProto = Object.prototype, objectToString = objectProto.toString, nativeMax = Math.max, nativeMin = Math.min, now = function() {
                return root.Date.now();
            };
            module.exports = debounce;
        }).call(exports, function() {
            return this;
        }());
    }, /* 123 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(global, module) {
            /**
	 * A specialized version of `_.filter` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 */
            function arrayFilter(array, predicate) {
                for (var index = -1, length = null == array ? 0 : array.length, resIndex = 0, result = []; ++index < length; ) {
                    var value = array[index];
                    predicate(value, index, array) && (result[resIndex++] = value);
                }
                return result;
            }
            /**
	 * Appends the elements of `values` to `array`.
	 *
	 * @private
	 * @param {Array} array The array to modify.
	 * @param {Array} values The values to append.
	 * @returns {Array} Returns `array`.
	 */
            function arrayPush(array, values) {
                for (var index = -1, length = values.length, offset = array.length; ++index < length; ) array[offset + index] = values[index];
                return array;
            }
            /**
	 * A specialized version of `_.some` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if any element passes the predicate check,
	 *  else `false`.
	 */
            function arraySome(array, predicate) {
                for (var index = -1, length = null == array ? 0 : array.length; ++index < length; ) if (predicate(array[index], index, array)) return !0;
                return !1;
            }
            /**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
            function baseTimes(n, iteratee) {
                for (var index = -1, result = Array(n); ++index < n; ) result[index] = iteratee(index);
                return result;
            }
            /**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */
            function baseUnary(func) {
                return function(value) {
                    return func(value);
                };
            }
            /**
	 * Checks if a `cache` value for `key` exists.
	 *
	 * @private
	 * @param {Object} cache The cache to query.
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
            function cacheHas(cache, key) {
                return cache.has(key);
            }
            /**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
            function getValue(object, key) {
                return null == object ? void 0 : object[key];
            }
            /**
	 * Converts `map` to its key-value pairs.
	 *
	 * @private
	 * @param {Object} map The map to convert.
	 * @returns {Array} Returns the key-value pairs.
	 */
            function mapToArray(map) {
                var index = -1, result = Array(map.size);
                return map.forEach(function(value, key) {
                    result[++index] = [ key, value ];
                }), result;
            }
            /**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
            function overArg(func, transform) {
                return function(arg) {
                    return func(transform(arg));
                };
            }
            /**
	 * Converts `set` to an array of its values.
	 *
	 * @private
	 * @param {Object} set The set to convert.
	 * @returns {Array} Returns the values.
	 */
            function setToArray(set) {
                var index = -1, result = Array(set.size);
                return set.forEach(function(value) {
                    result[++index] = value;
                }), result;
            }
            /**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
            function Hash(entries) {
                var index = -1, length = null == entries ? 0 : entries.length;
                for (this.clear(); ++index < length; ) {
                    var entry = entries[index];
                    this.set(entry[0], entry[1]);
                }
            }
            /**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
            function hashClear() {
                this.__data__ = nativeCreate ? nativeCreate(null) : {}, this.size = 0;
            }
            /**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
            function hashDelete(key) {
                var result = this.has(key) && delete this.__data__[key];
                return this.size -= result ? 1 : 0, result;
            }
            /**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
            function hashGet(key) {
                var data = this.__data__;
                if (nativeCreate) {
                    var result = data[key];
                    return result === HASH_UNDEFINED ? void 0 : result;
                }
                return hasOwnProperty.call(data, key) ? data[key] : void 0;
            }
            /**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
            function hashHas(key) {
                var data = this.__data__;
                return nativeCreate ? void 0 !== data[key] : hasOwnProperty.call(data, key);
            }
            /**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
            function hashSet(key, value) {
                var data = this.__data__;
                return this.size += this.has(key) ? 0 : 1, data[key] = nativeCreate && void 0 === value ? HASH_UNDEFINED : value, 
                this;
            }
            /**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
            function ListCache(entries) {
                var index = -1, length = null == entries ? 0 : entries.length;
                for (this.clear(); ++index < length; ) {
                    var entry = entries[index];
                    this.set(entry[0], entry[1]);
                }
            }
            /**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
            function listCacheClear() {
                this.__data__ = [], this.size = 0;
            }
            /**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
            function listCacheDelete(key) {
                var data = this.__data__, index = assocIndexOf(data, key);
                if (index < 0) return !1;
                var lastIndex = data.length - 1;
                return index == lastIndex ? data.pop() : splice.call(data, index, 1), --this.size, 
                !0;
            }
            /**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
            function listCacheGet(key) {
                var data = this.__data__, index = assocIndexOf(data, key);
                return index < 0 ? void 0 : data[index][1];
            }
            /**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
            function listCacheHas(key) {
                return assocIndexOf(this.__data__, key) > -1;
            }
            /**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
            function listCacheSet(key, value) {
                var data = this.__data__, index = assocIndexOf(data, key);
                return index < 0 ? (++this.size, data.push([ key, value ])) : data[index][1] = value, 
                this;
            }
            /**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
            function MapCache(entries) {
                var index = -1, length = null == entries ? 0 : entries.length;
                for (this.clear(); ++index < length; ) {
                    var entry = entries[index];
                    this.set(entry[0], entry[1]);
                }
            }
            /**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
            function mapCacheClear() {
                this.size = 0, this.__data__ = {
                    hash: new Hash(),
                    map: new (Map || ListCache)(),
                    string: new Hash()
                };
            }
            /**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
            function mapCacheDelete(key) {
                var result = getMapData(this, key).delete(key);
                return this.size -= result ? 1 : 0, result;
            }
            /**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
            function mapCacheGet(key) {
                return getMapData(this, key).get(key);
            }
            /**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
            function mapCacheHas(key) {
                return getMapData(this, key).has(key);
            }
            /**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
            function mapCacheSet(key, value) {
                var data = getMapData(this, key), size = data.size;
                return data.set(key, value), this.size += data.size == size ? 0 : 1, this;
            }
            /**
	 *
	 * Creates an array cache object to store unique values.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [values] The values to cache.
	 */
            function SetCache(values) {
                var index = -1, length = null == values ? 0 : values.length;
                for (this.__data__ = new MapCache(); ++index < length; ) this.add(values[index]);
            }
            /**
	 * Adds `value` to the array cache.
	 *
	 * @private
	 * @name add
	 * @memberOf SetCache
	 * @alias push
	 * @param {*} value The value to cache.
	 * @returns {Object} Returns the cache instance.
	 */
            function setCacheAdd(value) {
                return this.__data__.set(value, HASH_UNDEFINED), this;
            }
            /**
	 * Checks if `value` is in the array cache.
	 *
	 * @private
	 * @name has
	 * @memberOf SetCache
	 * @param {*} value The value to search for.
	 * @returns {number} Returns `true` if `value` is found, else `false`.
	 */
            function setCacheHas(value) {
                return this.__data__.has(value);
            }
            /**
	 * Creates a stack cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
            function Stack(entries) {
                var data = this.__data__ = new ListCache(entries);
                this.size = data.size;
            }
            /**
	 * Removes all key-value entries from the stack.
	 *
	 * @private
	 * @name clear
	 * @memberOf Stack
	 */
            function stackClear() {
                this.__data__ = new ListCache(), this.size = 0;
            }
            /**
	 * Removes `key` and its value from the stack.
	 *
	 * @private
	 * @name delete
	 * @memberOf Stack
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
            function stackDelete(key) {
                var data = this.__data__, result = data.delete(key);
                return this.size = data.size, result;
            }
            /**
	 * Gets the stack value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Stack
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
            function stackGet(key) {
                return this.__data__.get(key);
            }
            /**
	 * Checks if a stack value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Stack
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
            function stackHas(key) {
                return this.__data__.has(key);
            }
            /**
	 * Sets the stack `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Stack
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the stack cache instance.
	 */
            function stackSet(key, value) {
                var data = this.__data__;
                if (data instanceof ListCache) {
                    var pairs = data.__data__;
                    if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) return pairs.push([ key, value ]), 
                    this.size = ++data.size, this;
                    data = this.__data__ = new MapCache(pairs);
                }
                return data.set(key, value), this.size = data.size, this;
            }
            /**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
            function arrayLikeKeys(value, inherited) {
                var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
                for (var key in value) !inherited && !hasOwnProperty.call(value, key) || skipIndexes && (// Safari 9 has enumerable `arguments.length` in strict mode.
                "length" == key || // Node.js 0.10 has enumerable non-index properties on buffers.
                isBuff && ("offset" == key || "parent" == key) || // PhantomJS 2 has enumerable non-index properties on typed arrays.
                isType && ("buffer" == key || "byteLength" == key || "byteOffset" == key) || // Skip index properties.
                isIndex(key, length)) || result.push(key);
                return result;
            }
            /**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
            function assocIndexOf(array, key) {
                for (var length = array.length; length--; ) if (eq(array[length][0], key)) return length;
                return -1;
            }
            /**
	 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
	 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
	 * symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @param {Function} symbolsFunc The function to get the symbols of `object`.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
            function baseGetAllKeys(object, keysFunc, symbolsFunc) {
                var result = keysFunc(object);
                return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
            }
            /**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
            function baseGetTag(value) {
                return null == value ? void 0 === value ? undefinedTag : nullTag : symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
            }
            /**
	 * The base implementation of `_.isArguments`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 */
            function baseIsArguments(value) {
                return isObjectLike(value) && baseGetTag(value) == argsTag;
            }
            /**
	 * The base implementation of `_.isEqual` which supports partial comparisons
	 * and tracks traversed objects.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @param {boolean} bitmask The bitmask flags.
	 *  1 - Unordered comparison
	 *  2 - Partial comparison
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 */
            function baseIsEqual(value, other, bitmask, customizer, stack) {
                return value === other || (null == value || null == other || !isObjectLike(value) && !isObjectLike(other) ? value !== value && other !== other : baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack));
            }
            /**
	 * A specialized version of `baseIsEqual` for arrays and objects which performs
	 * deep comparisons and tracks traversed objects enabling objects with circular
	 * references to be compared.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
            function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
                var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
                objTag = objTag == argsTag ? objectTag : objTag, othTag = othTag == argsTag ? objectTag : othTag;
                var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
                if (isSameTag && isBuffer(object)) {
                    if (!isBuffer(other)) return !1;
                    objIsArr = !0, objIsObj = !1;
                }
                if (isSameTag && !objIsObj) return stack || (stack = new Stack()), objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
                if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
                    var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
                    if (objIsWrapped || othIsWrapped) {
                        var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                        return stack || (stack = new Stack()), equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
                    }
                }
                return !!isSameTag && (stack || (stack = new Stack()), equalObjects(object, other, bitmask, customizer, equalFunc, stack));
            }
            /**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
            function baseIsNative(value) {
                if (!isObject(value) || isMasked(value)) return !1;
                var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
                return pattern.test(toSource(value));
            }
            /**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
            function baseIsTypedArray(value) {
                return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
            }
            /**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
            function baseKeys(object) {
                if (!isPrototype(object)) return nativeKeys(object);
                var result = [];
                for (var key in Object(object)) hasOwnProperty.call(object, key) && "constructor" != key && result.push(key);
                return result;
            }
            /**
	 * A specialized version of `baseIsEqualDeep` for arrays with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Array} array The array to compare.
	 * @param {Array} other The other array to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `array` and `other` objects.
	 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	 */
            function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
                if (arrLength != othLength && !(isPartial && othLength > arrLength)) return !1;
                // Assume cyclic values are equal.
                var stacked = stack.get(array);
                if (stacked && stack.get(other)) return stacked == other;
                var index = -1, result = !0, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
                // Ignore non-index properties.
                for (stack.set(array, other), stack.set(other, array); ++index < arrLength; ) {
                    var arrValue = array[index], othValue = other[index];
                    if (customizer) var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
                    if (void 0 !== compared) {
                        if (compared) continue;
                        result = !1;
                        break;
                    }
                    // Recursively compare arrays (susceptible to call stack limits).
                    if (seen) {
                        if (!arraySome(other, function(othValue, othIndex) {
                            if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) return seen.push(othIndex);
                        })) {
                            result = !1;
                            break;
                        }
                    } else if (arrValue !== othValue && !equalFunc(arrValue, othValue, bitmask, customizer, stack)) {
                        result = !1;
                        break;
                    }
                }
                return stack.delete(array), stack.delete(other), result;
            }
            /**
	 * A specialized version of `baseIsEqualDeep` for comparing objects of
	 * the same `toStringTag`.
	 *
	 * **Note:** This function only supports comparing values with tags of
	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {string} tag The `toStringTag` of the objects to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
            function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
                switch (tag) {
                  case dataViewTag:
                    if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) return !1;
                    object = object.buffer, other = other.buffer;

                  case arrayBufferTag:
                    return !(object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other)));

                  case boolTag:
                  case dateTag:
                  case numberTag:
                    // Coerce booleans to `1` or `0` and dates to milliseconds.
                    // Invalid dates are coerced to `NaN`.
                    return eq(+object, +other);

                  case errorTag:
                    return object.name == other.name && object.message == other.message;

                  case regexpTag:
                  case stringTag:
                    // Coerce regexes to strings and treat strings, primitives and objects,
                    // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
                    // for more details.
                    return object == other + "";

                  case mapTag:
                    var convert = mapToArray;

                  case setTag:
                    var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                    if (convert || (convert = setToArray), object.size != other.size && !isPartial) return !1;
                    // Assume cyclic values are equal.
                    var stacked = stack.get(object);
                    if (stacked) return stacked == other;
                    bitmask |= COMPARE_UNORDERED_FLAG, // Recursively compare objects (susceptible to call stack limits).
                    stack.set(object, other);
                    var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                    return stack.delete(object), result;

                  case symbolTag:
                    if (symbolValueOf) return symbolValueOf.call(object) == symbolValueOf.call(other);
                }
                return !1;
            }
            /**
	 * A specialized version of `baseIsEqualDeep` for objects with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
            function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
                if (objLength != othLength && !isPartial) return !1;
                for (var index = objLength; index--; ) {
                    var key = objProps[index];
                    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) return !1;
                }
                // Assume cyclic values are equal.
                var stacked = stack.get(object);
                if (stacked && stack.get(other)) return stacked == other;
                var result = !0;
                stack.set(object, other), stack.set(other, object);
                for (var skipCtor = isPartial; ++index < objLength; ) {
                    key = objProps[index];
                    var objValue = object[key], othValue = other[key];
                    if (customizer) var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
                    // Recursively compare objects (susceptible to call stack limits).
                    if (!(void 0 === compared ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                        result = !1;
                        break;
                    }
                    skipCtor || (skipCtor = "constructor" == key);
                }
                if (result && !skipCtor) {
                    var objCtor = object.constructor, othCtor = other.constructor;
                    // Non `Object` object instances with different constructors are not equal.
                    objCtor != othCtor && "constructor" in object && "constructor" in other && !("function" == typeof objCtor && objCtor instanceof objCtor && "function" == typeof othCtor && othCtor instanceof othCtor) && (result = !1);
                }
                return stack.delete(object), stack.delete(other), result;
            }
            /**
	 * Creates an array of own enumerable property names and symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
            function getAllKeys(object) {
                return baseGetAllKeys(object, keys, getSymbols);
            }
            /**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
            function getMapData(map, key) {
                var data = map.__data__;
                return isKeyable(key) ? data["string" == typeof key ? "string" : "hash"] : data.map;
            }
            /**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
            function getNative(object, key) {
                var value = getValue(object, key);
                return baseIsNative(value) ? value : void 0;
            }
            /**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
            function getRawTag(value) {
                var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
                try {
                    value[symToStringTag] = void 0;
                    var unmasked = !0;
                } catch (e) {}
                var result = nativeObjectToString.call(value);
                return unmasked && (isOwn ? value[symToStringTag] = tag : delete value[symToStringTag]), 
                result;
            }
            /**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
            function isIndex(value, length) {
                return length = null == length ? MAX_SAFE_INTEGER : length, !!length && ("number" == typeof value || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
            }
            /**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
            function isKeyable(value) {
                var type = typeof value;
                return "string" == type || "number" == type || "symbol" == type || "boolean" == type ? "__proto__" !== value : null === value;
            }
            /**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
            function isMasked(func) {
                return !!maskSrcKey && maskSrcKey in func;
            }
            /**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
            function isPrototype(value) {
                var Ctor = value && value.constructor, proto = "function" == typeof Ctor && Ctor.prototype || objectProto;
                return value === proto;
            }
            /**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
            function objectToString(value) {
                return nativeObjectToString.call(value);
            }
            /**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source code.
	 */
            function toSource(func) {
                if (null != func) {
                    try {
                        return funcToString.call(func);
                    } catch (e) {}
                    try {
                        return func + "";
                    } catch (e) {}
                }
                return "";
            }
            /**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
            function eq(value, other) {
                return value === other || value !== value && other !== other;
            }
            /**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
            function isArrayLike(value) {
                return null != value && isLength(value.length) && !isFunction(value);
            }
            /**
	 * Performs a deep comparison between two values to determine if they are
	 * equivalent.
	 *
	 * **Note:** This method supports comparing arrays, array buffers, booleans,
	 * date objects, error objects, maps, numbers, `Object` objects, regexes,
	 * sets, strings, symbols, and typed arrays. `Object` objects are compared
	 * by their own, not inherited, enumerable properties. Functions and DOM
	 * nodes are compared by strict equality, i.e. `===`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.isEqual(object, other);
	 * // => true
	 *
	 * object === other;
	 * // => false
	 */
            function isEqual(value, other) {
                return baseIsEqual(value, other);
            }
            /**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
            function isFunction(value) {
                if (!isObject(value)) return !1;
                // The use of `Object#toString` avoids issues with the `typeof` operator
                // in Safari 9 which returns 'object' for typed arrays and other constructors.
                var tag = baseGetTag(value);
                return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
            }
            /**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
            function isLength(value) {
                return "number" == typeof value && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
            }
            /**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
            function isObject(value) {
                var type = typeof value;
                return null != value && ("object" == type || "function" == type);
            }
            /**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
            function isObjectLike(value) {
                return null != value && "object" == typeof value;
            }
            /**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
            function keys(object) {
                return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
            }
            /**
	 * This method returns a new empty array.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {Array} Returns the new empty array.
	 * @example
	 *
	 * var arrays = _.times(2, _.stubArray);
	 *
	 * console.log(arrays);
	 * // => [[], []]
	 *
	 * console.log(arrays[0] === arrays[1]);
	 * // => false
	 */
            function stubArray() {
                return [];
            }
            /**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, false]
	 */
            function stubFalse() {
                return !1;
            }
            /**
	 * Lodash (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright JS Foundation and other contributors <https://js.foundation/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */
            /** Used as the size to enable large array optimizations. */
            var LARGE_ARRAY_SIZE = 200, HASH_UNDEFINED = "__lodash_hash_undefined__", COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2, MAX_SAFE_INTEGER = 9007199254740991, argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]", reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reIsHostCtor = /^\[object .+?Constructor\]$/, reIsUint = /^(?:0|[1-9]\d*)$/, typedArrayTags = {};
            typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = !0, 
            typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = !1;
            /** Detect free variable `global` from Node.js. */
            var freeGlobal = "object" == typeof global && global && global.Object === Object && global, freeSelf = "object" == typeof self && self && self.Object === Object && self, root = freeGlobal || freeSelf || Function("return this")(), freeExports = "object" == typeof exports && exports && !exports.nodeType && exports, freeModule = freeExports && "object" == typeof module && module && !module.nodeType && module, moduleExports = freeModule && freeModule.exports === freeExports, freeProcess = moduleExports && freeGlobal.process, nodeUtil = function() {
                try {
                    return freeProcess && freeProcess.binding && freeProcess.binding("util");
                } catch (e) {}
            }(), nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray, arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype, coreJsData = root["__core-js_shared__"], funcToString = funcProto.toString, hasOwnProperty = objectProto.hasOwnProperty, maskSrcKey = function() {
                var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
                return uid ? "Symbol(src)_1." + uid : "";
            }(), nativeObjectToString = objectProto.toString, reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), Buffer = moduleExports ? root.Buffer : void 0, Symbol = root.Symbol, Uint8Array = root.Uint8Array, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, symToStringTag = Symbol ? Symbol.toStringTag : void 0, nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0, nativeKeys = overArg(Object.keys, Object), DataView = getNative(root, "DataView"), Map = getNative(root, "Map"), Promise = getNative(root, "Promise"), Set = getNative(root, "Set"), WeakMap = getNative(root, "WeakMap"), nativeCreate = getNative(Object, "create"), dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap), symbolProto = Symbol ? Symbol.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
            // Add methods to `Hash`.
            Hash.prototype.clear = hashClear, Hash.prototype.delete = hashDelete, Hash.prototype.get = hashGet, 
            Hash.prototype.has = hashHas, Hash.prototype.set = hashSet, // Add methods to `ListCache`.
            ListCache.prototype.clear = listCacheClear, ListCache.prototype.delete = listCacheDelete, 
            ListCache.prototype.get = listCacheGet, ListCache.prototype.has = listCacheHas, 
            ListCache.prototype.set = listCacheSet, // Add methods to `MapCache`.
            MapCache.prototype.clear = mapCacheClear, MapCache.prototype.delete = mapCacheDelete, 
            MapCache.prototype.get = mapCacheGet, MapCache.prototype.has = mapCacheHas, MapCache.prototype.set = mapCacheSet, 
            // Add methods to `SetCache`.
            SetCache.prototype.add = SetCache.prototype.push = setCacheAdd, SetCache.prototype.has = setCacheHas, 
            // Add methods to `Stack`.
            Stack.prototype.clear = stackClear, Stack.prototype.delete = stackDelete, Stack.prototype.get = stackGet, 
            Stack.prototype.has = stackHas, Stack.prototype.set = stackSet;
            /**
	 * Creates an array of the own enumerable symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of symbols.
	 */
            var getSymbols = nativeGetSymbols ? function(object) {
                return null == object ? [] : (object = Object(object), arrayFilter(nativeGetSymbols(object), function(symbol) {
                    return propertyIsEnumerable.call(object, symbol);
                }));
            } : stubArray, getTag = baseGetTag;
            // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
            (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) && (getTag = function(value) {
                var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
                if (ctorString) switch (ctorString) {
                  case dataViewCtorString:
                    return dataViewTag;

                  case mapCtorString:
                    return mapTag;

                  case promiseCtorString:
                    return promiseTag;

                  case setCtorString:
                    return setTag;

                  case weakMapCtorString:
                    return weakMapTag;
                }
                return result;
            });
            /**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
            var isArguments = baseIsArguments(function() {
                return arguments;
            }()) ? baseIsArguments : function(value) {
                return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
            }, isArray = Array.isArray, isBuffer = nativeIsBuffer || stubFalse, isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
            module.exports = isEqual;
        }).call(exports, function() {
            return this;
        }(), __webpack_require__(124)(module));
    }, /* 124 */
    /***/
    function(module, exports) {
        module.exports = function(module) {
            // module.parent = undefined by default
            return module.webpackPolyfill || (module.deprecate = function() {}, module.paths = [], 
            module.children = [], module.webpackPolyfill = 1), module;
        };
    }, /* 125 */
    /***/
    function(module, exports, __webpack_require__) {
        /**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
        "use strict";
        var React = __webpack_require__(108), factory = __webpack_require__(126);
        if ("undefined" == typeof React) throw Error("create-react-class could not find the React object. If you are using script tags, make sure that React is being loaded before create-react-class.");
        // Hack to grab NoopUpdateQueue from isomorphic React
        var ReactNoopUpdateQueue = new React.Component().updater;
        module.exports = factory(React.Component, React.isValidElement, ReactNoopUpdateQueue);
    }, /* 126 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(process) {
            /**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
            "use strict";
            // Helper function to allow the creation of anonymous functions which do not
            // have .name set to the name of the variable being assigned to.
            function identity(fn) {
                return fn;
            }
            function factory(ReactComponent, isValidElement, ReactNoopUpdateQueue) {
                function validateTypeDef(Constructor, typeDef, location) {
                    for (var propName in typeDef) typeDef.hasOwnProperty(propName) && "production" !== process.env.NODE_ENV && warning("function" == typeof typeDef[propName], "%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.", Constructor.displayName || "ReactClass", ReactPropTypeLocationNames[location], propName);
                }
                function validateMethodOverride(isAlreadyDefined, name) {
                    var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;
                    // Disallow overriding of base class methods unless explicitly allowed.
                    ReactClassMixin.hasOwnProperty(name) && _invariant("OVERRIDE_BASE" === specPolicy, "ReactClassInterface: You are attempting to override `%s` from your class specification. Ensure that your method names do not overlap with React methods.", name), 
                    // Disallow defining methods more than once unless explicitly allowed.
                    isAlreadyDefined && _invariant("DEFINE_MANY" === specPolicy || "DEFINE_MANY_MERGED" === specPolicy, "ReactClassInterface: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.", name);
                }
                /**
	   * Mixin helper which handles policy validation and reserved
	   * specification keys when building React classes.
	   */
                function mixSpecIntoComponent(Constructor, spec) {
                    if (spec) {
                        _invariant("function" != typeof spec, "ReactClass: You're attempting to use a component class or function as a mixin. Instead, just use a regular object."), 
                        _invariant(!isValidElement(spec), "ReactClass: You're attempting to use a component as a mixin. Instead, just use a regular object.");
                        var proto = Constructor.prototype, autoBindPairs = proto.__reactAutoBindPairs;
                        // By handling mixins before any other properties, we ensure the same
                        // chaining order is applied to methods with DEFINE_MANY policy, whether
                        // mixins are listed before or after these methods in the spec.
                        spec.hasOwnProperty(MIXINS_KEY) && RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
                        for (var name in spec) if (spec.hasOwnProperty(name) && name !== MIXINS_KEY) {
                            var property = spec[name], isAlreadyDefined = proto.hasOwnProperty(name);
                            if (validateMethodOverride(isAlreadyDefined, name), RESERVED_SPEC_KEYS.hasOwnProperty(name)) RESERVED_SPEC_KEYS[name](Constructor, property); else {
                                // Setup methods on prototype:
                                // The following member methods should not be automatically bound:
                                // 1. Expected ReactClass methods (in the "interface").
                                // 2. Overridden methods (that were mixed in).
                                var isReactClassMethod = ReactClassInterface.hasOwnProperty(name), isFunction = "function" == typeof property, shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== !1;
                                if (shouldAutoBind) autoBindPairs.push(name, property), proto[name] = property; else if (isAlreadyDefined) {
                                    var specPolicy = ReactClassInterface[name];
                                    // These cases should already be caught by validateMethodOverride.
                                    _invariant(isReactClassMethod && ("DEFINE_MANY_MERGED" === specPolicy || "DEFINE_MANY" === specPolicy), "ReactClass: Unexpected spec policy %s for key %s when mixing in component specs.", specPolicy, name), 
                                    // For methods which are defined more than once, call the existing
                                    // methods before calling the new property, merging if appropriate.
                                    "DEFINE_MANY_MERGED" === specPolicy ? proto[name] = createMergedResultFunction(proto[name], property) : "DEFINE_MANY" === specPolicy && (proto[name] = createChainedFunction(proto[name], property));
                                } else proto[name] = property, "production" !== process.env.NODE_ENV && "function" == typeof property && spec.displayName && (proto[name].displayName = spec.displayName + "_" + name);
                            }
                        }
                    } else if ("production" !== process.env.NODE_ENV) {
                        var typeofSpec = typeof spec, isMixinValid = "object" === typeofSpec && null !== spec;
                        "production" !== process.env.NODE_ENV && warning(isMixinValid, "%s: You're attempting to include a mixin that is either null or not an object. Check the mixins included by the component, as well as any mixins they include themselves. Expected object but got %s.", Constructor.displayName || "ReactClass", null === spec ? null : typeofSpec);
                    }
                }
                function mixStaticSpecIntoComponent(Constructor, statics) {
                    if (statics) for (var name in statics) {
                        var property = statics[name];
                        if (statics.hasOwnProperty(name)) {
                            var isReserved = name in RESERVED_SPEC_KEYS;
                            _invariant(!isReserved, 'ReactClass: You are attempting to define a reserved property, `%s`, that shouldn\'t be on the "statics" key. Define it as an instance property instead; it will still be accessible on the constructor.', name);
                            var isInherited = name in Constructor;
                            _invariant(!isInherited, "ReactClass: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.", name), 
                            Constructor[name] = property;
                        }
                    }
                }
                /**
	   * Merge two objects, but throw if both contain the same key.
	   *
	   * @param {object} one The first object, which is mutated.
	   * @param {object} two The second object
	   * @return {object} one after it has been mutated to contain everything in two.
	   */
                function mergeIntoWithNoDuplicateKeys(one, two) {
                    _invariant(one && two && "object" == typeof one && "object" == typeof two, "mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.");
                    for (var key in two) two.hasOwnProperty(key) && (_invariant(void 0 === one[key], "mergeIntoWithNoDuplicateKeys(): Tried to merge two objects with the same key: `%s`. This conflict may be due to a mixin; in particular, this may be caused by two getInitialState() or getDefaultProps() methods returning objects with clashing keys.", key), 
                    one[key] = two[key]);
                    return one;
                }
                /**
	   * Creates a function that invokes two functions and merges their return values.
	   *
	   * @param {function} one Function to invoke first.
	   * @param {function} two Function to invoke second.
	   * @return {function} Function that invokes the two argument functions.
	   * @private
	   */
                function createMergedResultFunction(one, two) {
                    return function() {
                        var a = one.apply(this, arguments), b = two.apply(this, arguments);
                        if (null == a) return b;
                        if (null == b) return a;
                        var c = {};
                        return mergeIntoWithNoDuplicateKeys(c, a), mergeIntoWithNoDuplicateKeys(c, b), c;
                    };
                }
                /**
	   * Creates a function that invokes two functions and ignores their return vales.
	   *
	   * @param {function} one Function to invoke first.
	   * @param {function} two Function to invoke second.
	   * @return {function} Function that invokes the two argument functions.
	   * @private
	   */
                function createChainedFunction(one, two) {
                    return function() {
                        one.apply(this, arguments), two.apply(this, arguments);
                    };
                }
                /**
	   * Binds a method to the component.
	   *
	   * @param {object} component Component whose method is going to be bound.
	   * @param {function} method Method to be bound.
	   * @return {function} The bound method.
	   */
                function bindAutoBindMethod(component, method) {
                    var boundMethod = method.bind(component);
                    if ("production" !== process.env.NODE_ENV) {
                        boundMethod.__reactBoundContext = component, boundMethod.__reactBoundMethod = method, 
                        boundMethod.__reactBoundArguments = null;
                        var componentName = component.constructor.displayName, _bind = boundMethod.bind;
                        boundMethod.bind = function(newThis) {
                            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];
                            // User is trying to bind() an autobound method; we effectively will
                            // ignore the value of "this" that the user is trying to use, so
                            // let's warn.
                            if (newThis !== component && null !== newThis) "production" !== process.env.NODE_ENV && warning(!1, "bind(): React component methods may only be bound to the component instance. See %s", componentName); else if (!args.length) return "production" !== process.env.NODE_ENV && warning(!1, "bind(): You are binding a component method to the component. React does this for you automatically in a high-performance way, so you can safely remove this call. See %s", componentName), 
                            boundMethod;
                            var reboundMethod = _bind.apply(boundMethod, arguments);
                            return reboundMethod.__reactBoundContext = component, reboundMethod.__reactBoundMethod = method, 
                            reboundMethod.__reactBoundArguments = args, reboundMethod;
                        };
                    }
                    return boundMethod;
                }
                /**
	   * Binds all auto-bound methods in a component.
	   *
	   * @param {object} component Component whose method is going to be bound.
	   */
                function bindAutoBindMethods(component) {
                    for (var pairs = component.__reactAutoBindPairs, i = 0; i < pairs.length; i += 2) {
                        var autoBindKey = pairs[i], method = pairs[i + 1];
                        component[autoBindKey] = bindAutoBindMethod(component, method);
                    }
                }
                /**
	   * Creates a composite component class given a class specification.
	   * See https://facebook.github.io/react/docs/top-level-api.html#react.createclass
	   *
	   * @param {object} spec Class specification (which must define `render`).
	   * @return {function} Component constructor function.
	   * @public
	   */
                function createClass(spec) {
                    // To keep our warnings more understandable, we'll use a little hack here to
                    // ensure that Constructor.name !== 'Constructor'. This makes sure we don't
                    // unnecessarily identify a class without displayName as 'Constructor'.
                    var Constructor = identity(function(props, context, updater) {
                        // This constructor gets overridden by mocks. The argument is used
                        // by mocks to assert on what gets mounted.
                        "production" !== process.env.NODE_ENV && warning(this instanceof Constructor, "Something is calling a React component directly. Use a factory or JSX instead. See: https://fb.me/react-legacyfactory"), 
                        // Wire up auto-binding
                        this.__reactAutoBindPairs.length && bindAutoBindMethods(this), this.props = props, 
                        this.context = context, this.refs = emptyObject, this.updater = updater || ReactNoopUpdateQueue, 
                        this.state = null;
                        // ReactClasses doesn't have constructors. Instead, they use the
                        // getInitialState and componentWillMount methods for initialization.
                        var initialState = this.getInitialState ? this.getInitialState() : null;
                        "production" !== process.env.NODE_ENV && void 0 === initialState && this.getInitialState._isMockFunction && (// This is probably bad practice. Consider warning here and
                        // deprecating this convenience.
                        initialState = null), _invariant("object" == typeof initialState && !Array.isArray(initialState), "%s.getInitialState(): must return an object or null", Constructor.displayName || "ReactCompositeComponent"), 
                        this.state = initialState;
                    });
                    Constructor.prototype = new ReactClassComponent(), Constructor.prototype.constructor = Constructor, 
                    Constructor.prototype.__reactAutoBindPairs = [], injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor)), 
                    mixSpecIntoComponent(Constructor, IsMountedPreMixin), mixSpecIntoComponent(Constructor, spec), 
                    mixSpecIntoComponent(Constructor, IsMountedPostMixin), // Initialize the defaultProps property after all mixins have been merged.
                    Constructor.getDefaultProps && (Constructor.defaultProps = Constructor.getDefaultProps()), 
                    "production" !== process.env.NODE_ENV && (// This is a tag to indicate that the use of these method names is ok,
                    // since it's used with createClass. If it's not, then it's likely a
                    // mistake so we'll warn you to use the static property, property
                    // initializer or constructor respectively.
                    Constructor.getDefaultProps && (Constructor.getDefaultProps.isReactClassApproved = {}), 
                    Constructor.prototype.getInitialState && (Constructor.prototype.getInitialState.isReactClassApproved = {})), 
                    _invariant(Constructor.prototype.render, "createClass(...): Class specification must implement a `render` method."), 
                    "production" !== process.env.NODE_ENV && (warning(!Constructor.prototype.componentShouldUpdate, "%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", spec.displayName || "A component"), 
                    warning(!Constructor.prototype.componentWillRecieveProps, "%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", spec.displayName || "A component"));
                    // Reduce time spent doing lookups by setting these on the prototype.
                    for (var methodName in ReactClassInterface) Constructor.prototype[methodName] || (Constructor.prototype[methodName] = null);
                    return Constructor;
                }
                /**
	   * Policies that describe methods in `ReactClassInterface`.
	   */
                var injectedMixins = [], ReactClassInterface = {
                    /**
	     * An array of Mixin objects to include when defining your component.
	     *
	     * @type {array}
	     * @optional
	     */
                    mixins: "DEFINE_MANY",
                    /**
	     * An object containing properties and methods that should be defined on
	     * the component's constructor instead of its prototype (static methods).
	     *
	     * @type {object}
	     * @optional
	     */
                    statics: "DEFINE_MANY",
                    /**
	     * Definition of prop types for this component.
	     *
	     * @type {object}
	     * @optional
	     */
                    propTypes: "DEFINE_MANY",
                    /**
	     * Definition of context types for this component.
	     *
	     * @type {object}
	     * @optional
	     */
                    contextTypes: "DEFINE_MANY",
                    /**
	     * Definition of context types this component sets for its children.
	     *
	     * @type {object}
	     * @optional
	     */
                    childContextTypes: "DEFINE_MANY",
                    // ==== Definition methods ====
                    /**
	     * Invoked when the component is mounted. Values in the mapping will be set on
	     * `this.props` if that prop is not specified (i.e. using an `in` check).
	     *
	     * This method is invoked before `getInitialState` and therefore cannot rely
	     * on `this.state` or use `this.setState`.
	     *
	     * @return {object}
	     * @optional
	     */
                    getDefaultProps: "DEFINE_MANY_MERGED",
                    /**
	     * Invoked once before the component is mounted. The return value will be used
	     * as the initial value of `this.state`.
	     *
	     *   getInitialState: function() {
	     *     return {
	     *       isOn: false,
	     *       fooBaz: new BazFoo()
	     *     }
	     *   }
	     *
	     * @return {object}
	     * @optional
	     */
                    getInitialState: "DEFINE_MANY_MERGED",
                    /**
	     * @return {object}
	     * @optional
	     */
                    getChildContext: "DEFINE_MANY_MERGED",
                    /**
	     * Uses props from `this.props` and state from `this.state` to render the
	     * structure of the component.
	     *
	     * No guarantees are made about when or how often this method is invoked, so
	     * it must not have side effects.
	     *
	     *   render: function() {
	     *     var name = this.props.name;
	     *     return <div>Hello, {name}!</div>;
	     *   }
	     *
	     * @return {ReactComponent}
	     * @required
	     */
                    render: "DEFINE_ONCE",
                    // ==== Delegate methods ====
                    /**
	     * Invoked when the component is initially created and about to be mounted.
	     * This may have side effects, but any external subscriptions or data created
	     * by this method must be cleaned up in `componentWillUnmount`.
	     *
	     * @optional
	     */
                    componentWillMount: "DEFINE_MANY",
                    /**
	     * Invoked when the component has been mounted and has a DOM representation.
	     * However, there is no guarantee that the DOM node is in the document.
	     *
	     * Use this as an opportunity to operate on the DOM when the component has
	     * been mounted (initialized and rendered) for the first time.
	     *
	     * @param {DOMElement} rootNode DOM element representing the component.
	     * @optional
	     */
                    componentDidMount: "DEFINE_MANY",
                    /**
	     * Invoked before the component receives new props.
	     *
	     * Use this as an opportunity to react to a prop transition by updating the
	     * state using `this.setState`. Current props are accessed via `this.props`.
	     *
	     *   componentWillReceiveProps: function(nextProps, nextContext) {
	     *     this.setState({
	     *       likesIncreasing: nextProps.likeCount > this.props.likeCount
	     *     });
	     *   }
	     *
	     * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
	     * transition may cause a state change, but the opposite is not true. If you
	     * need it, you are probably looking for `componentWillUpdate`.
	     *
	     * @param {object} nextProps
	     * @optional
	     */
                    componentWillReceiveProps: "DEFINE_MANY",
                    /**
	     * Invoked while deciding if the component should be updated as a result of
	     * receiving new props, state and/or context.
	     *
	     * Use this as an opportunity to `return false` when you're certain that the
	     * transition to the new props/state/context will not require a component
	     * update.
	     *
	     *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
	     *     return !equal(nextProps, this.props) ||
	     *       !equal(nextState, this.state) ||
	     *       !equal(nextContext, this.context);
	     *   }
	     *
	     * @param {object} nextProps
	     * @param {?object} nextState
	     * @param {?object} nextContext
	     * @return {boolean} True if the component should update.
	     * @optional
	     */
                    shouldComponentUpdate: "DEFINE_ONCE",
                    /**
	     * Invoked when the component is about to update due to a transition from
	     * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
	     * and `nextContext`.
	     *
	     * Use this as an opportunity to perform preparation before an update occurs.
	     *
	     * NOTE: You **cannot** use `this.setState()` in this method.
	     *
	     * @param {object} nextProps
	     * @param {?object} nextState
	     * @param {?object} nextContext
	     * @param {ReactReconcileTransaction} transaction
	     * @optional
	     */
                    componentWillUpdate: "DEFINE_MANY",
                    /**
	     * Invoked when the component's DOM representation has been updated.
	     *
	     * Use this as an opportunity to operate on the DOM when the component has
	     * been updated.
	     *
	     * @param {object} prevProps
	     * @param {?object} prevState
	     * @param {?object} prevContext
	     * @param {DOMElement} rootNode DOM element representing the component.
	     * @optional
	     */
                    componentDidUpdate: "DEFINE_MANY",
                    /**
	     * Invoked when the component is about to be removed from its parent and have
	     * its DOM representation destroyed.
	     *
	     * Use this as an opportunity to deallocate any external resources.
	     *
	     * NOTE: There is no `componentDidUnmount` since your component will have been
	     * destroyed by that point.
	     *
	     * @optional
	     */
                    componentWillUnmount: "DEFINE_MANY",
                    // ==== Advanced methods ====
                    /**
	     * Updates the component's currently mounted DOM representation.
	     *
	     * By default, this implements React's rendering and reconciliation algorithm.
	     * Sophisticated clients may wish to override this.
	     *
	     * @param {ReactReconcileTransaction} transaction
	     * @internal
	     * @overridable
	     */
                    updateComponent: "OVERRIDE_BASE"
                }, RESERVED_SPEC_KEYS = {
                    displayName: function(Constructor, displayName) {
                        Constructor.displayName = displayName;
                    },
                    mixins: function(Constructor, mixins) {
                        if (mixins) for (var i = 0; i < mixins.length; i++) mixSpecIntoComponent(Constructor, mixins[i]);
                    },
                    childContextTypes: function(Constructor, childContextTypes) {
                        "production" !== process.env.NODE_ENV && validateTypeDef(Constructor, childContextTypes, "childContext"), 
                        Constructor.childContextTypes = _assign({}, Constructor.childContextTypes, childContextTypes);
                    },
                    contextTypes: function(Constructor, contextTypes) {
                        "production" !== process.env.NODE_ENV && validateTypeDef(Constructor, contextTypes, "context"), 
                        Constructor.contextTypes = _assign({}, Constructor.contextTypes, contextTypes);
                    },
                    /**
	     * Special case getDefaultProps which should move into statics but requires
	     * automatic merging.
	     */
                    getDefaultProps: function(Constructor, getDefaultProps) {
                        Constructor.getDefaultProps ? Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps) : Constructor.getDefaultProps = getDefaultProps;
                    },
                    propTypes: function(Constructor, propTypes) {
                        "production" !== process.env.NODE_ENV && validateTypeDef(Constructor, propTypes, "prop"), 
                        Constructor.propTypes = _assign({}, Constructor.propTypes, propTypes);
                    },
                    statics: function(Constructor, statics) {
                        mixStaticSpecIntoComponent(Constructor, statics);
                    },
                    autobind: function() {}
                }, IsMountedPreMixin = {
                    componentDidMount: function() {
                        this.__isMounted = !0;
                    }
                }, IsMountedPostMixin = {
                    componentWillUnmount: function() {
                        this.__isMounted = !1;
                    }
                }, ReactClassMixin = {
                    /**
	     * TODO: This will be deprecated because state should always keep a consistent
	     * type signature and the only use case for this, is to avoid that.
	     */
                    replaceState: function(newState, callback) {
                        this.updater.enqueueReplaceState(this, newState, callback);
                    },
                    /**
	     * Checks whether or not this composite component is mounted.
	     * @return {boolean} True if mounted, false otherwise.
	     * @protected
	     * @final
	     */
                    isMounted: function() {
                        return "production" !== process.env.NODE_ENV && (warning(this.__didWarnIsMounted, "%s: isMounted is deprecated. Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks.", this.constructor && this.constructor.displayName || this.name || "Component"), 
                        this.__didWarnIsMounted = !0), !!this.__isMounted;
                    }
                }, ReactClassComponent = function() {};
                return _assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin), 
                createClass;
            }
            var _assign = __webpack_require__(115), emptyObject = __webpack_require__(127), _invariant = __webpack_require__(113);
            if ("production" !== process.env.NODE_ENV) var warning = __webpack_require__(114);
            var ReactPropTypeLocationNames, MIXINS_KEY = "mixins";
            ReactPropTypeLocationNames = "production" !== process.env.NODE_ENV ? {
                prop: "prop",
                context: "context",
                childContext: "child context"
            } : {}, module.exports = factory;
        }).call(exports, __webpack_require__(110));
    }, /* 127 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(process) {
            /**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
            "use strict";
            var emptyObject = {};
            "production" !== process.env.NODE_ENV && Object.freeze(emptyObject), module.exports = emptyObject;
        }).call(exports, __webpack_require__(110));
    }, /* 128 */
    /***/
    function(module, exports, __webpack_require__) {
        // CodeMirror, copyright (c) by Marijn Haverbeke and others
        // Distributed under an MIT license: http://codemirror.net/LICENSE
        // This is CodeMirror (http://codemirror.net), a code editor
        // implemented in JavaScript on top of the browser's DOM.
        //
        // You can find some technical background for some of the code below
        // at http://marijnhaverbeke.nl/blog/#cm-internals .
        !function(global, factory) {
            module.exports = factory();
        }(this, function() {
            "use strict";
            function classTest(cls) {
                return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*");
            }
            function removeChildren(e) {
                for (var count = e.childNodes.length; count > 0; --count) e.removeChild(e.firstChild);
                return e;
            }
            function removeChildrenAndAdd(parent, e) {
                return removeChildren(parent).appendChild(e);
            }
            function elt(tag, content, className, style) {
                var e = document.createElement(tag);
                if (className && (e.className = className), style && (e.style.cssText = style), 
                "string" == typeof content) e.appendChild(document.createTextNode(content)); else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);
                return e;
            }
            // wrapper for elt, which removes the elt from the accessibility tree
            function eltP(tag, content, className, style) {
                var e = elt(tag, content, className, style);
                return e.setAttribute("role", "presentation"), e;
            }
            function contains(parent, child) {
                if (3 == child.nodeType && (child = child.parentNode), parent.contains) return parent.contains(child);
                do if (11 == child.nodeType && (child = child.host), child == parent) return !0; while (child = child.parentNode);
            }
            function activeElt() {
                // IE and Edge may throw an "Unspecified Error" when accessing document.activeElement.
                // IE < 10 will throw when accessed while the page is loading or in an iframe.
                // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.
                var activeElement;
                try {
                    activeElement = document.activeElement;
                } catch (e) {
                    activeElement = document.body || null;
                }
                for (;activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement; ) activeElement = activeElement.shadowRoot.activeElement;
                return activeElement;
            }
            function addClass(node, cls) {
                var current = node.className;
                classTest(cls).test(current) || (node.className += (current ? " " : "") + cls);
            }
            function joinClasses(a, b) {
                for (var as = a.split(" "), i = 0; i < as.length; i++) as[i] && !classTest(as[i]).test(b) && (b += " " + as[i]);
                return b;
            }
            function bind(f) {
                var args = Array.prototype.slice.call(arguments, 1);
                return function() {
                    return f.apply(null, args);
                };
            }
            function copyObj(obj, target, overwrite) {
                target || (target = {});
                for (var prop in obj) !obj.hasOwnProperty(prop) || overwrite === !1 && target.hasOwnProperty(prop) || (target[prop] = obj[prop]);
                return target;
            }
            // Counts the column offset in a string, taking tabs into account.
            // Used mostly to find indentation.
            function countColumn(string, end, tabSize, startIndex, startValue) {
                null == end && (end = string.search(/[^\s\u00a0]/), end == -1 && (end = string.length));
                for (var i = startIndex || 0, n = startValue || 0; ;) {
                    var nextTab = string.indexOf("\t", i);
                    if (nextTab < 0 || nextTab >= end) return n + (end - i);
                    n += nextTab - i, n += tabSize - n % tabSize, i = nextTab + 1;
                }
            }
            function indexOf(array, elt) {
                for (var i = 0; i < array.length; ++i) if (array[i] == elt) return i;
                return -1;
            }
            // The inverse of countColumn -- find the offset that corresponds to
            // a particular column.
            function findColumn(string, goal, tabSize) {
                for (var pos = 0, col = 0; ;) {
                    var nextTab = string.indexOf("\t", pos);
                    nextTab == -1 && (nextTab = string.length);
                    var skipped = nextTab - pos;
                    if (nextTab == string.length || col + skipped >= goal) return pos + Math.min(skipped, goal - col);
                    if (col += nextTab - pos, col += tabSize - col % tabSize, pos = nextTab + 1, col >= goal) return pos;
                }
            }
            function spaceStr(n) {
                for (;spaceStrs.length <= n; ) spaceStrs.push(lst(spaceStrs) + " ");
                return spaceStrs[n];
            }
            function lst(arr) {
                return arr[arr.length - 1];
            }
            function map(array, f) {
                for (var out = [], i = 0; i < array.length; i++) out[i] = f(array[i], i);
                return out;
            }
            function insertSorted(array, value, score) {
                for (var pos = 0, priority = score(value); pos < array.length && score(array[pos]) <= priority; ) pos++;
                array.splice(pos, 0, value);
            }
            function nothing() {}
            function createObj(base, props) {
                var inst;
                return Object.create ? inst = Object.create(base) : (nothing.prototype = base, inst = new nothing()), 
                props && copyObj(props, inst), inst;
            }
            function isWordCharBasic(ch) {
                return /\w/.test(ch) || ch > "" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
            }
            function isWordChar(ch, helper) {
                return helper ? !!(helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) || helper.test(ch) : isWordCharBasic(ch);
            }
            function isEmpty(obj) {
                for (var n in obj) if (obj.hasOwnProperty(n) && obj[n]) return !1;
                return !0;
            }
            function isExtendingChar(ch) {
                return ch.charCodeAt(0) >= 768 && extendingChars.test(ch);
            }
            // Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.
            function skipExtendingChars(str, pos, dir) {
                for (;(dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos)); ) pos += dir;
                return pos;
            }
            // Returns the value from the range [`from`; `to`] that satisfies
            // `pred` and is closest to `from`. Assumes that at least `to`
            // satisfies `pred`. Supports `from` being greater than `to`.
            function findFirst(pred, from, to) {
                for (// At any point we are certain `to` satisfies `pred`, don't know
                // whether `from` does.
                var dir = from > to ? -1 : 1; ;) {
                    if (from == to) return from;
                    var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);
                    if (mid == from) return pred(mid) ? from : to;
                    pred(mid) ? to = mid : from = mid + dir;
                }
            }
            // The display handles the DOM integration, both for input reading
            // and content drawing. It holds references to DOM nodes and
            // display-related state.
            function Display(place, doc, input) {
                var d = this;
                this.input = input, // Covers bottom-right square when both scrollbars are present.
                d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler"), d.scrollbarFiller.setAttribute("cm-not-content", "true"), 
                // Covers bottom of gutter when coverGutterNextToScrollbar is on
                // and h scrollbar is present.
                d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler"), d.gutterFiller.setAttribute("cm-not-content", "true"), 
                // Will contain the actual code, positioned to cover the viewport.
                d.lineDiv = eltP("div", null, "CodeMirror-code"), // Elements are added to these to represent selection and cursors.
                d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1"), d.cursorDiv = elt("div", null, "CodeMirror-cursors"), 
                // A visibility: hidden element used to find the size of things.
                d.measure = elt("div", null, "CodeMirror-measure"), // When lines outside of the viewport are measured, they are drawn in this.
                d.lineMeasure = elt("div", null, "CodeMirror-measure"), // Wraps everything that needs to exist inside the vertically-padded coordinate system
                d.lineSpace = eltP("div", [ d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv ], null, "position: relative; outline: none");
                var lines = eltP("div", [ d.lineSpace ], "CodeMirror-lines");
                // Moved around its parent to cover visible view.
                d.mover = elt("div", [ lines ], null, "position: relative"), // Set to the height of the document, allowing scrolling.
                d.sizer = elt("div", [ d.mover ], "CodeMirror-sizer"), d.sizerWidth = null, // Behavior of elts with overflow: auto and padding is
                // inconsistent across browsers. This is used to ensure the
                // scrollable area is big enough.
                d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;"), 
                // Will contain the gutters, if any.
                d.gutters = elt("div", null, "CodeMirror-gutters"), d.lineGutter = null, // Actual scrollable element.
                d.scroller = elt("div", [ d.sizer, d.heightForcer, d.gutters ], "CodeMirror-scroll"), 
                d.scroller.setAttribute("tabIndex", "-1"), // The element in which the editor lives.
                d.wrapper = elt("div", [ d.scrollbarFiller, d.gutterFiller, d.scroller ], "CodeMirror"), 
                // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)
                ie && ie_version < 8 && (d.gutters.style.zIndex = -1, d.scroller.style.paddingRight = 0), 
                webkit || gecko && mobile || (d.scroller.draggable = !0), place && (place.appendChild ? place.appendChild(d.wrapper) : place(d.wrapper)), 
                // Current rendered range (may be bigger than the view window).
                d.viewFrom = d.viewTo = doc.first, d.reportedViewFrom = d.reportedViewTo = doc.first, 
                // Information about the rendered lines.
                d.view = [], d.renderedView = null, // Holds info about a single rendered line when it was rendered
                // for measurement, while not in view.
                d.externalMeasured = null, // Empty space (in pixels) above the view
                d.viewOffset = 0, d.lastWrapHeight = d.lastWrapWidth = 0, d.updateLineNumbers = null, 
                d.nativeBarWidth = d.barHeight = d.barWidth = 0, d.scrollbarsClipped = !1, // Used to only resize the line number gutter when necessary (when
                // the amount of lines crosses a boundary that makes its width change)
                d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null, // Set to true when a non-horizontal-scrolling line widget is
                // added. As an optimization, line widget aligning is skipped when
                // this is false.
                d.alignWidgets = !1, d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null, 
                // Tracks the maximum line length so that the horizontal scrollbar
                // can be kept static when scrolling.
                d.maxLine = null, d.maxLineLength = 0, d.maxLineChanged = !1, // Used for measuring wheel scrolling granularity
                d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null, // True when shift is held down.
                d.shift = !1, // Used to track whether anything happened since the context menu
                // was opened.
                d.selForContextMenu = null, d.activeTouch = null, input.init(d);
            }
            // Find the line object corresponding to the given line number.
            function getLine(doc, n) {
                if (n -= doc.first, n < 0 || n >= doc.size) throw new Error("There is no line " + (n + doc.first) + " in the document.");
                for (var chunk = doc; !chunk.lines; ) for (var i = 0; ;++i) {
                    var child = chunk.children[i], sz = child.chunkSize();
                    if (n < sz) {
                        chunk = child;
                        break;
                    }
                    n -= sz;
                }
                return chunk.lines[n];
            }
            // Get the part of a document between two positions, as an array of
            // strings.
            function getBetween(doc, start, end) {
                var out = [], n = start.line;
                return doc.iter(start.line, end.line + 1, function(line) {
                    var text = line.text;
                    n == end.line && (text = text.slice(0, end.ch)), n == start.line && (text = text.slice(start.ch)), 
                    out.push(text), ++n;
                }), out;
            }
            // Get the lines between from and to, as array of strings.
            function getLines(doc, from, to) {
                var out = [];
                // iter aborts when callback returns truthy value
                return doc.iter(from, to, function(line) {
                    out.push(line.text);
                }), out;
            }
            // Update the height of a line, propagating the height change
            // upwards to parent nodes.
            function updateLineHeight(line, height) {
                var diff = height - line.height;
                if (diff) for (var n = line; n; n = n.parent) n.height += diff;
            }
            // Given a line object, find its line number by walking up through
            // its parent links.
            function lineNo(line) {
                if (null == line.parent) return null;
                for (var cur = line.parent, no = indexOf(cur.lines, line), chunk = cur.parent; chunk; cur = chunk, 
                chunk = chunk.parent) for (var i = 0; chunk.children[i] != cur; ++i) no += chunk.children[i].chunkSize();
                return no + cur.first;
            }
            // Find the line at the given vertical position, using the height
            // information in the document tree.
            function lineAtHeight(chunk, h) {
                var n = chunk.first;
                outer: do {
                    for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {
                        var child = chunk.children[i$1], ch = child.height;
                        if (h < ch) {
                            chunk = child;
                            continue outer;
                        }
                        h -= ch, n += child.chunkSize();
                    }
                    return n;
                } while (!chunk.lines);
                for (var i = 0; i < chunk.lines.length; ++i) {
                    var line = chunk.lines[i], lh = line.height;
                    if (h < lh) break;
                    h -= lh;
                }
                return n + i;
            }
            function isLine(doc, l) {
                return l >= doc.first && l < doc.first + doc.size;
            }
            function lineNumberFor(options, i) {
                return String(options.lineNumberFormatter(i + options.firstLineNumber));
            }
            // A Pos instance represents a position within the text.
            function Pos(line, ch, sticky) {
                return void 0 === sticky && (sticky = null), this instanceof Pos ? (this.line = line, 
                this.ch = ch, void (this.sticky = sticky)) : new Pos(line, ch, sticky);
            }
            // Compare two positions, return 0 if they are the same, a negative
            // number when a is less, and a positive number otherwise.
            function cmp(a, b) {
                return a.line - b.line || a.ch - b.ch;
            }
            function equalCursorPos(a, b) {
                return a.sticky == b.sticky && 0 == cmp(a, b);
            }
            function copyPos(x) {
                return Pos(x.line, x.ch);
            }
            function maxPos(a, b) {
                return cmp(a, b) < 0 ? b : a;
            }
            function minPos(a, b) {
                return cmp(a, b) < 0 ? a : b;
            }
            // Most of the external API clips given positions to make sure they
            // actually exist within the document.
            function clipLine(doc, n) {
                return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));
            }
            function clipPos(doc, pos) {
                if (pos.line < doc.first) return Pos(doc.first, 0);
                var last = doc.first + doc.size - 1;
                return pos.line > last ? Pos(last, getLine(doc, last).text.length) : clipToLen(pos, getLine(doc, pos.line).text.length);
            }
            function clipToLen(pos, linelen) {
                var ch = pos.ch;
                return null == ch || ch > linelen ? Pos(pos.line, linelen) : ch < 0 ? Pos(pos.line, 0) : pos;
            }
            function clipPosArray(doc, array) {
                for (var out = [], i = 0; i < array.length; i++) out[i] = clipPos(doc, array[i]);
                return out;
            }
            function seeReadOnlySpans() {
                sawReadOnlySpans = !0;
            }
            function seeCollapsedSpans() {
                sawCollapsedSpans = !0;
            }
            // TEXTMARKER SPANS
            function MarkedSpan(marker, from, to) {
                this.marker = marker, this.from = from, this.to = to;
            }
            // Search an array of spans for a span matching the given marker.
            function getMarkedSpanFor(spans, marker) {
                if (spans) for (var i = 0; i < spans.length; ++i) {
                    var span = spans[i];
                    if (span.marker == marker) return span;
                }
            }
            // Remove a span from an array, returning undefined if no spans are
            // left (we don't store arrays for lines without spans).
            function removeMarkedSpan(spans, span) {
                for (var r, i = 0; i < spans.length; ++i) spans[i] != span && (r || (r = [])).push(spans[i]);
                return r;
            }
            // Add a span to a line.
            function addMarkedSpan(line, span) {
                line.markedSpans = line.markedSpans ? line.markedSpans.concat([ span ]) : [ span ], 
                span.marker.attachLine(line);
            }
            // Used for the algorithm that adjusts markers for a change in the
            // document. These functions cut an array of spans at a given
            // character position, returning an array of remaining chunks (or
            // undefined if nothing remains).
            function markedSpansBefore(old, startCh, isInsert) {
                var nw;
                if (old) for (var i = 0; i < old.length; ++i) {
                    var span = old[i], marker = span.marker, startsBefore = null == span.from || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
                    if (startsBefore || span.from == startCh && "bookmark" == marker.type && (!isInsert || !span.marker.insertLeft)) {
                        var endsAfter = null == span.to || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
                        (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
                    }
                }
                return nw;
            }
            function markedSpansAfter(old, endCh, isInsert) {
                var nw;
                if (old) for (var i = 0; i < old.length; ++i) {
                    var span = old[i], marker = span.marker, endsAfter = null == span.to || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
                    if (endsAfter || span.from == endCh && "bookmark" == marker.type && (!isInsert || span.marker.insertLeft)) {
                        var startsBefore = null == span.from || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
                        (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh, null == span.to ? null : span.to - endCh));
                    }
                }
                return nw;
            }
            // Given a change object, compute the new set of marker spans that
            // cover the line in which the change took place. Removes spans
            // entirely within the change, reconnects spans belonging to the
            // same marker that appear on both sides of the change, and cuts off
            // spans partially within the change. Returns an array of span
            // arrays with one element for each line in (after) the change.
            function stretchSpansOverChange(doc, change) {
                if (change.full) return null;
                var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans, oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
                if (!oldFirst && !oldLast) return null;
                var startCh = change.from.ch, endCh = change.to.ch, isInsert = 0 == cmp(change.from, change.to), first = markedSpansBefore(oldFirst, startCh, isInsert), last = markedSpansAfter(oldLast, endCh, isInsert), sameLine = 1 == change.text.length, offset = lst(change.text).length + (sameLine ? startCh : 0);
                if (first) // Fix up .to properties of first
                for (var i = 0; i < first.length; ++i) {
                    var span = first[i];
                    if (null == span.to) {
                        var found = getMarkedSpanFor(last, span.marker);
                        found ? sameLine && (span.to = null == found.to ? null : found.to + offset) : span.to = startCh;
                    }
                }
                if (last) // Fix up .from in last (or move them into first in case of sameLine)
                for (var i$1 = 0; i$1 < last.length; ++i$1) {
                    var span$1 = last[i$1];
                    if (null != span$1.to && (span$1.to += offset), null == span$1.from) {
                        var found$1 = getMarkedSpanFor(first, span$1.marker);
                        found$1 || (span$1.from = offset, sameLine && (first || (first = [])).push(span$1));
                    } else span$1.from += offset, sameLine && (first || (first = [])).push(span$1);
                }
                // Make sure we didn't create any zero-length spans
                first && (first = clearEmptySpans(first)), last && last != first && (last = clearEmptySpans(last));
                var newMarkers = [ first ];
                if (!sameLine) {
                    // Fill gap with whole-line-spans
                    var gapMarkers, gap = change.text.length - 2;
                    if (gap > 0 && first) for (var i$2 = 0; i$2 < first.length; ++i$2) null == first[i$2].to && (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null));
                    for (var i$3 = 0; i$3 < gap; ++i$3) newMarkers.push(gapMarkers);
                    newMarkers.push(last);
                }
                return newMarkers;
            }
            // Remove spans that are empty and don't have a clearWhenEmpty
            // option of false.
            function clearEmptySpans(spans) {
                for (var i = 0; i < spans.length; ++i) {
                    var span = spans[i];
                    null != span.from && span.from == span.to && span.marker.clearWhenEmpty !== !1 && spans.splice(i--, 1);
                }
                return spans.length ? spans : null;
            }
            // Used to 'clip' out readOnly ranges when making a change.
            function removeReadOnlyRanges(doc, from, to) {
                var markers = null;
                if (doc.iter(from.line, to.line + 1, function(line) {
                    if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {
                        var mark = line.markedSpans[i].marker;
                        !mark.readOnly || markers && indexOf(markers, mark) != -1 || (markers || (markers = [])).push(mark);
                    }
                }), !markers) return null;
                for (var parts = [ {
                    from: from,
                    to: to
                } ], i = 0; i < markers.length; ++i) for (var mk = markers[i], m = mk.find(0), j = 0; j < parts.length; ++j) {
                    var p = parts[j];
                    if (!(cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0)) {
                        var newParts = [ j, 1 ], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
                        (dfrom < 0 || !mk.inclusiveLeft && !dfrom) && newParts.push({
                            from: p.from,
                            to: m.from
                        }), (dto > 0 || !mk.inclusiveRight && !dto) && newParts.push({
                            from: m.to,
                            to: p.to
                        }), parts.splice.apply(parts, newParts), j += newParts.length - 3;
                    }
                }
                return parts;
            }
            // Connect or disconnect spans from a line.
            function detachMarkedSpans(line) {
                var spans = line.markedSpans;
                if (spans) {
                    for (var i = 0; i < spans.length; ++i) spans[i].marker.detachLine(line);
                    line.markedSpans = null;
                }
            }
            function attachMarkedSpans(line, spans) {
                if (spans) {
                    for (var i = 0; i < spans.length; ++i) spans[i].marker.attachLine(line);
                    line.markedSpans = spans;
                }
            }
            // Helpers used when computing which overlapping collapsed span
            // counts as the larger one.
            function extraLeft(marker) {
                return marker.inclusiveLeft ? -1 : 0;
            }
            function extraRight(marker) {
                return marker.inclusiveRight ? 1 : 0;
            }
            // Returns a number indicating which of two overlapping collapsed
            // spans is larger (and thus includes the other). Falls back to
            // comparing ids when the spans cover exactly the same range.
            function compareCollapsedMarkers(a, b) {
                var lenDiff = a.lines.length - b.lines.length;
                if (0 != lenDiff) return lenDiff;
                var aPos = a.find(), bPos = b.find(), fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
                if (fromCmp) return -fromCmp;
                var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
                return toCmp ? toCmp : b.id - a.id;
            }
            // Find out whether a line ends or starts in a collapsed span. If
            // so, return the marker for that span.
            function collapsedSpanAtSide(line, start) {
                var found, sps = sawCollapsedSpans && line.markedSpans;
                if (sps) for (var sp = void 0, i = 0; i < sps.length; ++i) sp = sps[i], sp.marker.collapsed && null == (start ? sp.from : sp.to) && (!found || compareCollapsedMarkers(found, sp.marker) < 0) && (found = sp.marker);
                return found;
            }
            function collapsedSpanAtStart(line) {
                return collapsedSpanAtSide(line, !0);
            }
            function collapsedSpanAtEnd(line) {
                return collapsedSpanAtSide(line, !1);
            }
            // Test whether there exists a collapsed span that partially
            // overlaps (covers the start or end, but not both) of a new span.
            // Such overlap is not allowed.
            function conflictingCollapsedRange(doc, lineNo$$1, from, to, marker) {
                var line = getLine(doc, lineNo$$1), sps = sawCollapsedSpans && line.markedSpans;
                if (sps) for (var i = 0; i < sps.length; ++i) {
                    var sp = sps[i];
                    if (sp.marker.collapsed) {
                        var found = sp.marker.find(0), fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker), toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
                        if (!(fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) && (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) || fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))) return !0;
                    }
                }
            }
            // A visual line is a line as drawn on the screen. Folding, for
            // example, can cause multiple logical lines to appear on the same
            // visual line. This finds the start of the visual line that the
            // given line is part of (usually that is the line itself).
            function visualLine(line) {
                for (var merged; merged = collapsedSpanAtStart(line); ) line = merged.find(-1, !0).line;
                return line;
            }
            function visualLineEnd(line) {
                for (var merged; merged = collapsedSpanAtEnd(line); ) line = merged.find(1, !0).line;
                return line;
            }
            // Returns an array of logical lines that continue the visual line
            // started by the argument, or undefined if there are no such lines.
            function visualLineContinued(line) {
                for (var merged, lines; merged = collapsedSpanAtEnd(line); ) line = merged.find(1, !0).line, 
                (lines || (lines = [])).push(line);
                return lines;
            }
            // Get the line number of the start of the visual line that the
            // given line number is part of.
            function visualLineNo(doc, lineN) {
                var line = getLine(doc, lineN), vis = visualLine(line);
                return line == vis ? lineN : lineNo(vis);
            }
            // Get the line number of the start of the next visual line after
            // the given line.
            function visualLineEndNo(doc, lineN) {
                if (lineN > doc.lastLine()) return lineN;
                var merged, line = getLine(doc, lineN);
                if (!lineIsHidden(doc, line)) return lineN;
                for (;merged = collapsedSpanAtEnd(line); ) line = merged.find(1, !0).line;
                return lineNo(line) + 1;
            }
            // Compute whether a line is hidden. Lines count as hidden when they
            // are part of a visual line that starts with another line, or when
            // they are entirely covered by collapsed, non-widget span.
            function lineIsHidden(doc, line) {
                var sps = sawCollapsedSpans && line.markedSpans;
                if (sps) for (var sp = void 0, i = 0; i < sps.length; ++i) if (sp = sps[i], sp.marker.collapsed) {
                    if (null == sp.from) return !0;
                    if (!sp.marker.widgetNode && 0 == sp.from && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp)) return !0;
                }
            }
            function lineIsHiddenInner(doc, line, span) {
                if (null == span.to) {
                    var end = span.marker.find(1, !0);
                    return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));
                }
                if (span.marker.inclusiveRight && span.to == line.text.length) return !0;
                for (var sp = void 0, i = 0; i < line.markedSpans.length; ++i) if (sp = line.markedSpans[i], 
                sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (null == sp.to || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp)) return !0;
            }
            // Find the height above the given line.
            function heightAtLine(lineObj) {
                lineObj = visualLine(lineObj);
                for (var h = 0, chunk = lineObj.parent, i = 0; i < chunk.lines.length; ++i) {
                    var line = chunk.lines[i];
                    if (line == lineObj) break;
                    h += line.height;
                }
                for (var p = chunk.parent; p; chunk = p, p = chunk.parent) for (var i$1 = 0; i$1 < p.children.length; ++i$1) {
                    var cur = p.children[i$1];
                    if (cur == chunk) break;
                    h += cur.height;
                }
                return h;
            }
            // Compute the character length of a line, taking into account
            // collapsed ranges (see markText) that might hide parts, and join
            // other lines onto it.
            function lineLength(line) {
                if (0 == line.height) return 0;
                for (var merged, len = line.text.length, cur = line; merged = collapsedSpanAtStart(cur); ) {
                    var found = merged.find(0, !0);
                    cur = found.from.line, len += found.from.ch - found.to.ch;
                }
                for (cur = line; merged = collapsedSpanAtEnd(cur); ) {
                    var found$1 = merged.find(0, !0);
                    len -= cur.text.length - found$1.from.ch, cur = found$1.to.line, len += cur.text.length - found$1.to.ch;
                }
                return len;
            }
            // Find the longest line in the document.
            function findMaxLine(cm) {
                var d = cm.display, doc = cm.doc;
                d.maxLine = getLine(doc, doc.first), d.maxLineLength = lineLength(d.maxLine), d.maxLineChanged = !0, 
                doc.iter(function(line) {
                    var len = lineLength(line);
                    len > d.maxLineLength && (d.maxLineLength = len, d.maxLine = line);
                });
            }
            // BIDI HELPERS
            function iterateBidiSections(order, from, to, f) {
                if (!order) return f(from, to, "ltr", 0);
                for (var found = !1, i = 0; i < order.length; ++i) {
                    var part = order[i];
                    (part.from < to && part.to > from || from == to && part.to == from) && (f(Math.max(part.from, from), Math.min(part.to, to), 1 == part.level ? "rtl" : "ltr", i), 
                    found = !0);
                }
                found || f(from, to, "ltr");
            }
            function getBidiPartAt(order, ch, sticky) {
                var found;
                bidiOther = null;
                for (var i = 0; i < order.length; ++i) {
                    var cur = order[i];
                    if (cur.from < ch && cur.to > ch) return i;
                    cur.to == ch && (cur.from != cur.to && "before" == sticky ? found = i : bidiOther = i), 
                    cur.from == ch && (cur.from != cur.to && "before" != sticky ? found = i : bidiOther = i);
                }
                return null != found ? found : bidiOther;
            }
            // Get the bidi ordering for the given line (and cache it). Returns
            // false for lines that are fully left-to-right, and an array of
            // BidiSpan objects otherwise.
            function getOrder(line, direction) {
                var order = line.order;
                return null == order && (order = line.order = bidiOrdering(line.text, direction)), 
                order;
            }
            function getHandlers(emitter, type) {
                return emitter._handlers && emitter._handlers[type] || noHandlers;
            }
            function off(emitter, type, f) {
                if (emitter.removeEventListener) emitter.removeEventListener(type, f, !1); else if (emitter.detachEvent) emitter.detachEvent("on" + type, f); else {
                    var map$$1 = emitter._handlers, arr = map$$1 && map$$1[type];
                    if (arr) {
                        var index = indexOf(arr, f);
                        index > -1 && (map$$1[type] = arr.slice(0, index).concat(arr.slice(index + 1)));
                    }
                }
            }
            function signal(emitter, type) {
                var handlers = getHandlers(emitter, type);
                if (handlers.length) for (var args = Array.prototype.slice.call(arguments, 2), i = 0; i < handlers.length; ++i) handlers[i].apply(null, args);
            }
            // The DOM events that CodeMirror handles can be overridden by
            // registering a (non-DOM) handler on the editor for the event name,
            // and preventDefault-ing the event in that handler.
            function signalDOMEvent(cm, e, override) {
                return "string" == typeof e && (e = {
                    type: e,
                    preventDefault: function() {
                        this.defaultPrevented = !0;
                    }
                }), signal(cm, override || e.type, cm, e), e_defaultPrevented(e) || e.codemirrorIgnore;
            }
            function signalCursorActivity(cm) {
                var arr = cm._handlers && cm._handlers.cursorActivity;
                if (arr) for (var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []), i = 0; i < arr.length; ++i) indexOf(set, arr[i]) == -1 && set.push(arr[i]);
            }
            function hasHandler(emitter, type) {
                return getHandlers(emitter, type).length > 0;
            }
            // Add on and off methods to a constructor's prototype, to make
            // registering events on such objects more convenient.
            function eventMixin(ctor) {
                ctor.prototype.on = function(type, f) {
                    on(this, type, f);
                }, ctor.prototype.off = function(type, f) {
                    off(this, type, f);
                };
            }
            // Due to the fact that we still support jurassic IE versions, some
            // compatibility wrappers are needed.
            function e_preventDefault(e) {
                e.preventDefault ? e.preventDefault() : e.returnValue = !1;
            }
            function e_stopPropagation(e) {
                e.stopPropagation ? e.stopPropagation() : e.cancelBubble = !0;
            }
            function e_defaultPrevented(e) {
                return null != e.defaultPrevented ? e.defaultPrevented : 0 == e.returnValue;
            }
            function e_stop(e) {
                e_preventDefault(e), e_stopPropagation(e);
            }
            function e_target(e) {
                return e.target || e.srcElement;
            }
            function e_button(e) {
                var b = e.which;
                return null == b && (1 & e.button ? b = 1 : 2 & e.button ? b = 3 : 4 & e.button && (b = 2)), 
                mac && e.ctrlKey && 1 == b && (b = 3), b;
            }
            function zeroWidthElement(measure) {
                if (null == zwspSupported) {
                    var test = elt("span", "​");
                    removeChildrenAndAdd(measure, elt("span", [ test, document.createTextNode("x") ])), 
                    0 != measure.firstChild.offsetHeight && (zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8));
                }
                var node = zwspSupported ? elt("span", "​") : elt("span", " ", null, "display: inline-block; width: 1px; margin-right: -1px");
                return node.setAttribute("cm-text", ""), node;
            }
            function hasBadBidiRects(measure) {
                if (null != badBidiRects) return badBidiRects;
                var txt = removeChildrenAndAdd(measure, document.createTextNode("AخA")), r0 = range(txt, 0, 1).getBoundingClientRect(), r1 = range(txt, 1, 2).getBoundingClientRect();
                return removeChildren(measure), !(!r0 || r0.left == r0.right) && (badBidiRects = r1.right - r0.right < 3);
            }
            function hasBadZoomedRects(measure) {
                if (null != badZoomedRects) return badZoomedRects;
                var node = removeChildrenAndAdd(measure, elt("span", "x")), normal = node.getBoundingClientRect(), fromRange = range(node, 0, 1).getBoundingClientRect();
                return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;
            }
            // Extra arguments are stored as the mode's dependencies, which is
            // used by (legacy) mechanisms like loadmode.js to automatically
            // load a mode. (Preferred mechanism is the require/define calls.)
            function defineMode(name, mode) {
                arguments.length > 2 && (mode.dependencies = Array.prototype.slice.call(arguments, 2)), 
                modes[name] = mode;
            }
            function defineMIME(mime, spec) {
                mimeModes[mime] = spec;
            }
            // Given a MIME type, a {name, ...options} config object, or a name
            // string, return a mode config object.
            function resolveMode(spec) {
                if ("string" == typeof spec && mimeModes.hasOwnProperty(spec)) spec = mimeModes[spec]; else if (spec && "string" == typeof spec.name && mimeModes.hasOwnProperty(spec.name)) {
                    var found = mimeModes[spec.name];
                    "string" == typeof found && (found = {
                        name: found
                    }), spec = createObj(found, spec), spec.name = found.name;
                } else {
                    if ("string" == typeof spec && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) return resolveMode("application/xml");
                    if ("string" == typeof spec && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) return resolveMode("application/json");
                }
                return "string" == typeof spec ? {
                    name: spec
                } : spec || {
                    name: "null"
                };
            }
            // Given a mode spec (anything that resolveMode accepts), find and
            // initialize an actual mode object.
            function getMode(options, spec) {
                spec = resolveMode(spec);
                var mfactory = modes[spec.name];
                if (!mfactory) return getMode(options, "text/plain");
                var modeObj = mfactory(options, spec);
                if (modeExtensions.hasOwnProperty(spec.name)) {
                    var exts = modeExtensions[spec.name];
                    for (var prop in exts) exts.hasOwnProperty(prop) && (modeObj.hasOwnProperty(prop) && (modeObj["_" + prop] = modeObj[prop]), 
                    modeObj[prop] = exts[prop]);
                }
                if (modeObj.name = spec.name, spec.helperType && (modeObj.helperType = spec.helperType), 
                spec.modeProps) for (var prop$1 in spec.modeProps) modeObj[prop$1] = spec.modeProps[prop$1];
                return modeObj;
            }
            function extendMode(mode, properties) {
                var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {};
                copyObj(properties, exts);
            }
            function copyState(mode, state) {
                if (state === !0) return state;
                if (mode.copyState) return mode.copyState(state);
                var nstate = {};
                for (var n in state) {
                    var val = state[n];
                    val instanceof Array && (val = val.concat([])), nstate[n] = val;
                }
                return nstate;
            }
            // Given a mode and a state (for that mode), find the inner mode and
            // state at the position that the state refers to.
            function innerMode(mode, state) {
                for (var info; mode.innerMode && (info = mode.innerMode(state), info && info.mode != mode); ) state = info.state, 
                mode = info.mode;
                return info || {
                    mode: mode,
                    state: state
                };
            }
            function startState(mode, a1, a2) {
                return !mode.startState || mode.startState(a1, a2);
            }
            // Compute a style array (an array starting with a mode generation
            // -- for invalidation -- followed by pairs of end positions and
            // style strings), which is used to highlight the tokens on the
            // line.
            function highlightLine(cm, line, context, forceToEnd) {
                // A styles array always starts with a number identifying the
                // mode/overlays that it is based on (for easy invalidation).
                var st = [ cm.state.modeGen ], lineClasses = {};
                // Compute the base array of styles
                runMode(cm, line.text, cm.doc.mode, context, function(end, style) {
                    return st.push(end, style);
                }, lineClasses, forceToEnd);
                for (var state = context.state, loop = function(o) {
                    context.baseTokens = st;
                    var overlay = cm.state.overlays[o], i = 1, at = 0;
                    context.state = !0, runMode(cm, line.text, overlay.mode, context, function(end, style) {
                        // Ensure there's a token end at the current position, and that i points at it
                        for (var start = i; at < end; ) {
                            var i_end = st[i];
                            i_end > end && st.splice(i, 1, end, st[i + 1], i_end), i += 2, at = Math.min(end, i_end);
                        }
                        if (style) if (overlay.opaque) st.splice(start, i - start, end, "overlay " + style), 
                        i = start + 2; else for (;start < i; start += 2) {
                            var cur = st[start + 1];
                            st[start + 1] = (cur ? cur + " " : "") + "overlay " + style;
                        }
                    }, lineClasses), context.state = state, context.baseTokens = null, context.baseTokenPos = 1;
                }, o = 0; o < cm.state.overlays.length; ++o) loop(o);
                return {
                    styles: st,
                    classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null
                };
            }
            function getLineStyles(cm, line, updateFrontier) {
                if (!line.styles || line.styles[0] != cm.state.modeGen) {
                    var context = getContextBefore(cm, lineNo(line)), resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state), result = highlightLine(cm, line, context);
                    resetState && (context.state = resetState), line.stateAfter = context.save(!resetState), 
                    line.styles = result.styles, result.classes ? line.styleClasses = result.classes : line.styleClasses && (line.styleClasses = null), 
                    updateFrontier === cm.doc.highlightFrontier && (cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier));
                }
                return line.styles;
            }
            function getContextBefore(cm, n, precise) {
                var doc = cm.doc, display = cm.display;
                if (!doc.mode.startState) return new Context(doc, !0, n);
                var start = findStartLine(cm, n, precise), saved = start > doc.first && getLine(doc, start - 1).stateAfter, context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);
                return doc.iter(start, n, function(line) {
                    processLine(cm, line.text, context);
                    var pos = context.line;
                    line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null, 
                    context.nextLine();
                }), precise && (doc.modeFrontier = context.line), context;
            }
            // Lightweight form of highlight -- proceed over this line and
            // update state, but don't save a style array. Used for lines that
            // aren't currently visible.
            function processLine(cm, text, context, startAt) {
                var mode = cm.doc.mode, stream = new StringStream(text, cm.options.tabSize, context);
                for (stream.start = stream.pos = startAt || 0, "" == text && callBlankLine(mode, context.state); !stream.eol(); ) readToken(mode, stream, context.state), 
                stream.start = stream.pos;
            }
            function callBlankLine(mode, state) {
                if (mode.blankLine) return mode.blankLine(state);
                if (mode.innerMode) {
                    var inner = innerMode(mode, state);
                    return inner.mode.blankLine ? inner.mode.blankLine(inner.state) : void 0;
                }
            }
            function readToken(mode, stream, state, inner) {
                for (var i = 0; i < 10; i++) {
                    inner && (inner[0] = innerMode(mode, state).mode);
                    var style = mode.token(stream, state);
                    if (stream.pos > stream.start) return style;
                }
                throw new Error("Mode " + mode.name + " failed to advance stream.");
            }
            // Utility for getTokenAt and getLineTokens
            function takeToken(cm, pos, precise, asArray) {
                var style, doc = cm.doc, mode = doc.mode;
                pos = clipPos(doc, pos);
                var tokens, line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise), stream = new StringStream(line.text, cm.options.tabSize, context);
                for (asArray && (tokens = []); (asArray || stream.pos < pos.ch) && !stream.eol(); ) stream.start = stream.pos, 
                style = readToken(mode, stream, context.state), asArray && tokens.push(new Token(stream, style, copyState(doc.mode, context.state)));
                return asArray ? tokens : new Token(stream, style, context.state);
            }
            function extractLineClasses(type, output) {
                if (type) for (;;) {
                    var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
                    if (!lineClass) break;
                    type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
                    var prop = lineClass[1] ? "bgClass" : "textClass";
                    null == output[prop] ? output[prop] = lineClass[2] : new RegExp("(?:^|s)" + lineClass[2] + "(?:$|s)").test(output[prop]) || (output[prop] += " " + lineClass[2]);
                }
                return type;
            }
            // Run the given mode's parser over a line, calling f for each token.
            function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {
                var flattenSpans = mode.flattenSpans;
                null == flattenSpans && (flattenSpans = cm.options.flattenSpans);
                var style, curStart = 0, curStyle = null, stream = new StringStream(text, cm.options.tabSize, context), inner = cm.options.addModeClass && [ null ];
                for ("" == text && extractLineClasses(callBlankLine(mode, context.state), lineClasses); !stream.eol(); ) {
                    if (stream.pos > cm.options.maxHighlightLength ? (flattenSpans = !1, forceToEnd && processLine(cm, text, context, stream.pos), 
                    stream.pos = text.length, style = null) : style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses), 
                    inner) {
                        var mName = inner[0].name;
                        mName && (style = "m-" + (style ? mName + " " + style : mName));
                    }
                    if (!flattenSpans || curStyle != style) {
                        for (;curStart < stream.start; ) curStart = Math.min(stream.start, curStart + 5e3), 
                        f(curStart, curStyle);
                        curStyle = style;
                    }
                    stream.start = stream.pos;
                }
                for (;curStart < stream.pos; ) {
                    // Webkit seems to refuse to render text nodes longer than 57444
                    // characters, and returns inaccurate measurements in nodes
                    // starting around 5000 chars.
                    var pos = Math.min(stream.pos, curStart + 5e3);
                    f(pos, curStyle), curStart = pos;
                }
            }
            // Finds the line to start with when starting a parse. Tries to
            // find a line with a stateAfter, so that it can start with a
            // valid state. If that fails, it returns the line with the
            // smallest indentation, which tends to need the least context to
            // parse correctly.
            function findStartLine(cm, n, precise) {
                for (var minindent, minline, doc = cm.doc, lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1e3 : 100), search = n; search > lim; --search) {
                    if (search <= doc.first) return doc.first;
                    var line = getLine(doc, search - 1), after = line.stateAfter;
                    if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier)) return search;
                    var indented = countColumn(line.text, null, cm.options.tabSize);
                    (null == minline || minindent > indented) && (minline = search - 1, minindent = indented);
                }
                return minline;
            }
            function retreatFrontier(doc, n) {
                if (doc.modeFrontier = Math.min(doc.modeFrontier, n), !(doc.highlightFrontier < n - 10)) {
                    for (var start = doc.first, line = n - 1; line > start; line--) {
                        var saved = getLine(doc, line).stateAfter;
                        // change is on 3
                        // state on line 1 looked ahead 2 -- so saw 3
                        // test 1 + 2 < 3 should cover this
                        if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {
                            start = line + 1;
                            break;
                        }
                    }
                    doc.highlightFrontier = Math.min(doc.highlightFrontier, start);
                }
            }
            // Change the content (text, markers) of a line. Automatically
            // invalidates cached information and tries to re-estimate the
            // line's height.
            function updateLine(line, text, markedSpans, estimateHeight) {
                line.text = text, line.stateAfter && (line.stateAfter = null), line.styles && (line.styles = null), 
                null != line.order && (line.order = null), detachMarkedSpans(line), attachMarkedSpans(line, markedSpans);
                var estHeight = estimateHeight ? estimateHeight(line) : 1;
                estHeight != line.height && updateLineHeight(line, estHeight);
            }
            // Detach a line from the document tree and its markers.
            function cleanUpLine(line) {
                line.parent = null, detachMarkedSpans(line);
            }
            function interpretTokenStyle(style, options) {
                if (!style || /^\s*$/.test(style)) return null;
                var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
                return cache[style] || (cache[style] = style.replace(/\S+/g, "cm-$&"));
            }
            // Render the DOM representation of the text of a line. Also builds
            // up a 'line map', which points at the DOM nodes that represent
            // specific stretches of text, and is used by the measuring code.
            // The returned object contains the DOM node, this map, and
            // information about line-wide styles that were set by the mode.
            function buildLineContent(cm, lineView) {
                // The padding-right forces the element to have a 'border', which
                // is needed on Webkit to be able to get line-level bounding
                // rectangles for it (in measureChar).
                var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null), builder = {
                    pre: eltP("pre", [ content ], "CodeMirror-line"),
                    content: content,
                    col: 0,
                    pos: 0,
                    cm: cm,
                    trailingSpace: !1,
                    splitSpaces: (ie || webkit) && cm.getOption("lineWrapping")
                };
                lineView.measure = {};
                // Iterate over the logical lines that make up this visual line.
                for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
                    var line = i ? lineView.rest[i - 1] : lineView.line, order = void 0;
                    builder.pos = 0, builder.addToken = buildToken, // Optionally wire in some hacks into the token-rendering
                    // algorithm, to deal with browser quirks.
                    hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction)) && (builder.addToken = buildTokenBadBidi(builder.addToken, order)), 
                    builder.map = [];
                    var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
                    insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate)), 
                    line.styleClasses && (line.styleClasses.bgClass && (builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "")), 
                    line.styleClasses.textClass && (builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || ""))), 
                    // Ensure at least a single node is present, for measuring.
                    0 == builder.map.length && builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))), 
                    // Store the map and a cache object for the current logical line
                    0 == i ? (lineView.measure.map = builder.map, lineView.measure.cache = {}) : ((lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map), 
                    (lineView.measure.caches || (lineView.measure.caches = [])).push({}));
                }
                // See issue #2901
                if (webkit) {
                    var last = builder.content.lastChild;
                    (/\bcm-tab\b/.test(last.className) || last.querySelector && last.querySelector(".cm-tab")) && (builder.content.className = "cm-tab-wrap-hack");
                }
                return signal(cm, "renderLine", cm, lineView.line, builder.pre), builder.pre.className && (builder.textClass = joinClasses(builder.pre.className, builder.textClass || "")), 
                builder;
            }
            function defaultSpecialCharPlaceholder(ch) {
                var token = elt("span", "•", "cm-invalidchar");
                return token.title = "\\u" + ch.charCodeAt(0).toString(16), token.setAttribute("aria-label", token.title), 
                token;
            }
            // Build up the DOM representation for a single token, and add it to
            // the line map. Takes care to render special characters separately.
            function buildToken(builder, text, style, startStyle, endStyle, title, css) {
                if (text) {
                    var content, displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text, special = builder.cm.state.specialChars, mustWrap = !1;
                    if (special.test(text)) {
                        content = document.createDocumentFragment();
                        for (var pos = 0; ;) {
                            special.lastIndex = pos;
                            var m = special.exec(text), skipped = m ? m.index - pos : text.length - pos;
                            if (skipped) {
                                var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
                                ie && ie_version < 9 ? content.appendChild(elt("span", [ txt ])) : content.appendChild(txt), 
                                builder.map.push(builder.pos, builder.pos + skipped, txt), builder.col += skipped, 
                                builder.pos += skipped;
                            }
                            if (!m) break;
                            pos += skipped + 1;
                            var txt$1 = void 0;
                            if ("\t" == m[0]) {
                                var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
                                txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab")), txt$1.setAttribute("role", "presentation"), 
                                txt$1.setAttribute("cm-text", "\t"), builder.col += tabWidth;
                            } else "\r" == m[0] || "\n" == m[0] ? (txt$1 = content.appendChild(elt("span", "\r" == m[0] ? "␍" : "␤", "cm-invalidchar")), 
                            txt$1.setAttribute("cm-text", m[0]), builder.col += 1) : (txt$1 = builder.cm.options.specialCharPlaceholder(m[0]), 
                            txt$1.setAttribute("cm-text", m[0]), ie && ie_version < 9 ? content.appendChild(elt("span", [ txt$1 ])) : content.appendChild(txt$1), 
                            builder.col += 1);
                            builder.map.push(builder.pos, builder.pos + 1, txt$1), builder.pos++;
                        }
                    } else builder.col += text.length, content = document.createTextNode(displayText), 
                    builder.map.push(builder.pos, builder.pos + text.length, content), ie && ie_version < 9 && (mustWrap = !0), 
                    builder.pos += text.length;
                    if (builder.trailingSpace = 32 == displayText.charCodeAt(text.length - 1), style || startStyle || endStyle || mustWrap || css) {
                        var fullStyle = style || "";
                        startStyle && (fullStyle += startStyle), endStyle && (fullStyle += endStyle);
                        var token = elt("span", [ content ], fullStyle, css);
                        return title && (token.title = title), builder.content.appendChild(token);
                    }
                    builder.content.appendChild(content);
                }
            }
            function splitSpaces(text, trailingBefore) {
                if (text.length > 1 && !/  /.test(text)) return text;
                for (var spaceBefore = trailingBefore, result = "", i = 0; i < text.length; i++) {
                    var ch = text.charAt(i);
                    " " != ch || !spaceBefore || i != text.length - 1 && 32 != text.charCodeAt(i + 1) || (ch = " "), 
                    result += ch, spaceBefore = " " == ch;
                }
                return result;
            }
            // Work around nonsense dimensions being reported for stretches of
            // right-to-left text.
            function buildTokenBadBidi(inner, order) {
                return function(builder, text, style, startStyle, endStyle, title, css) {
                    style = style ? style + " cm-force-border" : "cm-force-border";
                    for (var start = builder.pos, end = start + text.length; ;) {
                        for (var part = void 0, i = 0; i < order.length && (part = order[i], !(part.to > start && part.from <= start)); i++) ;
                        if (part.to >= end) return inner(builder, text, style, startStyle, endStyle, title, css);
                        inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css), 
                        startStyle = null, text = text.slice(part.to - start), start = part.to;
                    }
                };
            }
            function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
                var widget = !ignoreWidget && marker.widgetNode;
                widget && builder.map.push(builder.pos, builder.pos + size, widget), !ignoreWidget && builder.cm.display.input.needsContentAttribute && (widget || (widget = builder.content.appendChild(document.createElement("span"))), 
                widget.setAttribute("cm-marker", marker.id)), widget && (builder.cm.display.input.setUneditable(widget), 
                builder.content.appendChild(widget)), builder.pos += size, builder.trailingSpace = !1;
            }
            // Outputs a number of spans to make up a line, taking highlighting
            // and marked text into account.
            function insertLineContent(line, builder, styles) {
                var spans = line.markedSpans, allText = line.text, at = 0;
                if (spans) for (var style, css, spanStyle, spanEndStyle, spanStartStyle, title, collapsed, len = allText.length, pos = 0, i = 1, text = "", nextChange = 0; ;) {
                    if (nextChange == pos) {
                        // Update current marker set
                        spanStyle = spanEndStyle = spanStartStyle = title = css = "", collapsed = null, 
                        nextChange = 1 / 0;
                        for (var foundBookmarks = [], endStyles = void 0, j = 0; j < spans.length; ++j) {
                            var sp = spans[j], m = sp.marker;
                            "bookmark" == m.type && sp.from == pos && m.widgetNode ? foundBookmarks.push(m) : sp.from <= pos && (null == sp.to || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos) ? (null != sp.to && sp.to != pos && nextChange > sp.to && (nextChange = sp.to, 
                            spanEndStyle = ""), m.className && (spanStyle += " " + m.className), m.css && (css = (css ? css + ";" : "") + m.css), 
                            m.startStyle && sp.from == pos && (spanStartStyle += " " + m.startStyle), m.endStyle && sp.to == nextChange && (endStyles || (endStyles = [])).push(m.endStyle, sp.to), 
                            m.title && !title && (title = m.title), m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0) && (collapsed = sp)) : sp.from > pos && nextChange > sp.from && (nextChange = sp.from);
                        }
                        if (endStyles) for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2) endStyles[j$1 + 1] == nextChange && (spanEndStyle += " " + endStyles[j$1]);
                        if (!collapsed || collapsed.from == pos) for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2) buildCollapsedSpan(builder, 0, foundBookmarks[j$2]);
                        if (collapsed && (collapsed.from || 0) == pos) {
                            if (buildCollapsedSpan(builder, (null == collapsed.to ? len + 1 : collapsed.to) - pos, collapsed.marker, null == collapsed.from), 
                            null == collapsed.to) return;
                            collapsed.to == pos && (collapsed = !1);
                        }
                    }
                    if (pos >= len) break;
                    for (var upto = Math.min(len, nextChange); ;) {
                        if (text) {
                            var end = pos + text.length;
                            if (!collapsed) {
                                var tokenText = end > upto ? text.slice(0, upto - pos) : text;
                                builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", title, css);
                            }
                            if (end >= upto) {
                                text = text.slice(upto - pos), pos = upto;
                                break;
                            }
                            pos = end, spanStartStyle = "";
                        }
                        text = allText.slice(at, at = styles[i++]), style = interpretTokenStyle(styles[i++], builder.cm.options);
                    }
                } else for (var i$1 = 1; i$1 < styles.length; i$1 += 2) builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1 + 1], builder.cm.options));
            }
            // These objects are used to represent the visible (currently drawn)
            // part of the document. A LineView may correspond to multiple
            // logical lines, if those are connected by collapsed ranges.
            function LineView(doc, line, lineN) {
                // The starting line
                this.line = line, // Continuing lines, if any
                this.rest = visualLineContinued(line), // Number of logical lines in this visual line
                this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1, this.node = this.text = null, 
                this.hidden = lineIsHidden(doc, line);
            }
            // Create a range of LineView objects for the given lines.
            function buildViewArray(cm, from, to) {
                for (var nextPos, array = [], pos = from; pos < to; pos = nextPos) {
                    var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
                    nextPos = pos + view.size, array.push(view);
                }
                return array;
            }
            function pushOperation(op) {
                operationGroup ? operationGroup.ops.push(op) : op.ownsGroup = operationGroup = {
                    ops: [ op ],
                    delayedCallbacks: []
                };
            }
            function fireCallbacksForOps(group) {
                // Calls delayed callbacks and cursorActivity handlers until no
                // new ones appear
                var callbacks = group.delayedCallbacks, i = 0;
                do {
                    for (;i < callbacks.length; i++) callbacks[i].call(null);
                    for (var j = 0; j < group.ops.length; j++) {
                        var op = group.ops[j];
                        if (op.cursorActivityHandlers) for (;op.cursorActivityCalled < op.cursorActivityHandlers.length; ) op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);
                    }
                } while (i < callbacks.length);
            }
            function finishOperation(op, endCb) {
                var group = op.ownsGroup;
                if (group) try {
                    fireCallbacksForOps(group);
                } finally {
                    operationGroup = null, endCb(group);
                }
            }
            // Often, we want to signal events at a point where we are in the
            // middle of some work, but don't want the handler to start calling
            // other methods on the editor, which might be in an inconsistent
            // state or simply not expect any other events to happen.
            // signalLater looks whether there are any handlers, and schedules
            // them to be executed when the last operation ends, or, if no
            // operation is active, when a timeout fires.
            function signalLater(emitter, type) {
                var arr = getHandlers(emitter, type);
                if (arr.length) {
                    var list, args = Array.prototype.slice.call(arguments, 2);
                    operationGroup ? list = operationGroup.delayedCallbacks : orphanDelayedCallbacks ? list = orphanDelayedCallbacks : (list = orphanDelayedCallbacks = [], 
                    setTimeout(fireOrphanDelayed, 0));
                    for (var loop = function(i) {
                        list.push(function() {
                            return arr[i].apply(null, args);
                        });
                    }, i = 0; i < arr.length; ++i) loop(i);
                }
            }
            function fireOrphanDelayed() {
                var delayed = orphanDelayedCallbacks;
                orphanDelayedCallbacks = null;
                for (var i = 0; i < delayed.length; ++i) delayed[i]();
            }
            // When an aspect of a line changes, a string is added to
            // lineView.changes. This updates the relevant part of the line's
            // DOM structure.
            function updateLineForChanges(cm, lineView, lineN, dims) {
                for (var j = 0; j < lineView.changes.length; j++) {
                    var type = lineView.changes[j];
                    "text" == type ? updateLineText(cm, lineView) : "gutter" == type ? updateLineGutter(cm, lineView, lineN, dims) : "class" == type ? updateLineClasses(cm, lineView) : "widget" == type && updateLineWidgets(cm, lineView, dims);
                }
                lineView.changes = null;
            }
            // Lines with gutter elements, widgets or a background class need to
            // be wrapped, and have the extra elements added to the wrapper div
            function ensureLineWrapped(lineView) {
                return lineView.node == lineView.text && (lineView.node = elt("div", null, null, "position: relative"), 
                lineView.text.parentNode && lineView.text.parentNode.replaceChild(lineView.node, lineView.text), 
                lineView.node.appendChild(lineView.text), ie && ie_version < 8 && (lineView.node.style.zIndex = 2)), 
                lineView.node;
            }
            function updateLineBackground(cm, lineView) {
                var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
                if (cls && (cls += " CodeMirror-linebackground"), lineView.background) cls ? lineView.background.className = cls : (lineView.background.parentNode.removeChild(lineView.background), 
                lineView.background = null); else if (cls) {
                    var wrap = ensureLineWrapped(lineView);
                    lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild), 
                    cm.display.input.setUneditable(lineView.background);
                }
            }
            // Wrapper around buildLineContent which will reuse the structure
            // in display.externalMeasured when possible.
            function getLineContent(cm, lineView) {
                var ext = cm.display.externalMeasured;
                return ext && ext.line == lineView.line ? (cm.display.externalMeasured = null, lineView.measure = ext.measure, 
                ext.built) : buildLineContent(cm, lineView);
            }
            // Redraw the line's text. Interacts with the background and text
            // classes because the mode may output tokens that influence these
            // classes.
            function updateLineText(cm, lineView) {
                var cls = lineView.text.className, built = getLineContent(cm, lineView);
                lineView.text == lineView.node && (lineView.node = built.pre), lineView.text.parentNode.replaceChild(built.pre, lineView.text), 
                lineView.text = built.pre, built.bgClass != lineView.bgClass || built.textClass != lineView.textClass ? (lineView.bgClass = built.bgClass, 
                lineView.textClass = built.textClass, updateLineClasses(cm, lineView)) : cls && (lineView.text.className = cls);
            }
            function updateLineClasses(cm, lineView) {
                updateLineBackground(cm, lineView), lineView.line.wrapClass ? ensureLineWrapped(lineView).className = lineView.line.wrapClass : lineView.node != lineView.text && (lineView.node.className = "");
                var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
                lineView.text.className = textClass || "";
            }
            function updateLineGutter(cm, lineView, lineN, dims) {
                if (lineView.gutter && (lineView.node.removeChild(lineView.gutter), lineView.gutter = null), 
                lineView.gutterBackground && (lineView.node.removeChild(lineView.gutterBackground), 
                lineView.gutterBackground = null), lineView.line.gutterClass) {
                    var wrap = ensureLineWrapped(lineView);
                    lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass, "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + dims.gutterTotalWidth + "px"), 
                    cm.display.input.setUneditable(lineView.gutterBackground), wrap.insertBefore(lineView.gutterBackground, lineView.text);
                }
                var markers = lineView.line.gutterMarkers;
                if (cm.options.lineNumbers || markers) {
                    var wrap$1 = ensureLineWrapped(lineView), gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px");
                    if (cm.display.input.setUneditable(gutterWrap), wrap$1.insertBefore(gutterWrap, lineView.text), 
                    lineView.line.gutterClass && (gutterWrap.className += " " + lineView.line.gutterClass), 
                    !cm.options.lineNumbers || markers && markers["CodeMirror-linenumbers"] || (lineView.lineNumber = gutterWrap.appendChild(elt("div", lineNumberFor(cm.options, lineN), "CodeMirror-linenumber CodeMirror-gutter-elt", "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + cm.display.lineNumInnerWidth + "px"))), 
                    markers) for (var k = 0; k < cm.options.gutters.length; ++k) {
                        var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];
                        found && gutterWrap.appendChild(elt("div", [ found ], "CodeMirror-gutter-elt", "left: " + dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"));
                    }
                }
            }
            function updateLineWidgets(cm, lineView, dims) {
                lineView.alignable && (lineView.alignable = null);
                for (var node = lineView.node.firstChild, next = void 0; node; node = next) next = node.nextSibling, 
                "CodeMirror-linewidget" == node.className && lineView.node.removeChild(node);
                insertLineWidgets(cm, lineView, dims);
            }
            // Build a line's DOM representation from scratch
            function buildLineElement(cm, lineView, lineN, dims) {
                var built = getLineContent(cm, lineView);
                return lineView.text = lineView.node = built.pre, built.bgClass && (lineView.bgClass = built.bgClass), 
                built.textClass && (lineView.textClass = built.textClass), updateLineClasses(cm, lineView), 
                updateLineGutter(cm, lineView, lineN, dims), insertLineWidgets(cm, lineView, dims), 
                lineView.node;
            }
            // A lineView may contain multiple logical lines (when merged by
            // collapsed spans). The widgets for all of them need to be drawn.
            function insertLineWidgets(cm, lineView, dims) {
                if (insertLineWidgetsFor(cm, lineView.line, lineView, dims, !0), lineView.rest) for (var i = 0; i < lineView.rest.length; i++) insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, !1);
            }
            function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
                if (line.widgets) for (var wrap = ensureLineWrapped(lineView), i = 0, ws = line.widgets; i < ws.length; ++i) {
                    var widget = ws[i], node = elt("div", [ widget.node ], "CodeMirror-linewidget");
                    widget.handleMouseEvents || node.setAttribute("cm-ignore-events", "true"), positionLineWidget(widget, node, lineView, dims), 
                    cm.display.input.setUneditable(node), allowAbove && widget.above ? wrap.insertBefore(node, lineView.gutter || lineView.text) : wrap.appendChild(node), 
                    signalLater(widget, "redraw");
                }
            }
            function positionLineWidget(widget, node, lineView, dims) {
                if (widget.noHScroll) {
                    (lineView.alignable || (lineView.alignable = [])).push(node);
                    var width = dims.wrapperWidth;
                    node.style.left = dims.fixedPos + "px", widget.coverGutter || (width -= dims.gutterTotalWidth, 
                    node.style.paddingLeft = dims.gutterTotalWidth + "px"), node.style.width = width + "px";
                }
                widget.coverGutter && (node.style.zIndex = 5, node.style.position = "relative", 
                widget.noHScroll || (node.style.marginLeft = -dims.gutterTotalWidth + "px"));
            }
            function widgetHeight(widget) {
                if (null != widget.height) return widget.height;
                var cm = widget.doc.cm;
                if (!cm) return 0;
                if (!contains(document.body, widget.node)) {
                    var parentStyle = "position: relative;";
                    widget.coverGutter && (parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;"), 
                    widget.noHScroll && (parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;"), 
                    removeChildrenAndAdd(cm.display.measure, elt("div", [ widget.node ], null, parentStyle));
                }
                return widget.height = widget.node.parentNode.offsetHeight;
            }
            // Return true when the given mouse event happened in a widget
            function eventInWidget(display, e) {
                for (var n = e_target(e); n != display.wrapper; n = n.parentNode) if (!n || 1 == n.nodeType && "true" == n.getAttribute("cm-ignore-events") || n.parentNode == display.sizer && n != display.mover) return !0;
            }
            // POSITION MEASUREMENT
            function paddingTop(display) {
                return display.lineSpace.offsetTop;
            }
            function paddingVert(display) {
                return display.mover.offsetHeight - display.lineSpace.offsetHeight;
            }
            function paddingH(display) {
                if (display.cachedPaddingH) return display.cachedPaddingH;
                var e = removeChildrenAndAdd(display.measure, elt("pre", "x")), style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle, data = {
                    left: parseInt(style.paddingLeft),
                    right: parseInt(style.paddingRight)
                };
                return isNaN(data.left) || isNaN(data.right) || (display.cachedPaddingH = data), 
                data;
            }
            function scrollGap(cm) {
                return scrollerGap - cm.display.nativeBarWidth;
            }
            function displayWidth(cm) {
                return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;
            }
            function displayHeight(cm) {
                return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;
            }
            // Ensure the lineView.wrapping.heights array is populated. This is
            // an array of bottom offsets for the lines that make up a drawn
            // line. When lineWrapping is on, there might be more than one
            // height.
            function ensureLineHeights(cm, lineView, rect) {
                var wrapping = cm.options.lineWrapping, curWidth = wrapping && displayWidth(cm);
                if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
                    var heights = lineView.measure.heights = [];
                    if (wrapping) {
                        lineView.measure.width = curWidth;
                        for (var rects = lineView.text.firstChild.getClientRects(), i = 0; i < rects.length - 1; i++) {
                            var cur = rects[i], next = rects[i + 1];
                            Math.abs(cur.bottom - next.bottom) > 2 && heights.push((cur.bottom + next.top) / 2 - rect.top);
                        }
                    }
                    heights.push(rect.bottom - rect.top);
                }
            }
            // Find a line map (mapping character offsets to text nodes) and a
            // measurement cache for the given line number. (A line view might
            // contain multiple lines when collapsed ranges are present.)
            function mapFromLineView(lineView, line, lineN) {
                if (lineView.line == line) return {
                    map: lineView.measure.map,
                    cache: lineView.measure.cache
                };
                for (var i = 0; i < lineView.rest.length; i++) if (lineView.rest[i] == line) return {
                    map: lineView.measure.maps[i],
                    cache: lineView.measure.caches[i]
                };
                for (var i$1 = 0; i$1 < lineView.rest.length; i$1++) if (lineNo(lineView.rest[i$1]) > lineN) return {
                    map: lineView.measure.maps[i$1],
                    cache: lineView.measure.caches[i$1],
                    before: !0
                };
            }
            // Render a line into the hidden node display.externalMeasured. Used
            // when measurement is needed for a line that's not in the viewport.
            function updateExternalMeasurement(cm, line) {
                line = visualLine(line);
                var lineN = lineNo(line), view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
                view.lineN = lineN;
                var built = view.built = buildLineContent(cm, view);
                return view.text = built.pre, removeChildrenAndAdd(cm.display.lineMeasure, built.pre), 
                view;
            }
            // Get a {top, bottom, left, right} box (in line-local coordinates)
            // for a given character.
            function measureChar(cm, line, ch, bias) {
                return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);
            }
            // Find a line view that corresponds to the given line number.
            function findViewForLine(cm, lineN) {
                if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo) return cm.display.view[findViewIndex(cm, lineN)];
                var ext = cm.display.externalMeasured;
                return ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size ? ext : void 0;
            }
            // Measurement can be split in two steps, the set-up work that
            // applies to the whole line, and the measurement of the actual
            // character. Functions like coordsChar, that need to do a lot of
            // measurements in a row, can thus ensure that the set-up work is
            // only done once.
            function prepareMeasureForLine(cm, line) {
                var lineN = lineNo(line), view = findViewForLine(cm, lineN);
                view && !view.text ? view = null : view && view.changes && (updateLineForChanges(cm, view, lineN, getDimensions(cm)), 
                cm.curOp.forceUpdate = !0), view || (view = updateExternalMeasurement(cm, line));
                var info = mapFromLineView(view, line, lineN);
                return {
                    line: line,
                    view: view,
                    rect: null,
                    map: info.map,
                    cache: info.cache,
                    before: info.before,
                    hasHeights: !1
                };
            }
            // Given a prepared measurement object, measures the position of an
            // actual character (or fetches it from the cache).
            function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
                prepared.before && (ch = -1);
                var found, key = ch + (bias || "");
                return prepared.cache.hasOwnProperty(key) ? found = prepared.cache[key] : (prepared.rect || (prepared.rect = prepared.view.text.getBoundingClientRect()), 
                prepared.hasHeights || (ensureLineHeights(cm, prepared.view, prepared.rect), prepared.hasHeights = !0), 
                found = measureCharInner(cm, prepared, ch, bias), found.bogus || (prepared.cache[key] = found)), 
                {
                    left: found.left,
                    right: found.right,
                    top: varHeight ? found.rtop : found.top,
                    bottom: varHeight ? found.rbottom : found.bottom
                };
            }
            function nodeAndOffsetInLineMap(map$$1, ch, bias) {
                // First, search the line map for the text node corresponding to,
                // or closest to, the target character.
                for (var node, start, end, collapse, mStart, mEnd, i = 0; i < map$$1.length; i += 3) if (mStart = map$$1[i], 
                mEnd = map$$1[i + 1], ch < mStart ? (start = 0, end = 1, collapse = "left") : ch < mEnd ? (start = ch - mStart, 
                end = start + 1) : (i == map$$1.length - 3 || ch == mEnd && map$$1[i + 3] > ch) && (end = mEnd - mStart, 
                start = end - 1, ch >= mEnd && (collapse = "right")), null != start) {
                    if (node = map$$1[i + 2], mStart == mEnd && bias == (node.insertLeft ? "left" : "right") && (collapse = bias), 
                    "left" == bias && 0 == start) for (;i && map$$1[i - 2] == map$$1[i - 3] && map$$1[i - 1].insertLeft; ) node = map$$1[(i -= 3) + 2], 
                    collapse = "left";
                    if ("right" == bias && start == mEnd - mStart) for (;i < map$$1.length - 3 && map$$1[i + 3] == map$$1[i + 4] && !map$$1[i + 5].insertLeft; ) node = map$$1[(i += 3) + 2], 
                    collapse = "right";
                    break;
                }
                return {
                    node: node,
                    start: start,
                    end: end,
                    collapse: collapse,
                    coverStart: mStart,
                    coverEnd: mEnd
                };
            }
            function getUsefulRect(rects, bias) {
                var rect = nullRect;
                if ("left" == bias) for (var i = 0; i < rects.length && (rect = rects[i]).left == rect.right; i++) ; else for (var i$1 = rects.length - 1; i$1 >= 0 && (rect = rects[i$1]).left == rect.right; i$1--) ;
                return rect;
            }
            function measureCharInner(cm, prepared, ch, bias) {
                var rect, place = nodeAndOffsetInLineMap(prepared.map, ch, bias), node = place.node, start = place.start, end = place.end, collapse = place.collapse;
                if (3 == node.nodeType) {
                    // If it is a text node, use a range to retrieve the coordinates.
                    for (var i$1 = 0; i$1 < 4; i$1++) {
                        // Retry a maximum of 4 times when nonsense rectangles are returned
                        for (;start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start)); ) --start;
                        for (;place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end)); ) ++end;
                        if (rect = ie && ie_version < 9 && 0 == start && end == place.coverEnd - place.coverStart ? node.parentNode.getBoundingClientRect() : getUsefulRect(range(node, start, end).getClientRects(), bias), 
                        rect.left || rect.right || 0 == start) break;
                        end = start, start -= 1, collapse = "right";
                    }
                    ie && ie_version < 11 && (rect = maybeUpdateRectForZooming(cm.display.measure, rect));
                } else {
                    // If it is a widget, simply get the box for the whole widget.
                    start > 0 && (collapse = bias = "right");
                    var rects;
                    rect = cm.options.lineWrapping && (rects = node.getClientRects()).length > 1 ? rects["right" == bias ? rects.length - 1 : 0] : node.getBoundingClientRect();
                }
                if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
                    var rSpan = node.parentNode.getClientRects()[0];
                    rect = rSpan ? {
                        left: rSpan.left,
                        right: rSpan.left + charWidth(cm.display),
                        top: rSpan.top,
                        bottom: rSpan.bottom
                    } : nullRect;
                }
                for (var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top, mid = (rtop + rbot) / 2, heights = prepared.view.measure.heights, i = 0; i < heights.length - 1 && !(mid < heights[i]); i++) ;
                var top = i ? heights[i - 1] : 0, bot = heights[i], result = {
                    left: ("right" == collapse ? rect.right : rect.left) - prepared.rect.left,
                    right: ("left" == collapse ? rect.left : rect.right) - prepared.rect.left,
                    top: top,
                    bottom: bot
                };
                return rect.left || rect.right || (result.bogus = !0), cm.options.singleCursorHeightPerLine || (result.rtop = rtop, 
                result.rbottom = rbot), result;
            }
            // Work around problem with bounding client rects on ranges being
            // returned incorrectly when zoomed on IE10 and below.
            function maybeUpdateRectForZooming(measure, rect) {
                if (!window.screen || null == screen.logicalXDPI || screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure)) return rect;
                var scaleX = screen.logicalXDPI / screen.deviceXDPI, scaleY = screen.logicalYDPI / screen.deviceYDPI;
                return {
                    left: rect.left * scaleX,
                    right: rect.right * scaleX,
                    top: rect.top * scaleY,
                    bottom: rect.bottom * scaleY
                };
            }
            function clearLineMeasurementCacheFor(lineView) {
                if (lineView.measure && (lineView.measure.cache = {}, lineView.measure.heights = null, 
                lineView.rest)) for (var i = 0; i < lineView.rest.length; i++) lineView.measure.caches[i] = {};
            }
            function clearLineMeasurementCache(cm) {
                cm.display.externalMeasure = null, removeChildren(cm.display.lineMeasure);
                for (var i = 0; i < cm.display.view.length; i++) clearLineMeasurementCacheFor(cm.display.view[i]);
            }
            function clearCaches(cm) {
                clearLineMeasurementCache(cm), cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null, 
                cm.options.lineWrapping || (cm.display.maxLineChanged = !0), cm.display.lineNumChars = null;
            }
            function pageScrollX() {
                // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206
                // which causes page_Offset and bounding client rects to use
                // different reference viewports and invalidate our calculations.
                // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206
                // which causes page_Offset and bounding client rects to use
                // different reference viewports and invalidate our calculations.
                return chrome && android ? -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) : window.pageXOffset || (document.documentElement || document.body).scrollLeft;
            }
            function pageScrollY() {
                return chrome && android ? -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) : window.pageYOffset || (document.documentElement || document.body).scrollTop;
            }
            function widgetTopHeight(lineObj) {
                var height = 0;
                if (lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) lineObj.widgets[i].above && (height += widgetHeight(lineObj.widgets[i]));
                return height;
            }
            // Converts a {top, bottom, left, right} box from line-local
            // coordinates into another coordinate system. Context may be one of
            // "line", "div" (display.lineDiv), "local"./null (editor), "window",
            // or "page".
            function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
                if (!includeWidgets) {
                    var height = widgetTopHeight(lineObj);
                    rect.top += height, rect.bottom += height;
                }
                if ("line" == context) return rect;
                context || (context = "local");
                var yOff = heightAtLine(lineObj);
                if ("local" == context ? yOff += paddingTop(cm.display) : yOff -= cm.display.viewOffset, 
                "page" == context || "window" == context) {
                    var lOff = cm.display.lineSpace.getBoundingClientRect();
                    yOff += lOff.top + ("window" == context ? 0 : pageScrollY());
                    var xOff = lOff.left + ("window" == context ? 0 : pageScrollX());
                    rect.left += xOff, rect.right += xOff;
                }
                return rect.top += yOff, rect.bottom += yOff, rect;
            }
            // Coverts a box from "div" coords to another coordinate system.
            // Context may be "window", "page", "div", or "local"./null.
            function fromCoordSystem(cm, coords, context) {
                if ("div" == context) return coords;
                var left = coords.left, top = coords.top;
                // First move into "page" coordinate system
                if ("page" == context) left -= pageScrollX(), top -= pageScrollY(); else if ("local" == context || !context) {
                    var localBox = cm.display.sizer.getBoundingClientRect();
                    left += localBox.left, top += localBox.top;
                }
                var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
                return {
                    left: left - lineSpaceBox.left,
                    top: top - lineSpaceBox.top
                };
            }
            function charCoords(cm, pos, context, lineObj, bias) {
                return lineObj || (lineObj = getLine(cm.doc, pos.line)), intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);
            }
            // Returns a box for a given cursor position, which may have an
            // 'other' property containing the position of the secondary cursor
            // on a bidi boundary.
            // A cursor Pos(line, char, "before") is on the same visual line as `char - 1`
            // and after `char - 1` in writing order of `char - 1`
            // A cursor Pos(line, char, "after") is on the same visual line as `char`
            // and before `char` in writing order of `char`
            // Examples (upper-case letters are RTL, lower-case are LTR):
            //     Pos(0, 1, ...)
            //     before   after
            // ab     a|b     a|b
            // aB     a|B     aB|
            // Ab     |Ab     A|b
            // AB     B|A     B|A
            // Every position after the last character on a line is considered to stick
            // to the last character on the line.
            function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
                function get(ch, right) {
                    var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);
                    return right ? m.left = m.right : m.right = m.left, intoCoordSystem(cm, lineObj, m, context);
                }
                function getBidi(ch, partPos, invert) {
                    var part = order[partPos], right = 1 == part.level;
                    return get(invert ? ch - 1 : ch, right != invert);
                }
                lineObj = lineObj || getLine(cm.doc, pos.line), preparedMeasure || (preparedMeasure = prepareMeasureForLine(cm, lineObj));
                var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;
                if (ch >= lineObj.text.length ? (ch = lineObj.text.length, sticky = "before") : ch <= 0 && (ch = 0, 
                sticky = "after"), !order) return get("before" == sticky ? ch - 1 : ch, "before" == sticky);
                var partPos = getBidiPartAt(order, ch, sticky), other = bidiOther, val = getBidi(ch, partPos, "before" == sticky);
                return null != other && (val.other = getBidi(ch, other, "before" != sticky)), val;
            }
            // Used to cheaply estimate the coordinates for a position. Used for
            // intermediate scroll updates.
            function estimateCoords(cm, pos) {
                var left = 0;
                pos = clipPos(cm.doc, pos), cm.options.lineWrapping || (left = charWidth(cm.display) * pos.ch);
                var lineObj = getLine(cm.doc, pos.line), top = heightAtLine(lineObj) + paddingTop(cm.display);
                return {
                    left: left,
                    right: left,
                    top: top,
                    bottom: top + lineObj.height
                };
            }
            // Positions returned by coordsChar contain some extra information.
            // xRel is the relative x position of the input coordinates compared
            // to the found position (so xRel > 0 means the coordinates are to
            // the right of the character position, for example). When outside
            // is true, that means the coordinates lie outside the line's
            // vertical range.
            function PosWithInfo(line, ch, sticky, outside, xRel) {
                var pos = Pos(line, ch, sticky);
                return pos.xRel = xRel, outside && (pos.outside = !0), pos;
            }
            // Compute the character position closest to the given coordinates.
            // Input must be lineSpace-local ("div" coordinate system).
            function coordsChar(cm, x, y) {
                var doc = cm.doc;
                if (y += cm.display.viewOffset, y < 0) return PosWithInfo(doc.first, 0, null, !0, -1);
                var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
                if (lineN > last) return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, !0, 1);
                x < 0 && (x = 0);
                for (var lineObj = getLine(doc, lineN); ;) {
                    var found = coordsCharInner(cm, lineObj, lineN, x, y), merged = collapsedSpanAtEnd(lineObj), mergedPos = merged && merged.find(0, !0);
                    if (!merged || !(found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0)) return found;
                    lineN = lineNo(lineObj = mergedPos.to.line);
                }
            }
            function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
                y -= widgetTopHeight(lineObj);
                var end = lineObj.text.length, begin = findFirst(function(ch) {
                    return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y;
                }, end, 0);
                return end = findFirst(function(ch) {
                    return measureCharPrepared(cm, preparedMeasure, ch).top > y;
                }, begin, end), {
                    begin: begin,
                    end: end
                };
            }
            function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
                preparedMeasure || (preparedMeasure = prepareMeasureForLine(cm, lineObj));
                var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;
                return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop);
            }
            // Returns true if the given side of a box is after the given
            // coordinates, in top-to-bottom, left-to-right order.
            function boxIsAfter(box, x, y, left) {
                return !(box.bottom <= y) && (box.top > y || (left ? box.left : box.right) > x);
            }
            function coordsCharInner(cm, lineObj, lineNo$$1, x, y) {
                // Move y into line-local coordinate space
                y -= heightAtLine(lineObj);
                var preparedMeasure = prepareMeasureForLine(cm, lineObj), widgetHeight$$1 = widgetTopHeight(lineObj), begin = 0, end = lineObj.text.length, ltr = !0, order = getOrder(lineObj, cm.doc.direction);
                // If the line isn't plain left-to-right text, first figure out
                // which bidi section the coordinates fall into.
                if (order) {
                    var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)(cm, lineObj, lineNo$$1, preparedMeasure, order, x, y);
                    ltr = 1 != part.level, // The awkward -1 offsets are needed because findFirst (called
                    // on these below) will treat its first bound as inclusive,
                    // second as exclusive, but we want to actually address the
                    // characters in the part's range
                    begin = ltr ? part.from : part.to - 1, end = ltr ? part.to : part.from - 1;
                }
                // A binary search to find the first character whose bounding box
                // starts after the coordinates. If we run across any whose box wrap
                // the coordinates, store that.
                var baseX, sticky, chAround = null, boxAround = null, ch = findFirst(function(ch) {
                    var box = measureCharPrepared(cm, preparedMeasure, ch);
                    return box.top += widgetHeight$$1, box.bottom += widgetHeight$$1, !!boxIsAfter(box, x, y, !1) && (box.top <= y && box.left <= x && (chAround = ch, 
                    boxAround = box), !0);
                }, begin, end), outside = !1;
                // If a box around the coordinates was found, use that
                if (boxAround) {
                    // Distinguish coordinates nearer to the left or right side of the box
                    var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;
                    ch = chAround + (atStart ? 0 : 1), sticky = atStart ? "after" : "before", baseX = atLeft ? boxAround.left : boxAround.right;
                } else {
                    // (Adjust for extended bound, if necessary.)
                    ltr || ch != end && ch != begin || ch++, // To determine which side to associate with, get the box to the
                    // left of the character and compare it's vertical position to the
                    // coordinates
                    sticky = 0 == ch ? "after" : ch == lineObj.text.length ? "before" : measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight$$1 <= y == ltr ? "after" : "before";
                    // Now get accurate coordinates for this place, in order to get a
                    // base X position
                    var coords = cursorCoords(cm, Pos(lineNo$$1, ch, sticky), "line", lineObj, preparedMeasure);
                    baseX = coords.left, outside = y < coords.top || y >= coords.bottom;
                }
                return ch = skipExtendingChars(lineObj.text, ch, 1), PosWithInfo(lineNo$$1, ch, sticky, outside, x - baseX);
            }
            function coordsBidiPart(cm, lineObj, lineNo$$1, preparedMeasure, order, x, y) {
                // Bidi parts are sorted left-to-right, and in a non-line-wrapping
                // situation, we can take this ordering to correspond to the visual
                // ordering. This finds the first part whose end is after the given
                // coordinates.
                var index = findFirst(function(i) {
                    var part = order[i], ltr = 1 != part.level;
                    return boxIsAfter(cursorCoords(cm, Pos(lineNo$$1, ltr ? part.to : part.from, ltr ? "before" : "after"), "line", lineObj, preparedMeasure), x, y, !0);
                }, 0, order.length - 1), part = order[index];
                // If this isn't the first part, the part's start is also after
                // the coordinates, and the coordinates aren't on the same line as
                // that start, move one part back.
                if (index > 0) {
                    var ltr = 1 != part.level, start = cursorCoords(cm, Pos(lineNo$$1, ltr ? part.from : part.to, ltr ? "after" : "before"), "line", lineObj, preparedMeasure);
                    boxIsAfter(start, x, y, !0) && start.top > y && (part = order[index - 1]);
                }
                return part;
            }
            function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {
                // In a wrapped line, rtl text on wrapping boundaries can do things
                // that don't correspond to the ordering in our `order` array at
                // all, so a binary search doesn't work, and we want to return a
                // part that only spans one line so that the binary search in
                // coordsCharInner is safe. As such, we first find the extent of the
                // wrapped line, and then do a flat search in which we discard any
                // spans that aren't on the line.
                var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y), begin = ref.begin, end = ref.end;
                /\s/.test(lineObj.text.charAt(end - 1)) && end--;
                for (var part = null, closestDist = null, i = 0; i < order.length; i++) {
                    var p = order[i];
                    if (!(p.from >= end || p.to <= begin)) {
                        var ltr = 1 != p.level, endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right, dist = endX < x ? x - endX + 1e9 : endX - x;
                        (!part || closestDist > dist) && (part = p, closestDist = dist);
                    }
                }
                // Clip the part to the wrapped line.
                return part || (part = order[order.length - 1]), part.from < begin && (part = {
                    from: begin,
                    to: part.to,
                    level: part.level
                }), part.to > end && (part = {
                    from: part.from,
                    to: end,
                    level: part.level
                }), part;
            }
            // Compute the default text height.
            function textHeight(display) {
                if (null != display.cachedTextHeight) return display.cachedTextHeight;
                if (null == measureText) {
                    measureText = elt("pre");
                    // Measure a bunch of lines, for browsers that compute
                    // fractional heights.
                    for (var i = 0; i < 49; ++i) measureText.appendChild(document.createTextNode("x")), 
                    measureText.appendChild(elt("br"));
                    measureText.appendChild(document.createTextNode("x"));
                }
                removeChildrenAndAdd(display.measure, measureText);
                var height = measureText.offsetHeight / 50;
                return height > 3 && (display.cachedTextHeight = height), removeChildren(display.measure), 
                height || 1;
            }
            // Compute the default character width.
            function charWidth(display) {
                if (null != display.cachedCharWidth) return display.cachedCharWidth;
                var anchor = elt("span", "xxxxxxxxxx"), pre = elt("pre", [ anchor ]);
                removeChildrenAndAdd(display.measure, pre);
                var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
                return width > 2 && (display.cachedCharWidth = width), width || 10;
            }
            // Do a bulk-read of the DOM positions and sizes needed to draw the
            // view, so that we don't interleave reading and writing to the DOM.
            function getDimensions(cm) {
                for (var d = cm.display, left = {}, width = {}, gutterLeft = d.gutters.clientLeft, n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, 
                ++i) left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft, width[cm.options.gutters[i]] = n.clientWidth;
                return {
                    fixedPos: compensateForHScroll(d),
                    gutterTotalWidth: d.gutters.offsetWidth,
                    gutterLeft: left,
                    gutterWidth: width,
                    wrapperWidth: d.wrapper.clientWidth
                };
            }
            // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
            // but using getBoundingClientRect to get a sub-pixel-accurate
            // result.
            function compensateForHScroll(display) {
                return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
            }
            // Returns a function that estimates the height of a line, to use as
            // first approximation until the line becomes visible (and is thus
            // properly measurable).
            function estimateHeight(cm) {
                var th = textHeight(cm.display), wrapping = cm.options.lineWrapping, perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
                return function(line) {
                    if (lineIsHidden(cm.doc, line)) return 0;
                    var widgetsHeight = 0;
                    if (line.widgets) for (var i = 0; i < line.widgets.length; i++) line.widgets[i].height && (widgetsHeight += line.widgets[i].height);
                    return wrapping ? widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th : widgetsHeight + th;
                };
            }
            function estimateLineHeights(cm) {
                var doc = cm.doc, est = estimateHeight(cm);
                doc.iter(function(line) {
                    var estHeight = est(line);
                    estHeight != line.height && updateLineHeight(line, estHeight);
                });
            }
            // Given a mouse event, find the corresponding position. If liberal
            // is false, it checks whether a gutter or scrollbar was clicked,
            // and returns null if it was. forRect is used by rectangular
            // selections, and tries to estimate a character position even for
            // coordinates beyond the right of the text.
            function posFromMouse(cm, e, liberal, forRect) {
                var display = cm.display;
                if (!liberal && "true" == e_target(e).getAttribute("cm-not-content")) return null;
                var x, y, space = display.lineSpace.getBoundingClientRect();
                // Fails unpredictably on IE[67] when mouse is dragged around quickly.
                try {
                    x = e.clientX - space.left, y = e.clientY - space.top;
                } catch (e) {
                    return null;
                }
                var line, coords = coordsChar(cm, x, y);
                if (forRect && 1 == coords.xRel && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
                    var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
                    coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
                }
                return coords;
            }
            // Find the view element corresponding to a given line. Return null
            // when the line isn't visible.
            function findViewIndex(cm, n) {
                if (n >= cm.display.viewTo) return null;
                if (n -= cm.display.viewFrom, n < 0) return null;
                for (var view = cm.display.view, i = 0; i < view.length; i++) if (n -= view[i].size, 
                n < 0) return i;
            }
            function updateSelection(cm) {
                cm.display.input.showSelection(cm.display.input.prepareSelection());
            }
            function prepareSelection(cm, primary) {
                void 0 === primary && (primary = !0);
                for (var doc = cm.doc, result = {}, curFragment = result.cursors = document.createDocumentFragment(), selFragment = result.selection = document.createDocumentFragment(), i = 0; i < doc.sel.ranges.length; i++) if (primary || i != doc.sel.primIndex) {
                    var range$$1 = doc.sel.ranges[i];
                    if (!(range$$1.from().line >= cm.display.viewTo || range$$1.to().line < cm.display.viewFrom)) {
                        var collapsed = range$$1.empty();
                        (collapsed || cm.options.showCursorWhenSelecting) && drawSelectionCursor(cm, range$$1.head, curFragment), 
                        collapsed || drawSelectionRange(cm, range$$1, selFragment);
                    }
                }
                return result;
            }
            // Draws a cursor for the given range
            function drawSelectionCursor(cm, head, output) {
                var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine), cursor = output.appendChild(elt("div", " ", "CodeMirror-cursor"));
                if (cursor.style.left = pos.left + "px", cursor.style.top = pos.top + "px", cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px", 
                pos.other) {
                    // Secondary cursor, shown when on a 'jump' in bi-directional text
                    var otherCursor = output.appendChild(elt("div", " ", "CodeMirror-cursor CodeMirror-secondarycursor"));
                    otherCursor.style.display = "", otherCursor.style.left = pos.other.left + "px", 
                    otherCursor.style.top = pos.other.top + "px", otherCursor.style.height = .85 * (pos.other.bottom - pos.other.top) + "px";
                }
            }
            function cmpCoords(a, b) {
                return a.top - b.top || a.left - b.left;
            }
            // Draws the given range as a highlighted selection
            function drawSelectionRange(cm, range$$1, output) {
                function add(left, top, width, bottom) {
                    top < 0 && (top = 0), top = Math.round(top), bottom = Math.round(bottom), fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left + "px;\n                             top: " + top + "px; width: " + (null == width ? rightSide - left : width) + "px;\n                             height: " + (bottom - top) + "px"));
                }
                function drawForLine(line, fromArg, toArg) {
                    function coords(ch, bias) {
                        return charCoords(cm, Pos(line, ch), "div", lineObj, bias);
                    }
                    function wrapX(pos, dir, side) {
                        var extent = wrappedLineExtentChar(cm, lineObj, null, pos), prop = "ltr" == dir == ("after" == side) ? "left" : "right", ch = "after" == side ? extent.begin : extent.end - (/\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);
                        return coords(ch, prop)[prop];
                    }
                    var start, end, lineObj = getLine(doc, line), lineLen = lineObj.text.length, order = getOrder(lineObj, doc.direction);
                    return iterateBidiSections(order, fromArg || 0, null == toArg ? lineLen : toArg, function(from, to, dir, i) {
                        var ltr = "ltr" == dir, fromPos = coords(from, ltr ? "left" : "right"), toPos = coords(to - 1, ltr ? "right" : "left"), openStart = null == fromArg && 0 == from, openEnd = null == toArg && to == lineLen, first = 0 == i, last = !order || i == order.length - 1;
                        if (toPos.top - fromPos.top <= 3) {
                            // Single line
                            var openLeft = (docLTR ? openStart : openEnd) && first, openRight = (docLTR ? openEnd : openStart) && last, left = openLeft ? leftSide : (ltr ? fromPos : toPos).left, right = openRight ? rightSide : (ltr ? toPos : fromPos).right;
                            add(left, fromPos.top, right - left, fromPos.bottom);
                        } else {
                            // Multiple lines
                            var topLeft, topRight, botLeft, botRight;
                            ltr ? (topLeft = docLTR && openStart && first ? leftSide : fromPos.left, topRight = docLTR ? rightSide : wrapX(from, dir, "before"), 
                            botLeft = docLTR ? leftSide : wrapX(to, dir, "after"), botRight = docLTR && openEnd && last ? rightSide : toPos.right) : (topLeft = docLTR ? wrapX(from, dir, "before") : leftSide, 
                            topRight = !docLTR && openStart && first ? rightSide : fromPos.right, botLeft = !docLTR && openEnd && last ? leftSide : toPos.left, 
                            botRight = docLTR ? wrapX(to, dir, "after") : rightSide), add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom), 
                            fromPos.bottom < toPos.top && add(leftSide, fromPos.bottom, null, toPos.top), add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);
                        }
                        (!start || cmpCoords(fromPos, start) < 0) && (start = fromPos), cmpCoords(toPos, start) < 0 && (start = toPos), 
                        (!end || cmpCoords(fromPos, end) < 0) && (end = fromPos), cmpCoords(toPos, end) < 0 && (end = toPos);
                    }), {
                        start: start,
                        end: end
                    };
                }
                var display = cm.display, doc = cm.doc, fragment = document.createDocumentFragment(), padding = paddingH(cm.display), leftSide = padding.left, rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right, docLTR = "ltr" == doc.direction, sFrom = range$$1.from(), sTo = range$$1.to();
                if (sFrom.line == sTo.line) drawForLine(sFrom.line, sFrom.ch, sTo.ch); else {
                    var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line), singleVLine = visualLine(fromLine) == visualLine(toLine), leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end, rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
                    singleVLine && (leftEnd.top < rightStart.top - 2 ? (add(leftEnd.right, leftEnd.top, null, leftEnd.bottom), 
                    add(leftSide, rightStart.top, rightStart.left, rightStart.bottom)) : add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom)), 
                    leftEnd.bottom < rightStart.top && add(leftSide, leftEnd.bottom, null, rightStart.top);
                }
                output.appendChild(fragment);
            }
            // Cursor-blinking
            function restartBlink(cm) {
                if (cm.state.focused) {
                    var display = cm.display;
                    clearInterval(display.blinker);
                    var on = !0;
                    display.cursorDiv.style.visibility = "", cm.options.cursorBlinkRate > 0 ? display.blinker = setInterval(function() {
                        return display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden";
                    }, cm.options.cursorBlinkRate) : cm.options.cursorBlinkRate < 0 && (display.cursorDiv.style.visibility = "hidden");
                }
            }
            function ensureFocus(cm) {
                cm.state.focused || (cm.display.input.focus(), onFocus(cm));
            }
            function delayBlurEvent(cm) {
                cm.state.delayingBlurEvent = !0, setTimeout(function() {
                    cm.state.delayingBlurEvent && (cm.state.delayingBlurEvent = !1, onBlur(cm));
                }, 100);
            }
            function onFocus(cm, e) {
                cm.state.delayingBlurEvent && (cm.state.delayingBlurEvent = !1), "nocursor" != cm.options.readOnly && (cm.state.focused || (signal(cm, "focus", cm, e), 
                cm.state.focused = !0, addClass(cm.display.wrapper, "CodeMirror-focused"), // This test prevents this from firing when a context
                // menu is closed (since the input reset would kill the
                // select-all detection hack)
                cm.curOp || cm.display.selForContextMenu == cm.doc.sel || (cm.display.input.reset(), 
                webkit && setTimeout(function() {
                    return cm.display.input.reset(!0);
                }, 20)), cm.display.input.receivedFocus()), restartBlink(cm));
            }
            function onBlur(cm, e) {
                cm.state.delayingBlurEvent || (cm.state.focused && (signal(cm, "blur", cm, e), cm.state.focused = !1, 
                rmClass(cm.display.wrapper, "CodeMirror-focused")), clearInterval(cm.display.blinker), 
                setTimeout(function() {
                    cm.state.focused || (cm.display.shift = !1);
                }, 150));
            }
            // Read the actual heights of the rendered lines, and update their
            // stored heights to match.
            function updateHeightsInViewport(cm) {
                for (var display = cm.display, prevBottom = display.lineDiv.offsetTop, i = 0; i < display.view.length; i++) {
                    var cur = display.view[i], height = void 0;
                    if (!cur.hidden) {
                        if (ie && ie_version < 8) {
                            var bot = cur.node.offsetTop + cur.node.offsetHeight;
                            height = bot - prevBottom, prevBottom = bot;
                        } else {
                            var box = cur.node.getBoundingClientRect();
                            height = box.bottom - box.top;
                        }
                        var diff = cur.line.height - height;
                        if (height < 2 && (height = textHeight(display)), (diff > .005 || diff < -.005) && (updateLineHeight(cur.line, height), 
                        updateWidgetHeight(cur.line), cur.rest)) for (var j = 0; j < cur.rest.length; j++) updateWidgetHeight(cur.rest[j]);
                    }
                }
            }
            // Read and store the height of line widgets associated with the
            // given line.
            function updateWidgetHeight(line) {
                if (line.widgets) for (var i = 0; i < line.widgets.length; ++i) line.widgets[i].height = line.widgets[i].node.parentNode.offsetHeight;
            }
            // Compute the lines that are visible in a given viewport (defaults
            // the the current scroll position). viewport may contain top,
            // height, and ensure (see op.scrollToPos) properties.
            function visibleLines(display, doc, viewport) {
                var top = viewport && null != viewport.top ? Math.max(0, viewport.top) : display.scroller.scrollTop;
                top = Math.floor(top - paddingTop(display));
                var bottom = viewport && null != viewport.bottom ? viewport.bottom : top + display.wrapper.clientHeight, from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);
                // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
                // forces those lines into the viewport (if possible).
                if (viewport && viewport.ensure) {
                    var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
                    ensureFrom < from ? (from = ensureFrom, to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight)) : Math.min(ensureTo, doc.lastLine()) >= to && (from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight), 
                    to = ensureTo);
                }
                return {
                    from: from,
                    to: Math.max(to, from + 1)
                };
            }
            // Re-align line numbers and gutter marks to compensate for
            // horizontal scrolling.
            function alignHorizontally(cm) {
                var display = cm.display, view = display.view;
                if (display.alignWidgets || display.gutters.firstChild && cm.options.fixedGutter) {
                    for (var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft, gutterW = display.gutters.offsetWidth, left = comp + "px", i = 0; i < view.length; i++) if (!view[i].hidden) {
                        cm.options.fixedGutter && (view[i].gutter && (view[i].gutter.style.left = left), 
                        view[i].gutterBackground && (view[i].gutterBackground.style.left = left));
                        var align = view[i].alignable;
                        if (align) for (var j = 0; j < align.length; j++) align[j].style.left = left;
                    }
                    cm.options.fixedGutter && (display.gutters.style.left = comp + gutterW + "px");
                }
            }
            // Used to ensure that the line number gutter is still the right
            // size for the current document size. Returns true when an update
            // is needed.
            function maybeUpdateLineNumberWidth(cm) {
                if (!cm.options.lineNumbers) return !1;
                var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
                if (last.length != display.lineNumChars) {
                    var test = display.measure.appendChild(elt("div", [ elt("div", last) ], "CodeMirror-linenumber CodeMirror-gutter-elt")), innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
                    return display.lineGutter.style.width = "", display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1, 
                    display.lineNumWidth = display.lineNumInnerWidth + padding, display.lineNumChars = display.lineNumInnerWidth ? last.length : -1, 
                    display.lineGutter.style.width = display.lineNumWidth + "px", updateGutterSpace(cm), 
                    !0;
                }
                return !1;
            }
            // SCROLLING THINGS INTO VIEW
            // If an editor sits on the top or bottom of the window, partially
            // scrolled out of view, this ensures that the cursor is visible.
            function maybeScrollWindow(cm, rect) {
                if (!signalDOMEvent(cm, "scrollCursorIntoView")) {
                    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
                    if (rect.top + box.top < 0 ? doScroll = !0 : rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight) && (doScroll = !1), 
                    null != doScroll && !phantom) {
                        var scrollNode = elt("div", "​", null, "position: absolute;\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + rect.left + "px; width: " + Math.max(2, rect.right - rect.left) + "px;");
                        cm.display.lineSpace.appendChild(scrollNode), scrollNode.scrollIntoView(doScroll), 
                        cm.display.lineSpace.removeChild(scrollNode);
                    }
                }
            }
            // Scroll a given position into view (immediately), verifying that
            // it actually became visible (as line heights are accurately
            // measured, the position of something may 'drift' during drawing).
            function scrollPosIntoView(cm, pos, end, margin) {
                null == margin && (margin = 0);
                var rect;
                cm.options.lineWrapping || pos != end || (// Set pos and end to the cursor positions around the character pos sticks to
                // If pos.sticky == "before", that is around pos.ch - 1, otherwise around pos.ch
                // If pos == Pos(_, 0, "before"), pos and end are unchanged
                pos = pos.ch ? Pos(pos.line, "before" == pos.sticky ? pos.ch - 1 : pos.ch, "after") : pos, 
                end = "before" == pos.sticky ? Pos(pos.line, pos.ch + 1, "before") : pos);
                for (var limit = 0; limit < 5; limit++) {
                    var changed = !1, coords = cursorCoords(cm, pos), endCoords = end && end != pos ? cursorCoords(cm, end) : coords;
                    rect = {
                        left: Math.min(coords.left, endCoords.left),
                        top: Math.min(coords.top, endCoords.top) - margin,
                        right: Math.max(coords.left, endCoords.left),
                        bottom: Math.max(coords.bottom, endCoords.bottom) + margin
                    };
                    var scrollPos = calculateScrollPos(cm, rect), startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
                    if (null != scrollPos.scrollTop && (updateScrollTop(cm, scrollPos.scrollTop), Math.abs(cm.doc.scrollTop - startTop) > 1 && (changed = !0)), 
                    null != scrollPos.scrollLeft && (setScrollLeft(cm, scrollPos.scrollLeft), Math.abs(cm.doc.scrollLeft - startLeft) > 1 && (changed = !0)), 
                    !changed) break;
                }
                return rect;
            }
            // Scroll a given set of coordinates into view (immediately).
            function scrollIntoView(cm, rect) {
                var scrollPos = calculateScrollPos(cm, rect);
                null != scrollPos.scrollTop && updateScrollTop(cm, scrollPos.scrollTop), null != scrollPos.scrollLeft && setScrollLeft(cm, scrollPos.scrollLeft);
            }
            // Calculate a new scroll position needed to scroll the given
            // rectangle into view. Returns an object with scrollTop and
            // scrollLeft properties. When these are undefined, the
            // vertical/horizontal position does not need to be adjusted.
            function calculateScrollPos(cm, rect) {
                var display = cm.display, snapMargin = textHeight(cm.display);
                rect.top < 0 && (rect.top = 0);
                var screentop = cm.curOp && null != cm.curOp.scrollTop ? cm.curOp.scrollTop : display.scroller.scrollTop, screen = displayHeight(cm), result = {};
                rect.bottom - rect.top > screen && (rect.bottom = rect.top + screen);
                var docBottom = cm.doc.height + paddingVert(display), atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;
                if (rect.top < screentop) result.scrollTop = atTop ? 0 : rect.top; else if (rect.bottom > screentop + screen) {
                    var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);
                    newTop != screentop && (result.scrollTop = newTop);
                }
                var screenleft = cm.curOp && null != cm.curOp.scrollLeft ? cm.curOp.scrollLeft : display.scroller.scrollLeft, screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0), tooWide = rect.right - rect.left > screenw;
                return tooWide && (rect.right = rect.left + screenw), rect.left < 10 ? result.scrollLeft = 0 : rect.left < screenleft ? result.scrollLeft = Math.max(0, rect.left - (tooWide ? 0 : 10)) : rect.right > screenw + screenleft - 3 && (result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw), 
                result;
            }
            // Store a relative adjustment to the scroll position in the current
            // operation (to be applied when the operation finishes).
            function addToScrollTop(cm, top) {
                null != top && (resolveScrollToPos(cm), cm.curOp.scrollTop = (null == cm.curOp.scrollTop ? cm.doc.scrollTop : cm.curOp.scrollTop) + top);
            }
            // Make sure that at the end of the operation the current cursor is
            // shown.
            function ensureCursorVisible(cm) {
                resolveScrollToPos(cm);
                var cur = cm.getCursor();
                cm.curOp.scrollToPos = {
                    from: cur,
                    to: cur,
                    margin: cm.options.cursorScrollMargin
                };
            }
            function scrollToCoords(cm, x, y) {
                null == x && null == y || resolveScrollToPos(cm), null != x && (cm.curOp.scrollLeft = x), 
                null != y && (cm.curOp.scrollTop = y);
            }
            function scrollToRange(cm, range$$1) {
                resolveScrollToPos(cm), cm.curOp.scrollToPos = range$$1;
            }
            // When an operation has its scrollToPos property set, and another
            // scroll action is applied before the end of the operation, this
            // 'simulates' scrolling that position into view in a cheap way, so
            // that the effect of intermediate scroll commands is not ignored.
            function resolveScrollToPos(cm) {
                var range$$1 = cm.curOp.scrollToPos;
                if (range$$1) {
                    cm.curOp.scrollToPos = null;
                    var from = estimateCoords(cm, range$$1.from), to = estimateCoords(cm, range$$1.to);
                    scrollToCoordsRange(cm, from, to, range$$1.margin);
                }
            }
            function scrollToCoordsRange(cm, from, to, margin) {
                var sPos = calculateScrollPos(cm, {
                    left: Math.min(from.left, to.left),
                    top: Math.min(from.top, to.top) - margin,
                    right: Math.max(from.right, to.right),
                    bottom: Math.max(from.bottom, to.bottom) + margin
                });
                scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);
            }
            // Sync the scrollable area and scrollbars, ensure the viewport
            // covers the visible area.
            function updateScrollTop(cm, val) {
                Math.abs(cm.doc.scrollTop - val) < 2 || (gecko || updateDisplaySimple(cm, {
                    top: val
                }), setScrollTop(cm, val, !0), gecko && updateDisplaySimple(cm), startWorker(cm, 100));
            }
            function setScrollTop(cm, val, forceScroll) {
                val = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val), 
                (cm.display.scroller.scrollTop != val || forceScroll) && (cm.doc.scrollTop = val, 
                cm.display.scrollbars.setScrollTop(val), cm.display.scroller.scrollTop != val && (cm.display.scroller.scrollTop = val));
            }
            // Sync scroller and scrollbar, ensure the gutter elements are
            // aligned.
            function setScrollLeft(cm, val, isScroller, forceScroll) {
                val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth), 
                (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll || (cm.doc.scrollLeft = val, 
                alignHorizontally(cm), cm.display.scroller.scrollLeft != val && (cm.display.scroller.scrollLeft = val), 
                cm.display.scrollbars.setScrollLeft(val));
            }
            // SCROLLBARS
            // Prepare DOM reads needed to update the scrollbars. Done in one
            // shot to minimize update/measure roundtrips.
            function measureForScrollbars(cm) {
                var d = cm.display, gutterW = d.gutters.offsetWidth, docH = Math.round(cm.doc.height + paddingVert(cm.display));
                return {
                    clientHeight: d.scroller.clientHeight,
                    viewHeight: d.wrapper.clientHeight,
                    scrollWidth: d.scroller.scrollWidth,
                    clientWidth: d.scroller.clientWidth,
                    viewWidth: d.wrapper.clientWidth,
                    barLeft: cm.options.fixedGutter ? gutterW : 0,
                    docHeight: docH,
                    scrollHeight: docH + scrollGap(cm) + d.barHeight,
                    nativeBarWidth: d.nativeBarWidth,
                    gutterWidth: gutterW
                };
            }
            function updateScrollbars(cm, measure) {
                measure || (measure = measureForScrollbars(cm));
                var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
                updateScrollbarsInner(cm, measure);
                for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) startWidth != cm.display.barWidth && cm.options.lineWrapping && updateHeightsInViewport(cm), 
                updateScrollbarsInner(cm, measureForScrollbars(cm)), startWidth = cm.display.barWidth, 
                startHeight = cm.display.barHeight;
            }
            // Re-synchronize the fake scrollbars with the actual size of the
            // content.
            function updateScrollbarsInner(cm, measure) {
                var d = cm.display, sizes = d.scrollbars.update(measure);
                d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px", d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px", 
                d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent", sizes.right && sizes.bottom ? (d.scrollbarFiller.style.display = "block", 
                d.scrollbarFiller.style.height = sizes.bottom + "px", d.scrollbarFiller.style.width = sizes.right + "px") : d.scrollbarFiller.style.display = "", 
                sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter ? (d.gutterFiller.style.display = "block", 
                d.gutterFiller.style.height = sizes.bottom + "px", d.gutterFiller.style.width = measure.gutterWidth + "px") : d.gutterFiller.style.display = "";
            }
            function initScrollbars(cm) {
                cm.display.scrollbars && (cm.display.scrollbars.clear(), cm.display.scrollbars.addClass && rmClass(cm.display.wrapper, cm.display.scrollbars.addClass)), 
                cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function(node) {
                    cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller), // Prevent clicks in the scrollbars from killing focus
                    on(node, "mousedown", function() {
                        cm.state.focused && setTimeout(function() {
                            return cm.display.input.focus();
                        }, 0);
                    }), node.setAttribute("cm-not-content", "true");
                }, function(pos, axis) {
                    "horizontal" == axis ? setScrollLeft(cm, pos) : updateScrollTop(cm, pos);
                }, cm), cm.display.scrollbars.addClass && addClass(cm.display.wrapper, cm.display.scrollbars.addClass);
            }
            // Start a new operation.
            function startOperation(cm) {
                cm.curOp = {
                    cm: cm,
                    viewChanged: !1,
                    // Flag that indicates that lines might need to be redrawn
                    startHeight: cm.doc.height,
                    // Used to detect need to update scrollbar
                    forceUpdate: !1,
                    // Used to force a redraw
                    updateInput: null,
                    // Whether to reset the input textarea
                    typing: !1,
                    // Whether this reset should be careful to leave existing text (for compositing)
                    changeObjs: null,
                    // Accumulated changes, for firing change events
                    cursorActivityHandlers: null,
                    // Set of handlers to fire cursorActivity on
                    cursorActivityCalled: 0,
                    // Tracks which cursorActivity handlers have been called already
                    selectionChanged: !1,
                    // Whether the selection needs to be redrawn
                    updateMaxLine: !1,
                    // Set when the widest line needs to be determined anew
                    scrollLeft: null,
                    scrollTop: null,
                    // Intermediate scroll position, not pushed to DOM yet
                    scrollToPos: null,
                    // Used to scroll to a specific position
                    focus: !1,
                    id: ++nextOpId
                }, pushOperation(cm.curOp);
            }
            // Finish an operation, updating the display and signalling delayed events
            function endOperation(cm) {
                var op = cm.curOp;
                finishOperation(op, function(group) {
                    for (var i = 0; i < group.ops.length; i++) group.ops[i].cm.curOp = null;
                    endOperations(group);
                });
            }
            // The DOM updates done when an operation finishes are batched so
            // that the minimum number of relayouts are required.
            function endOperations(group) {
                for (var ops = group.ops, i = 0; i < ops.length; i++) endOperation_R1(ops[i]);
                for (var i$1 = 0; i$1 < ops.length; i$1++) endOperation_W1(ops[i$1]);
                for (var i$2 = 0; i$2 < ops.length; i$2++) endOperation_R2(ops[i$2]);
                for (var i$3 = 0; i$3 < ops.length; i$3++) endOperation_W2(ops[i$3]);
                for (var i$4 = 0; i$4 < ops.length; i$4++) endOperation_finish(ops[i$4]);
            }
            function endOperation_R1(op) {
                var cm = op.cm, display = cm.display;
                maybeClipScrollbars(cm), op.updateMaxLine && findMaxLine(cm), op.mustUpdate = op.viewChanged || op.forceUpdate || null != op.scrollTop || op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom || op.scrollToPos.to.line >= display.viewTo) || display.maxLineChanged && cm.options.lineWrapping, 
                op.update = op.mustUpdate && new DisplayUpdate(cm, op.mustUpdate && {
                    top: op.scrollTop,
                    ensure: op.scrollToPos
                }, op.forceUpdate);
            }
            function endOperation_W1(op) {
                op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
            }
            function endOperation_R2(op) {
                var cm = op.cm, display = cm.display;
                op.updatedDisplay && updateHeightsInViewport(cm), op.barMeasure = measureForScrollbars(cm), 
                // If the max line changed since it was last measured, measure it,
                // and ensure the document's width matches it.
                // updateDisplay_W2 will use these properties to do the actual resizing
                display.maxLineChanged && !cm.options.lineWrapping && (op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3, 
                cm.display.sizerWidth = op.adjustWidthTo, op.barMeasure.scrollWidth = Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth), 
                op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm))), 
                (op.updatedDisplay || op.selectionChanged) && (op.preparedSelection = display.input.prepareSelection());
            }
            function endOperation_W2(op) {
                var cm = op.cm;
                null != op.adjustWidthTo && (cm.display.sizer.style.minWidth = op.adjustWidthTo + "px", 
                op.maxScrollLeft < cm.doc.scrollLeft && setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), !0), 
                cm.display.maxLineChanged = !1);
                var takeFocus = op.focus && op.focus == activeElt();
                op.preparedSelection && cm.display.input.showSelection(op.preparedSelection, takeFocus), 
                (op.updatedDisplay || op.startHeight != cm.doc.height) && updateScrollbars(cm, op.barMeasure), 
                op.updatedDisplay && setDocumentHeight(cm, op.barMeasure), op.selectionChanged && restartBlink(cm), 
                cm.state.focused && op.updateInput && cm.display.input.reset(op.typing), takeFocus && ensureFocus(op.cm);
            }
            function endOperation_finish(op) {
                var cm = op.cm, display = cm.display, doc = cm.doc;
                // If we need to scroll a specific position into view, do so.
                if (op.updatedDisplay && postUpdateDisplay(cm, op.update), // Abort mouse wheel delta measurement, when scrolling explicitly
                null == display.wheelStartX || null == op.scrollTop && null == op.scrollLeft && !op.scrollToPos || (display.wheelStartX = display.wheelStartY = null), 
                // Propagate the scroll position to the actual DOM scroller
                null != op.scrollTop && setScrollTop(cm, op.scrollTop, op.forceScroll), null != op.scrollLeft && setScrollLeft(cm, op.scrollLeft, !0, !0), 
                op.scrollToPos) {
                    var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from), clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
                    maybeScrollWindow(cm, rect);
                }
                // Fire events for markers that are hidden/unidden by editing or
                // undoing
                var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
                if (hidden) for (var i = 0; i < hidden.length; ++i) hidden[i].lines.length || signal(hidden[i], "hide");
                if (unhidden) for (var i$1 = 0; i$1 < unhidden.length; ++i$1) unhidden[i$1].lines.length && signal(unhidden[i$1], "unhide");
                display.wrapper.offsetHeight && (doc.scrollTop = cm.display.scroller.scrollTop), 
                // Fire change events, and delayed event handlers
                op.changeObjs && signal(cm, "changes", cm, op.changeObjs), op.update && op.update.finish();
            }
            // Run the given function in an operation
            function runInOp(cm, f) {
                if (cm.curOp) return f();
                startOperation(cm);
                try {
                    return f();
                } finally {
                    endOperation(cm);
                }
            }
            // Wraps a function in an operation. Returns the wrapped function.
            function operation(cm, f) {
                return function() {
                    if (cm.curOp) return f.apply(cm, arguments);
                    startOperation(cm);
                    try {
                        return f.apply(cm, arguments);
                    } finally {
                        endOperation(cm);
                    }
                };
            }
            // Used to add methods to editor and doc instances, wrapping them in
            // operations.
            function methodOp(f) {
                return function() {
                    if (this.curOp) return f.apply(this, arguments);
                    startOperation(this);
                    try {
                        return f.apply(this, arguments);
                    } finally {
                        endOperation(this);
                    }
                };
            }
            function docMethodOp(f) {
                return function() {
                    var cm = this.cm;
                    if (!cm || cm.curOp) return f.apply(this, arguments);
                    startOperation(cm);
                    try {
                        return f.apply(this, arguments);
                    } finally {
                        endOperation(cm);
                    }
                };
            }
            // Updates the display.view data structure for a given change to the
            // document. From and to are in pre-change coordinates. Lendiff is
            // the amount of lines added or subtracted by the change. This is
            // used for changes that span multiple lines, or change the way
            // lines are divided into visual lines. regLineChange (below)
            // registers single-line changes.
            function regChange(cm, from, to, lendiff) {
                null == from && (from = cm.doc.first), null == to && (to = cm.doc.first + cm.doc.size), 
                lendiff || (lendiff = 0);
                var display = cm.display;
                if (lendiff && to < display.viewTo && (null == display.updateLineNumbers || display.updateLineNumbers > from) && (display.updateLineNumbers = from), 
                cm.curOp.viewChanged = !0, from >= display.viewTo) // Change after
                sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo && resetView(cm); else if (to <= display.viewFrom) // Change before
                sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom ? resetView(cm) : (display.viewFrom += lendiff, 
                display.viewTo += lendiff); else if (from <= display.viewFrom && to >= display.viewTo) // Full overlap
                resetView(cm); else if (from <= display.viewFrom) {
                    // Top overlap
                    var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
                    cut ? (display.view = display.view.slice(cut.index), display.viewFrom = cut.lineN, 
                    display.viewTo += lendiff) : resetView(cm);
                } else if (to >= display.viewTo) {
                    // Bottom overlap
                    var cut$1 = viewCuttingPoint(cm, from, from, -1);
                    cut$1 ? (display.view = display.view.slice(0, cut$1.index), display.viewTo = cut$1.lineN) : resetView(cm);
                } else {
                    // Gap in the middle
                    var cutTop = viewCuttingPoint(cm, from, from, -1), cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
                    cutTop && cutBot ? (display.view = display.view.slice(0, cutTop.index).concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN)).concat(display.view.slice(cutBot.index)), 
                    display.viewTo += lendiff) : resetView(cm);
                }
                var ext = display.externalMeasured;
                ext && (to < ext.lineN ? ext.lineN += lendiff : from < ext.lineN + ext.size && (display.externalMeasured = null));
            }
            // Register a change to a single line. Type must be one of "text",
            // "gutter", "class", "widget"
            function regLineChange(cm, line, type) {
                cm.curOp.viewChanged = !0;
                var display = cm.display, ext = cm.display.externalMeasured;
                if (ext && line >= ext.lineN && line < ext.lineN + ext.size && (display.externalMeasured = null), 
                !(line < display.viewFrom || line >= display.viewTo)) {
                    var lineView = display.view[findViewIndex(cm, line)];
                    if (null != lineView.node) {
                        var arr = lineView.changes || (lineView.changes = []);
                        indexOf(arr, type) == -1 && arr.push(type);
                    }
                }
            }
            // Clear the view.
            function resetView(cm) {
                cm.display.viewFrom = cm.display.viewTo = cm.doc.first, cm.display.view = [], cm.display.viewOffset = 0;
            }
            function viewCuttingPoint(cm, oldN, newN, dir) {
                var diff, index = findViewIndex(cm, oldN), view = cm.display.view;
                if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size) return {
                    index: index,
                    lineN: newN
                };
                for (var n = cm.display.viewFrom, i = 0; i < index; i++) n += view[i].size;
                if (n != oldN) {
                    if (dir > 0) {
                        if (index == view.length - 1) return null;
                        diff = n + view[index].size - oldN, index++;
                    } else diff = n - oldN;
                    oldN += diff, newN += diff;
                }
                for (;visualLineNo(cm.doc, newN) != newN; ) {
                    if (index == (dir < 0 ? 0 : view.length - 1)) return null;
                    newN += dir * view[index - (dir < 0 ? 1 : 0)].size, index += dir;
                }
                return {
                    index: index,
                    lineN: newN
                };
            }
            // Force the view to cover a given range, adding empty view element
            // or clipping off existing ones as needed.
            function adjustView(cm, from, to) {
                var display = cm.display, view = display.view;
                0 == view.length || from >= display.viewTo || to <= display.viewFrom ? (display.view = buildViewArray(cm, from, to), 
                display.viewFrom = from) : (display.viewFrom > from ? display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view) : display.viewFrom < from && (display.view = display.view.slice(findViewIndex(cm, from))), 
                display.viewFrom = from, display.viewTo < to ? display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)) : display.viewTo > to && (display.view = display.view.slice(0, findViewIndex(cm, to)))), 
                display.viewTo = to;
            }
            // Count the number of lines in the view whose DOM representation is
            // out of date (or nonexistent).
            function countDirtyView(cm) {
                for (var view = cm.display.view, dirty = 0, i = 0; i < view.length; i++) {
                    var lineView = view[i];
                    lineView.hidden || lineView.node && !lineView.changes || ++dirty;
                }
                return dirty;
            }
            // HIGHLIGHT WORKER
            function startWorker(cm, time) {
                cm.doc.highlightFrontier < cm.display.viewTo && cm.state.highlight.set(time, bind(highlightWorker, cm));
            }
            function highlightWorker(cm) {
                var doc = cm.doc;
                if (!(doc.highlightFrontier >= cm.display.viewTo)) {
                    var end = +new Date() + cm.options.workTime, context = getContextBefore(cm, doc.highlightFrontier), changedLines = [];
                    doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {
                        if (context.line >= cm.display.viewFrom) {
                            // Visible
                            var oldStyles = line.styles, resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null, highlighted = highlightLine(cm, line, context, !0);
                            resetState && (context.state = resetState), line.styles = highlighted.styles;
                            var oldCls = line.styleClasses, newCls = highlighted.classes;
                            newCls ? line.styleClasses = newCls : oldCls && (line.styleClasses = null);
                            for (var ischange = !oldStyles || oldStyles.length != line.styles.length || oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass), i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];
                            ischange && changedLines.push(context.line), line.stateAfter = context.save(), context.nextLine();
                        } else line.text.length <= cm.options.maxHighlightLength && processLine(cm, line.text, context), 
                        line.stateAfter = context.line % 5 == 0 ? context.save() : null, context.nextLine();
                        if (+new Date() > end) return startWorker(cm, cm.options.workDelay), !0;
                    }), doc.highlightFrontier = context.line, doc.modeFrontier = Math.max(doc.modeFrontier, context.line), 
                    changedLines.length && runInOp(cm, function() {
                        for (var i = 0; i < changedLines.length; i++) regLineChange(cm, changedLines[i], "text");
                    });
                }
            }
            function maybeClipScrollbars(cm) {
                var display = cm.display;
                !display.scrollbarsClipped && display.scroller.offsetWidth && (display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth, 
                display.heightForcer.style.height = scrollGap(cm) + "px", display.sizer.style.marginBottom = -display.nativeBarWidth + "px", 
                display.sizer.style.borderRightWidth = scrollGap(cm) + "px", display.scrollbarsClipped = !0);
            }
            function selectionSnapshot(cm) {
                if (cm.hasFocus()) return null;
                var active = activeElt();
                if (!active || !contains(cm.display.lineDiv, active)) return null;
                var result = {
                    activeElt: active
                };
                if (window.getSelection) {
                    var sel = window.getSelection();
                    sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode) && (result.anchorNode = sel.anchorNode, 
                    result.anchorOffset = sel.anchorOffset, result.focusNode = sel.focusNode, result.focusOffset = sel.focusOffset);
                }
                return result;
            }
            function restoreSelection(snapshot) {
                if (snapshot && snapshot.activeElt && snapshot.activeElt != activeElt() && (snapshot.activeElt.focus(), 
                snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode))) {
                    var sel = window.getSelection(), range$$1 = document.createRange();
                    range$$1.setEnd(snapshot.anchorNode, snapshot.anchorOffset), range$$1.collapse(!1), 
                    sel.removeAllRanges(), sel.addRange(range$$1), sel.extend(snapshot.focusNode, snapshot.focusOffset);
                }
            }
            // Does the actual updating of the line display. Bails out
            // (returning false) when there is nothing to be done and forced is
            // false.
            function updateDisplayIfNeeded(cm, update) {
                var display = cm.display, doc = cm.doc;
                if (update.editorIsHidden) return resetView(cm), !1;
                // Bail out if the visible area is already rendered and nothing changed.
                if (!update.force && update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo && (null == display.updateLineNumbers || display.updateLineNumbers >= display.viewTo) && display.renderedView == display.view && 0 == countDirtyView(cm)) return !1;
                maybeUpdateLineNumberWidth(cm) && (resetView(cm), update.dims = getDimensions(cm));
                // Compute a suitable new viewport (from & to)
                var end = doc.first + doc.size, from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first), to = Math.min(end, update.visible.to + cm.options.viewportMargin);
                display.viewFrom < from && from - display.viewFrom < 20 && (from = Math.max(doc.first, display.viewFrom)), 
                display.viewTo > to && display.viewTo - to < 20 && (to = Math.min(end, display.viewTo)), 
                sawCollapsedSpans && (from = visualLineNo(cm.doc, from), to = visualLineEndNo(cm.doc, to));
                var different = from != display.viewFrom || to != display.viewTo || display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
                adjustView(cm, from, to), display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom)), 
                // Position the mover div to align with the current scroll position
                cm.display.mover.style.top = display.viewOffset + "px";
                var toUpdate = countDirtyView(cm);
                if (!different && 0 == toUpdate && !update.force && display.renderedView == display.view && (null == display.updateLineNumbers || display.updateLineNumbers >= display.viewTo)) return !1;
                // For big changes, we hide the enclosing element during the
                // update, since that speeds up the operations on most browsers.
                var selSnapshot = selectionSnapshot(cm);
                // There might have been a widget with a focused element that got
                // hidden or updated, if so re-focus it.
                // Prevent selection and cursors from interfering with the scroll
                // width and height.
                return toUpdate > 4 && (display.lineDiv.style.display = "none"), patchDisplay(cm, display.updateLineNumbers, update.dims), 
                toUpdate > 4 && (display.lineDiv.style.display = ""), display.renderedView = display.view, 
                restoreSelection(selSnapshot), removeChildren(display.cursorDiv), removeChildren(display.selectionDiv), 
                display.gutters.style.height = display.sizer.style.minHeight = 0, different && (display.lastWrapHeight = update.wrapperHeight, 
                display.lastWrapWidth = update.wrapperWidth, startWorker(cm, 400)), display.updateLineNumbers = null, 
                !0;
            }
            function postUpdateDisplay(cm, update) {
                for (var viewport = update.viewport, first = !0; (first && cm.options.lineWrapping && update.oldDisplayWidth != displayWidth(cm) || (// Clip forced viewport to actual scrollable area.
                viewport && null != viewport.top && (viewport = {
                    top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)
                }), // Updated line heights might result in the drawn area not
                // actually covering the viewport. Keep looping until it does.
                update.visible = visibleLines(cm.display, cm.doc, viewport), !(update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo))) && updateDisplayIfNeeded(cm, update); first = !1) {
                    updateHeightsInViewport(cm);
                    var barMeasure = measureForScrollbars(cm);
                    updateSelection(cm), updateScrollbars(cm, barMeasure), setDocumentHeight(cm, barMeasure), 
                    update.force = !1;
                }
                update.signal(cm, "update", cm), cm.display.viewFrom == cm.display.reportedViewFrom && cm.display.viewTo == cm.display.reportedViewTo || (update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo), 
                cm.display.reportedViewFrom = cm.display.viewFrom, cm.display.reportedViewTo = cm.display.viewTo);
            }
            function updateDisplaySimple(cm, viewport) {
                var update = new DisplayUpdate(cm, viewport);
                if (updateDisplayIfNeeded(cm, update)) {
                    updateHeightsInViewport(cm), postUpdateDisplay(cm, update);
                    var barMeasure = measureForScrollbars(cm);
                    updateSelection(cm), updateScrollbars(cm, barMeasure), setDocumentHeight(cm, barMeasure), 
                    update.finish();
                }
            }
            // Sync the actual display DOM structure with display.view, removing
            // nodes for lines that are no longer in view, and creating the ones
            // that are not there yet, and updating the ones that are out of
            // date.
            function patchDisplay(cm, updateNumbersFrom, dims) {
                function rm(node) {
                    var next = node.nextSibling;
                    // Works around a throw-scroll bug in OS X Webkit
                    return webkit && mac && cm.display.currentWheelTarget == node ? node.style.display = "none" : node.parentNode.removeChild(node), 
                    next;
                }
                // Loop over the elements in the view, syncing cur (the DOM nodes
                // in display.lineDiv) with the view as we go.
                for (var display = cm.display, lineNumbers = cm.options.lineNumbers, container = display.lineDiv, cur = container.firstChild, view = display.view, lineN = display.viewFrom, i = 0; i < view.length; i++) {
                    var lineView = view[i];
                    if (lineView.hidden) ; else if (lineView.node && lineView.node.parentNode == container) {
                        // Already drawn
                        for (;cur != lineView.node; ) cur = rm(cur);
                        var updateNumber = lineNumbers && null != updateNumbersFrom && updateNumbersFrom <= lineN && lineView.lineNumber;
                        lineView.changes && (indexOf(lineView.changes, "gutter") > -1 && (updateNumber = !1), 
                        updateLineForChanges(cm, lineView, lineN, dims)), updateNumber && (removeChildren(lineView.lineNumber), 
                        lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)))), 
                        cur = lineView.node.nextSibling;
                    } else {
                        // Not drawn yet
                        var node = buildLineElement(cm, lineView, lineN, dims);
                        container.insertBefore(node, cur);
                    }
                    lineN += lineView.size;
                }
                for (;cur; ) cur = rm(cur);
            }
            function updateGutterSpace(cm) {
                var width = cm.display.gutters.offsetWidth;
                cm.display.sizer.style.marginLeft = width + "px";
            }
            function setDocumentHeight(cm, measure) {
                cm.display.sizer.style.minHeight = measure.docHeight + "px", cm.display.heightForcer.style.top = measure.docHeight + "px", 
                cm.display.gutters.style.height = measure.docHeight + cm.display.barHeight + scrollGap(cm) + "px";
            }
            // Rebuild the gutter elements, ensure the margin to the left of the
            // code matches their width.
            function updateGutters(cm) {
                var gutters = cm.display.gutters, specs = cm.options.gutters;
                removeChildren(gutters);
                for (var i = 0; i < specs.length; ++i) {
                    var gutterClass = specs[i], gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass));
                    "CodeMirror-linenumbers" == gutterClass && (cm.display.lineGutter = gElt, gElt.style.width = (cm.display.lineNumWidth || 1) + "px");
                }
                gutters.style.display = i ? "" : "none", updateGutterSpace(cm);
            }
            // Make sure the gutters options contains the element
            // "CodeMirror-linenumbers" when the lineNumbers option is true.
            function setGuttersForLineNumbers(options) {
                var found = indexOf(options.gutters, "CodeMirror-linenumbers");
                found == -1 && options.lineNumbers ? options.gutters = options.gutters.concat([ "CodeMirror-linenumbers" ]) : found > -1 && !options.lineNumbers && (options.gutters = options.gutters.slice(0), 
                options.gutters.splice(found, 1));
            }
            function wheelEventDelta(e) {
                var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
                return null == dx && e.detail && e.axis == e.HORIZONTAL_AXIS && (dx = e.detail), 
                null == dy && e.detail && e.axis == e.VERTICAL_AXIS ? dy = e.detail : null == dy && (dy = e.wheelDelta), 
                {
                    x: dx,
                    y: dy
                };
            }
            function wheelEventPixels(e) {
                var delta = wheelEventDelta(e);
                return delta.x *= wheelPixelsPerUnit, delta.y *= wheelPixelsPerUnit, delta;
            }
            function onScrollWheel(cm, e) {
                var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y, display = cm.display, scroll = display.scroller, canScrollX = scroll.scrollWidth > scroll.clientWidth, canScrollY = scroll.scrollHeight > scroll.clientHeight;
                if (dx && canScrollX || dy && canScrollY) {
                    // Webkit browsers on OS X abort momentum scrolls when the target
                    // of the scroll event is removed from the scrollable element.
                    // This hack (see related code in patchDisplay) makes sure the
                    // element is kept around.
                    if (dy && mac && webkit) outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) for (var i = 0; i < view.length; i++) if (view[i].node == cur) {
                        cm.display.currentWheelTarget = cur;
                        break outer;
                    }
                    // On some browsers, horizontal scrolling will cause redraws to
                    // happen before the gutter has been realigned, causing it to
                    // wriggle around in a most unseemly way. When we have an
                    // estimated pixels/delta value, we just handle horizontal
                    // scrolling entirely here. It'll be slightly off from native, but
                    // better than glitching out.
                    if (dx && !gecko && !presto && null != wheelPixelsPerUnit) // Abort measurement, if in progress
                    // Only prevent default scrolling if vertical scrolling is
                    // actually possible. Otherwise, it causes vertical scroll
                    // jitter on OSX trackpads when deltaX is small and deltaY
                    // is large (issue #3579)
                    return dy && canScrollY && updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit)), 
                    setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit)), (!dy || dy && canScrollY) && e_preventDefault(e), 
                    void (display.wheelStartX = null);
                    // 'Project' the visible viewport to cover the area that is being
                    // scrolled into view (if we know enough to estimate it).
                    if (dy && null != wheelPixelsPerUnit) {
                        var pixels = dy * wheelPixelsPerUnit, top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
                        pixels < 0 ? top = Math.max(0, top + pixels - 50) : bot = Math.min(cm.doc.height, bot + pixels + 50), 
                        updateDisplaySimple(cm, {
                            top: top,
                            bottom: bot
                        });
                    }
                    wheelSamples < 20 && (null == display.wheelStartX ? (display.wheelStartX = scroll.scrollLeft, 
                    display.wheelStartY = scroll.scrollTop, display.wheelDX = dx, display.wheelDY = dy, 
                    setTimeout(function() {
                        if (null != display.wheelStartX) {
                            var movedX = scroll.scrollLeft - display.wheelStartX, movedY = scroll.scrollTop - display.wheelStartY, sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;
                            display.wheelStartX = display.wheelStartY = null, sample && (wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1), 
                            ++wheelSamples);
                        }
                    }, 200)) : (display.wheelDX += dx, display.wheelDY += dy));
                }
            }
            // Take an unsorted, potentially overlapping set of ranges, and
            // build a selection out of it. 'Consumes' ranges array (modifying
            // it).
            function normalizeSelection(ranges, primIndex) {
                var prim = ranges[primIndex];
                ranges.sort(function(a, b) {
                    return cmp(a.from(), b.from());
                }), primIndex = indexOf(ranges, prim);
                for (var i = 1; i < ranges.length; i++) {
                    var cur = ranges[i], prev = ranges[i - 1];
                    if (cmp(prev.to(), cur.from()) >= 0) {
                        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to()), inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
                        i <= primIndex && --primIndex, ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
                    }
                }
                return new Selection(ranges, primIndex);
            }
            function simpleSelection(anchor, head) {
                return new Selection([ new Range(anchor, head || anchor) ], 0);
            }
            // Compute the position of the end of a change (its 'to' property
            // refers to the pre-change end).
            function changeEnd(change) {
                return change.text ? Pos(change.from.line + change.text.length - 1, lst(change.text).length + (1 == change.text.length ? change.from.ch : 0)) : change.to;
            }
            // Adjust a position to refer to the post-change position of the
            // same text, or the end of the change if the change covers it.
            function adjustForChange(pos, change) {
                if (cmp(pos, change.from) < 0) return pos;
                if (cmp(pos, change.to) <= 0) return changeEnd(change);
                var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
                return pos.line == change.to.line && (ch += changeEnd(change).ch - change.to.ch), 
                Pos(line, ch);
            }
            function computeSelAfterChange(doc, change) {
                for (var out = [], i = 0; i < doc.sel.ranges.length; i++) {
                    var range = doc.sel.ranges[i];
                    out.push(new Range(adjustForChange(range.anchor, change), adjustForChange(range.head, change)));
                }
                return normalizeSelection(out, doc.sel.primIndex);
            }
            function offsetPos(pos, old, nw) {
                return pos.line == old.line ? Pos(nw.line, pos.ch - old.ch + nw.ch) : Pos(nw.line + (pos.line - old.line), pos.ch);
            }
            // Used by replaceSelections to allow moving the selection to the
            // start or around the replaced test. Hint may be "start" or "around".
            function computeReplacedSel(doc, changes, hint) {
                for (var out = [], oldPrev = Pos(doc.first, 0), newPrev = oldPrev, i = 0; i < changes.length; i++) {
                    var change = changes[i], from = offsetPos(change.from, oldPrev, newPrev), to = offsetPos(changeEnd(change), oldPrev, newPrev);
                    if (oldPrev = change.to, newPrev = to, "around" == hint) {
                        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;
                        out[i] = new Range(inv ? to : from, inv ? from : to);
                    } else out[i] = new Range(from, from);
                }
                return new Selection(out, doc.sel.primIndex);
            }
            // Used to get the editor into a consistent state again when options change.
            function loadMode(cm) {
                cm.doc.mode = getMode(cm.options, cm.doc.modeOption), resetModeState(cm);
            }
            function resetModeState(cm) {
                cm.doc.iter(function(line) {
                    line.stateAfter && (line.stateAfter = null), line.styles && (line.styles = null);
                }), cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first, startWorker(cm, 100), 
                cm.state.modeGen++, cm.curOp && regChange(cm);
            }
            // DOCUMENT DATA STRUCTURE
            // By default, updates that start and end at the beginning of a line
            // are treated specially, in order to make the association of line
            // widgets and marker elements with the text behave more intuitive.
            function isWholeLineUpdate(doc, change) {
                return 0 == change.from.ch && 0 == change.to.ch && "" == lst(change.text) && (!doc.cm || doc.cm.options.wholeLineUpdateBefore);
            }
            // Perform a change on the document data structure.
            function updateDoc(doc, change, markedSpans, estimateHeight$$1) {
                function spansFor(n) {
                    return markedSpans ? markedSpans[n] : null;
                }
                function update(line, text, spans) {
                    updateLine(line, text, spans, estimateHeight$$1), signalLater(line, "change", line, change);
                }
                function linesFor(start, end) {
                    for (var result = [], i = start; i < end; ++i) result.push(new Line(text[i], spansFor(i), estimateHeight$$1));
                    return result;
                }
                var from = change.from, to = change.to, text = change.text, firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line), lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;
                // Adjust the line structure
                if (change.full) doc.insert(0, linesFor(0, text.length)), doc.remove(text.length, doc.size - text.length); else if (isWholeLineUpdate(doc, change)) {
                    // This is a whole-line replace. Treated specially to make
                    // sure line objects move the way they are supposed to.
                    var added = linesFor(0, text.length - 1);
                    update(lastLine, lastLine.text, lastSpans), nlines && doc.remove(from.line, nlines), 
                    added.length && doc.insert(from.line, added);
                } else if (firstLine == lastLine) if (1 == text.length) update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans); else {
                    var added$1 = linesFor(1, text.length - 1);
                    added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight$$1)), 
                    update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0)), doc.insert(from.line + 1, added$1);
                } else if (1 == text.length) update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0)), 
                doc.remove(from.line + 1, nlines); else {
                    update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0)), update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
                    var added$2 = linesFor(1, text.length - 1);
                    nlines > 1 && doc.remove(from.line + 1, nlines - 1), doc.insert(from.line + 1, added$2);
                }
                signalLater(doc, "change", doc, change);
            }
            // Call f for all linked documents.
            function linkedDocs(doc, f, sharedHistOnly) {
                function propagate(doc, skip, sharedHist) {
                    if (doc.linked) for (var i = 0; i < doc.linked.length; ++i) {
                        var rel = doc.linked[i];
                        if (rel.doc != skip) {
                            var shared = sharedHist && rel.sharedHist;
                            sharedHistOnly && !shared || (f(rel.doc, shared), propagate(rel.doc, doc, shared));
                        }
                    }
                }
                propagate(doc, null, !0);
            }
            // Attach a document to an editor.
            function attachDoc(cm, doc) {
                if (doc.cm) throw new Error("This document is already in use.");
                cm.doc = doc, doc.cm = cm, estimateLineHeights(cm), loadMode(cm), setDirectionClass(cm), 
                cm.options.lineWrapping || findMaxLine(cm), cm.options.mode = doc.modeOption, regChange(cm);
            }
            function setDirectionClass(cm) {
                ("rtl" == cm.doc.direction ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");
            }
            function directionChanged(cm) {
                runInOp(cm, function() {
                    setDirectionClass(cm), regChange(cm);
                });
            }
            function History(startGen) {
                // Arrays of change events and selections. Doing something adds an
                // event to done and clears undo. Undoing moves events from done
                // to undone, redoing moves them in the other direction.
                this.done = [], this.undone = [], this.undoDepth = 1 / 0, // Used to track when changes can be merged into a single undo
                // event
                this.lastModTime = this.lastSelTime = 0, this.lastOp = this.lastSelOp = null, this.lastOrigin = this.lastSelOrigin = null, 
                // Used by the isClean() method
                this.generation = this.maxGeneration = startGen || 1;
            }
            // Create a history change event from an updateDoc-style change
            // object.
            function historyChangeFromChange(doc, change) {
                var histChange = {
                    from: copyPos(change.from),
                    to: changeEnd(change),
                    text: getBetween(doc, change.from, change.to)
                };
                return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1), 
                linkedDocs(doc, function(doc) {
                    return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
                }, !0), histChange;
            }
            // Pop all selection events off the end of a history array. Stop at
            // a change event.
            function clearSelectionEvents(array) {
                for (;array.length; ) {
                    var last = lst(array);
                    if (!last.ranges) break;
                    array.pop();
                }
            }
            // Find the top change event in the history. Pop off selection
            // events that are in the way.
            function lastChangeEvent(hist, force) {
                return force ? (clearSelectionEvents(hist.done), lst(hist.done)) : hist.done.length && !lst(hist.done).ranges ? lst(hist.done) : hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges ? (hist.done.pop(), 
                lst(hist.done)) : void 0;
            }
            // Register a change in the history. Merges changes that are within
            // a single operation, or are close together with an origin that
            // allows merging (starting with "+") into a single event.
            function addChangeToHistory(doc, change, selAfter, opId) {
                var hist = doc.history;
                hist.undone.length = 0;
                var cur, last, time = +new Date();
                if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && ("+" == change.origin.charAt(0) && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay || "*" == change.origin.charAt(0))) && (cur = lastChangeEvent(hist, hist.lastOp == opId))) // Merge this change into the last event
                last = lst(cur.changes), 0 == cmp(change.from, change.to) && 0 == cmp(change.from, last.to) ? // Optimized case for simple insertion -- don't want to add
                // new changesets for every character typed
                last.to = changeEnd(change) : // Add new sub-event
                cur.changes.push(historyChangeFromChange(doc, change)); else {
                    // Can not be merged, start a new event.
                    var before = lst(hist.done);
                    for (before && before.ranges || pushSelectionToHistory(doc.sel, hist.done), cur = {
                        changes: [ historyChangeFromChange(doc, change) ],
                        generation: hist.generation
                    }, hist.done.push(cur); hist.done.length > hist.undoDepth; ) hist.done.shift(), 
                    hist.done[0].ranges || hist.done.shift();
                }
                hist.done.push(selAfter), hist.generation = ++hist.maxGeneration, hist.lastModTime = hist.lastSelTime = time, 
                hist.lastOp = hist.lastSelOp = opId, hist.lastOrigin = hist.lastSelOrigin = change.origin, 
                last || signal(doc, "historyAdded");
            }
            function selectionEventCanBeMerged(doc, origin, prev, sel) {
                var ch = origin.charAt(0);
                return "*" == ch || "+" == ch && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && new Date() - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);
            }
            // Called whenever the selection changes, sets the new selection as
            // the pending selection in the history, and pushes the old pending
            // selection into the 'done' array when it was significantly
            // different (in number of selected ranges, emptiness, or time).
            function addSelectionToHistory(doc, sel, opId, options) {
                var hist = doc.history, origin = options && options.origin;
                // A new event is started when the previous origin does not match
                // the current, or the origins don't allow matching. Origins
                // starting with * are always merged, those starting with + are
                // merged when similar and close together in time.
                opId == hist.lastSelOp || origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || selectionEventCanBeMerged(doc, origin, lst(hist.done), sel)) ? hist.done[hist.done.length - 1] = sel : pushSelectionToHistory(sel, hist.done), 
                hist.lastSelTime = +new Date(), hist.lastSelOrigin = origin, hist.lastSelOp = opId, 
                options && options.clearRedo !== !1 && clearSelectionEvents(hist.undone);
            }
            function pushSelectionToHistory(sel, dest) {
                var top = lst(dest);
                top && top.ranges && top.equals(sel) || dest.push(sel);
            }
            // Used to store marked span information in the history.
            function attachLocalSpans(doc, change, from, to) {
                var existing = change["spans_" + doc.id], n = 0;
                doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {
                    line.markedSpans && ((existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans), 
                    ++n;
                });
            }
            // When un/re-doing restores text containing marked spans, those
            // that have been explicitly cleared should not be restored.
            function removeClearedSpans(spans) {
                if (!spans) return null;
                for (var out, i = 0; i < spans.length; ++i) spans[i].marker.explicitlyCleared ? out || (out = spans.slice(0, i)) : out && out.push(spans[i]);
                return out ? out.length ? out : null : spans;
            }
            // Retrieve and filter the old marked spans stored in a change event.
            function getOldSpans(doc, change) {
                var found = change["spans_" + doc.id];
                if (!found) return null;
                for (var nw = [], i = 0; i < change.text.length; ++i) nw.push(removeClearedSpans(found[i]));
                return nw;
            }
            // Used for un/re-doing changes from the history. Combines the
            // result of computing the existing spans with the set of spans that
            // existed in the history (so that deleting around a span and then
            // undoing brings back the span).
            function mergeOldSpans(doc, change) {
                var old = getOldSpans(doc, change), stretched = stretchSpansOverChange(doc, change);
                if (!old) return stretched;
                if (!stretched) return old;
                for (var i = 0; i < old.length; ++i) {
                    var oldCur = old[i], stretchCur = stretched[i];
                    if (oldCur && stretchCur) spans: for (var j = 0; j < stretchCur.length; ++j) {
                        for (var span = stretchCur[j], k = 0; k < oldCur.length; ++k) if (oldCur[k].marker == span.marker) continue spans;
                        oldCur.push(span);
                    } else stretchCur && (old[i] = stretchCur);
                }
                return old;
            }
            // Used both to provide a JSON-safe object in .getHistory, and, when
            // detaching a document, to split the history in two
            function copyHistoryArray(events, newGroup, instantiateSel) {
                for (var copy = [], i = 0; i < events.length; ++i) {
                    var event = events[i];
                    if (event.ranges) copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event); else {
                        var changes = event.changes, newChanges = [];
                        copy.push({
                            changes: newChanges
                        });
                        for (var j = 0; j < changes.length; ++j) {
                            var change = changes[j], m = void 0;
                            if (newChanges.push({
                                from: change.from,
                                to: change.to,
                                text: change.text
                            }), newGroup) for (var prop in change) (m = prop.match(/^spans_(\d+)$/)) && indexOf(newGroup, Number(m[1])) > -1 && (lst(newChanges)[prop] = change[prop], 
                            delete change[prop]);
                        }
                    }
                }
                return copy;
            }
            // The 'scroll' parameter given to many of these indicated whether
            // the new cursor position should be scrolled into view after
            // modifying the selection.
            // If shift is held or the extend flag is set, extends a range to
            // include a given position (and optionally a second position).
            // Otherwise, simply returns the range between the given positions.
            // Used for cursor motion and such.
            function extendRange(range, head, other, extend) {
                if (extend) {
                    var anchor = range.anchor;
                    if (other) {
                        var posBefore = cmp(head, anchor) < 0;
                        posBefore != cmp(other, anchor) < 0 ? (anchor = head, head = other) : posBefore != cmp(head, other) < 0 && (head = other);
                    }
                    return new Range(anchor, head);
                }
                return new Range(other || head, head);
            }
            // Extend the primary selection range, discard the rest.
            function extendSelection(doc, head, other, options, extend) {
                null == extend && (extend = doc.cm && (doc.cm.display.shift || doc.extend)), setSelection(doc, new Selection([ extendRange(doc.sel.primary(), head, other, extend) ], 0), options);
            }
            // Extend all selections (pos is an array of selections with length
            // equal the number of selections)
            function extendSelections(doc, heads, options) {
                for (var out = [], extend = doc.cm && (doc.cm.display.shift || doc.extend), i = 0; i < doc.sel.ranges.length; i++) out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend);
                var newSel = normalizeSelection(out, doc.sel.primIndex);
                setSelection(doc, newSel, options);
            }
            // Updates a single range in the selection.
            function replaceOneSelection(doc, i, range, options) {
                var ranges = doc.sel.ranges.slice(0);
                ranges[i] = range, setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);
            }
            // Reset the selection to a single range.
            function setSimpleSelection(doc, anchor, head, options) {
                setSelection(doc, simpleSelection(anchor, head), options);
            }
            // Give beforeSelectionChange handlers a change to influence a
            // selection update.
            function filterSelectionChange(doc, sel, options) {
                var obj = {
                    ranges: sel.ranges,
                    update: function(ranges) {
                        var this$1 = this;
                        this.ranges = [];
                        for (var i = 0; i < ranges.length; i++) this$1.ranges[i] = new Range(clipPos(doc, ranges[i].anchor), clipPos(doc, ranges[i].head));
                    },
                    origin: options && options.origin
                };
                return signal(doc, "beforeSelectionChange", doc, obj), doc.cm && signal(doc.cm, "beforeSelectionChange", doc.cm, obj), 
                obj.ranges != sel.ranges ? normalizeSelection(obj.ranges, obj.ranges.length - 1) : sel;
            }
            function setSelectionReplaceHistory(doc, sel, options) {
                var done = doc.history.done, last = lst(done);
                last && last.ranges ? (done[done.length - 1] = sel, setSelectionNoUndo(doc, sel, options)) : setSelection(doc, sel, options);
            }
            // Set a new selection.
            function setSelection(doc, sel, options) {
                setSelectionNoUndo(doc, sel, options), addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
            }
            function setSelectionNoUndo(doc, sel, options) {
                (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange")) && (sel = filterSelectionChange(doc, sel, options));
                var bias = options && options.bias || (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
                setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, !0)), options && options.scroll === !1 || !doc.cm || ensureCursorVisible(doc.cm);
            }
            function setSelectionInner(doc, sel) {
                sel.equals(doc.sel) || (doc.sel = sel, doc.cm && (doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = !0, 
                signalCursorActivity(doc.cm)), signalLater(doc, "cursorActivity", doc));
            }
            // Verify that the selection does not partially select any atomic
            // marked ranges.
            function reCheckSelection(doc) {
                setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, !1));
            }
            // Return a selection that does not partially select any atomic
            // ranges.
            function skipAtomicInSelection(doc, sel, bias, mayClear) {
                for (var out, i = 0; i < sel.ranges.length; i++) {
                    var range = sel.ranges[i], old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i], newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear), newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);
                    (out || newAnchor != range.anchor || newHead != range.head) && (out || (out = sel.ranges.slice(0, i)), 
                    out[i] = new Range(newAnchor, newHead));
                }
                return out ? normalizeSelection(out, sel.primIndex) : sel;
            }
            function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
                var line = getLine(doc, pos.line);
                if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {
                    var sp = line.markedSpans[i], m = sp.marker;
                    if ((null == sp.from || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) && (null == sp.to || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
                        if (mayClear && (signal(m, "beforeCursorEnter"), m.explicitlyCleared)) {
                            if (line.markedSpans) {
                                --i;
                                continue;
                            }
                            break;
                        }
                        if (!m.atomic) continue;
                        if (oldPos) {
                            var near = m.find(dir < 0 ? 1 : -1), diff = void 0;
                            if ((dir < 0 ? m.inclusiveRight : m.inclusiveLeft) && (near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null)), 
                            near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0)) return skipAtomicInner(doc, near, pos, dir, mayClear);
                        }
                        var far = m.find(dir < 0 ? -1 : 1);
                        return (dir < 0 ? m.inclusiveLeft : m.inclusiveRight) && (far = movePos(doc, far, dir, far.line == pos.line ? line : null)), 
                        far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null;
                    }
                }
                return pos;
            }
            // Ensure a given position is not inside an atomic range.
            function skipAtomic(doc, pos, oldPos, bias, mayClear) {
                var dir = bias || 1, found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, dir, !0) || skipAtomicInner(doc, pos, oldPos, -dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, -dir, !0);
                return found ? found : (doc.cantEdit = !0, Pos(doc.first, 0));
            }
            function movePos(doc, pos, dir, line) {
                return dir < 0 && 0 == pos.ch ? pos.line > doc.first ? clipPos(doc, Pos(pos.line - 1)) : null : dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length ? pos.line < doc.first + doc.size - 1 ? Pos(pos.line + 1, 0) : null : new Pos(pos.line, pos.ch + dir);
            }
            function selectAll(cm) {
                cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
            }
            // UPDATING
            // Allow "beforeChange" event handlers to influence a change
            function filterChange(doc, change, update) {
                var obj = {
                    canceled: !1,
                    from: change.from,
                    to: change.to,
                    text: change.text,
                    origin: change.origin,
                    cancel: function() {
                        return obj.canceled = !0;
                    }
                };
                return update && (obj.update = function(from, to, text, origin) {
                    from && (obj.from = clipPos(doc, from)), to && (obj.to = clipPos(doc, to)), text && (obj.text = text), 
                    void 0 !== origin && (obj.origin = origin);
                }), signal(doc, "beforeChange", doc, obj), doc.cm && signal(doc.cm, "beforeChange", doc.cm, obj), 
                obj.canceled ? null : {
                    from: obj.from,
                    to: obj.to,
                    text: obj.text,
                    origin: obj.origin
                };
            }
            // Apply a change to a document, and add it to the document's
            // history, and propagating it to all linked documents.
            function makeChange(doc, change, ignoreReadOnly) {
                if (doc.cm) {
                    if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);
                    if (doc.cm.state.suppressEdits) return;
                }
                if (!(hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) || (change = filterChange(doc, change, !0))) {
                    // Possibly split or suppress the update based on the presence
                    // of read-only spans in its range.
                    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
                    if (split) for (var i = split.length - 1; i >= 0; --i) makeChangeInner(doc, {
                        from: split[i].from,
                        to: split[i].to,
                        text: i ? [ "" ] : change.text,
                        origin: change.origin
                    }); else makeChangeInner(doc, change);
                }
            }
            function makeChangeInner(doc, change) {
                if (1 != change.text.length || "" != change.text[0] || 0 != cmp(change.from, change.to)) {
                    var selAfter = computeSelAfterChange(doc, change);
                    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN), makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
                    var rebased = [];
                    linkedDocs(doc, function(doc, sharedHist) {
                        sharedHist || indexOf(rebased, doc.history) != -1 || (rebaseHist(doc.history, change), 
                        rebased.push(doc.history)), makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
                    });
                }
            }
            // Revert a change stored in a document's history.
            function makeChangeFromHistory(doc, type, allowSelectionOnly) {
                if (!doc.cm || !doc.cm.state.suppressEdits || allowSelectionOnly) {
                    for (var event, hist = doc.history, selAfter = doc.sel, source = "undo" == type ? hist.done : hist.undone, dest = "undo" == type ? hist.undone : hist.done, i = 0; i < source.length && (event = source[i], 
                    allowSelectionOnly ? !event.ranges || event.equals(doc.sel) : event.ranges); i++) ;
                    if (i != source.length) {
                        for (hist.lastOrigin = hist.lastSelOrigin = null; event = source.pop(), event.ranges; ) {
                            if (pushSelectionToHistory(event, dest), allowSelectionOnly && !event.equals(doc.sel)) return void setSelection(doc, event, {
                                clearRedo: !1
                            });
                            selAfter = event;
                        }
                        // Build up a reverse change object to add to the opposite history
                        // stack (redo when undoing, and vice versa).
                        var antiChanges = [];
                        pushSelectionToHistory(selAfter, dest), dest.push({
                            changes: antiChanges,
                            generation: hist.generation
                        }), hist.generation = event.generation || ++hist.maxGeneration;
                        for (var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange"), loop = function(i) {
                            var change = event.changes[i];
                            if (change.origin = type, filter && !filterChange(doc, change, !1)) return source.length = 0, 
                            {};
                            antiChanges.push(historyChangeFromChange(doc, change));
                            var after = i ? computeSelAfterChange(doc, change) : lst(source);
                            makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change)), !i && doc.cm && doc.cm.scrollIntoView({
                                from: change.from,
                                to: changeEnd(change)
                            });
                            var rebased = [];
                            // Propagate to the linked documents
                            linkedDocs(doc, function(doc, sharedHist) {
                                sharedHist || indexOf(rebased, doc.history) != -1 || (rebaseHist(doc.history, change), 
                                rebased.push(doc.history)), makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
                            });
                        }, i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {
                            var returned = loop(i$1);
                            if (returned) return returned.v;
                        }
                    }
                }
            }
            // Sub-views need their line numbers shifted when text is added
            // above or below them in the parent document.
            function shiftDoc(doc, distance) {
                if (0 != distance && (doc.first += distance, doc.sel = new Selection(map(doc.sel.ranges, function(range) {
                    return new Range(Pos(range.anchor.line + distance, range.anchor.ch), Pos(range.head.line + distance, range.head.ch));
                }), doc.sel.primIndex), doc.cm)) {
                    regChange(doc.cm, doc.first, doc.first - distance, distance);
                    for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++) regLineChange(doc.cm, l, "gutter");
                }
            }
            // More lower-level change function, handling only a single document
            // (not linked ones).
            function makeChangeSingleDoc(doc, change, selAfter, spans) {
                if (doc.cm && !doc.cm.curOp) return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);
                if (change.to.line < doc.first) return void shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
                if (!(change.from.line > doc.lastLine())) {
                    // Clip the change to the size of this doc
                    if (change.from.line < doc.first) {
                        var shift = change.text.length - 1 - (doc.first - change.from.line);
                        shiftDoc(doc, shift), change = {
                            from: Pos(doc.first, 0),
                            to: Pos(change.to.line + shift, change.to.ch),
                            text: [ lst(change.text) ],
                            origin: change.origin
                        };
                    }
                    var last = doc.lastLine();
                    change.to.line > last && (change = {
                        from: change.from,
                        to: Pos(last, getLine(doc, last).text.length),
                        text: [ change.text[0] ],
                        origin: change.origin
                    }), change.removed = getBetween(doc, change.from, change.to), selAfter || (selAfter = computeSelAfterChange(doc, change)), 
                    doc.cm ? makeChangeSingleDocInEditor(doc.cm, change, spans) : updateDoc(doc, change, spans), 
                    setSelectionNoUndo(doc, selAfter, sel_dontScroll);
                }
            }
            // Handle the interaction of a change to a document with the editor
            // that this document is part of.
            function makeChangeSingleDocInEditor(cm, change, spans) {
                var doc = cm.doc, display = cm.display, from = change.from, to = change.to, recomputeMaxLength = !1, checkWidthStart = from.line;
                cm.options.lineWrapping || (checkWidthStart = lineNo(visualLine(getLine(doc, from.line))), 
                doc.iter(checkWidthStart, to.line + 1, function(line) {
                    if (line == display.maxLine) return recomputeMaxLength = !0, !0;
                })), doc.sel.contains(change.from, change.to) > -1 && signalCursorActivity(cm), 
                updateDoc(doc, change, spans, estimateHeight(cm)), cm.options.lineWrapping || (doc.iter(checkWidthStart, from.line + change.text.length, function(line) {
                    var len = lineLength(line);
                    len > display.maxLineLength && (display.maxLine = line, display.maxLineLength = len, 
                    display.maxLineChanged = !0, recomputeMaxLength = !1);
                }), recomputeMaxLength && (cm.curOp.updateMaxLine = !0)), retreatFrontier(doc, from.line), 
                startWorker(cm, 400);
                var lendiff = change.text.length - (to.line - from.line) - 1;
                // Remember that these lines changed, for updating the display
                change.full ? regChange(cm) : from.line != to.line || 1 != change.text.length || isWholeLineUpdate(cm.doc, change) ? regChange(cm, from.line, to.line + 1, lendiff) : regLineChange(cm, from.line, "text");
                var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
                if (changeHandler || changesHandler) {
                    var obj = {
                        from: from,
                        to: to,
                        text: change.text,
                        removed: change.removed,
                        origin: change.origin
                    };
                    changeHandler && signalLater(cm, "change", cm, obj), changesHandler && (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
                }
                cm.display.selForContextMenu = null;
            }
            function replaceRange(doc, code, from, to, origin) {
                if (to || (to = from), cmp(to, from) < 0) {
                    var assign;
                    assign = [ to, from ], from = assign[0], to = assign[1], assign;
                }
                "string" == typeof code && (code = doc.splitLines(code)), makeChange(doc, {
                    from: from,
                    to: to,
                    text: code,
                    origin: origin
                });
            }
            // Rebasing/resetting history to deal with externally-sourced changes
            function rebaseHistSelSingle(pos, from, to, diff) {
                to < pos.line ? pos.line += diff : from < pos.line && (pos.line = from, pos.ch = 0);
            }
            // Tries to rebase an array of history events given a change in the
            // document. If the change touches the same lines as the event, the
            // event, and everything 'behind' it, is discarded. If the change is
            // before the event, the event's positions are updated. Uses a
            // copy-on-write scheme for the positions, to avoid having to
            // reallocate them all on every rebase, but also avoid problems with
            // shared position objects being unsafely updated.
            function rebaseHistArray(array, from, to, diff) {
                for (var i = 0; i < array.length; ++i) {
                    var sub = array[i], ok = !0;
                    if (sub.ranges) {
                        sub.copied || (sub = array[i] = sub.deepCopy(), sub.copied = !0);
                        for (var j = 0; j < sub.ranges.length; j++) rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff), 
                        rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
                    } else {
                        for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
                            var cur = sub.changes[j$1];
                            if (to < cur.from.line) cur.from = Pos(cur.from.line + diff, cur.from.ch), cur.to = Pos(cur.to.line + diff, cur.to.ch); else if (from <= cur.to.line) {
                                ok = !1;
                                break;
                            }
                        }
                        ok || (array.splice(0, i + 1), i = 0);
                    }
                }
            }
            function rebaseHist(hist, change) {
                var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
                rebaseHistArray(hist.done, from, to, diff), rebaseHistArray(hist.undone, from, to, diff);
            }
            // Utility for applying a change to a line by handle or number,
            // returning the number and optionally registering the line as
            // changed.
            function changeLine(doc, handle, changeType, op) {
                var no = handle, line = handle;
                return "number" == typeof handle ? line = getLine(doc, clipLine(doc, handle)) : no = lineNo(handle), 
                null == no ? null : (op(line, no) && doc.cm && regLineChange(doc.cm, no, changeType), 
                line);
            }
            // The document is represented as a BTree consisting of leaves, with
            // chunk of lines in them, and branches, with up to ten leaves or
            // other branch nodes below them. The top node is always a branch
            // node, and is the document object itself (meaning it has
            // additional methods and properties).
            //
            // All nodes have parent links. The tree is used both to go from
            // line numbers to line objects, and to go from objects to numbers.
            // It also indexes by height, and is used to convert between height
            // and line object, and to find the total height of the document.
            //
            // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html
            function LeafChunk(lines) {
                var this$1 = this;
                this.lines = lines, this.parent = null;
                for (var height = 0, i = 0; i < lines.length; ++i) lines[i].parent = this$1, height += lines[i].height;
                this.height = height;
            }
            function BranchChunk(children) {
                var this$1 = this;
                this.children = children;
                for (var size = 0, height = 0, i = 0; i < children.length; ++i) {
                    var ch = children[i];
                    size += ch.chunkSize(), height += ch.height, ch.parent = this$1;
                }
                this.size = size, this.height = height, this.parent = null;
            }
            function adjustScrollWhenAboveVisible(cm, line, diff) {
                heightAtLine(line) < (cm.curOp && cm.curOp.scrollTop || cm.doc.scrollTop) && addToScrollTop(cm, diff);
            }
            function addLineWidget(doc, handle, node, options) {
                var widget = new LineWidget(doc, node, options), cm = doc.cm;
                return cm && widget.noHScroll && (cm.display.alignWidgets = !0), changeLine(doc, handle, "widget", function(line) {
                    var widgets = line.widgets || (line.widgets = []);
                    if (null == widget.insertAt ? widgets.push(widget) : widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget), 
                    widget.line = line, cm && !lineIsHidden(doc, line)) {
                        var aboveVisible = heightAtLine(line) < doc.scrollTop;
                        updateLineHeight(line, line.height + widgetHeight(widget)), aboveVisible && addToScrollTop(cm, widget.height), 
                        cm.curOp.forceUpdate = !0;
                    }
                    return !0;
                }), signalLater(cm, "lineWidgetAdded", cm, widget, "number" == typeof handle ? handle : lineNo(handle)), 
                widget;
            }
            // Create a marker, wire it up to the right lines, and
            function markText(doc, from, to, options, type) {
                // Shared markers (across linked documents) are handled separately
                // (markTextShared will call out to this again, once per
                // document).
                if (options && options.shared) return markTextShared(doc, from, to, options, type);
                // Ensure we are in an operation.
                if (doc.cm && !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);
                var marker = new TextMarker(doc, type), diff = cmp(from, to);
                // Don't connect empty markers unless clearWhenEmpty is false
                if (options && copyObj(options, marker, !1), diff > 0 || 0 == diff && marker.clearWhenEmpty !== !1) return marker;
                if (marker.replacedWith && (// Showing up as a widget implies collapsed (widget replaces text)
                marker.collapsed = !0, marker.widgetNode = eltP("span", [ marker.replacedWith ], "CodeMirror-widget"), 
                options.handleMouseEvents || marker.widgetNode.setAttribute("cm-ignore-events", "true"), 
                options.insertLeft && (marker.widgetNode.insertLeft = !0)), marker.collapsed) {
                    if (conflictingCollapsedRange(doc, from.line, from, to, marker) || from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker)) throw new Error("Inserting collapsed marker partially overlapping an existing one");
                    seeCollapsedSpans();
                }
                marker.addToHistory && addChangeToHistory(doc, {
                    from: from,
                    to: to,
                    origin: "markText"
                }, doc.sel, NaN);
                var updateMaxLine, curLine = from.line, cm = doc.cm;
                if (doc.iter(curLine, to.line + 1, function(line) {
                    cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine && (updateMaxLine = !0), 
                    marker.collapsed && curLine != from.line && updateLineHeight(line, 0), addMarkedSpan(line, new MarkedSpan(marker, curLine == from.line ? from.ch : null, curLine == to.line ? to.ch : null)), 
                    ++curLine;
                }), // lineIsHidden depends on the presence of the spans, so needs a second pass
                marker.collapsed && doc.iter(from.line, to.line + 1, function(line) {
                    lineIsHidden(doc, line) && updateLineHeight(line, 0);
                }), marker.clearOnEnter && on(marker, "beforeCursorEnter", function() {
                    return marker.clear();
                }), marker.readOnly && (seeReadOnlySpans(), (doc.history.done.length || doc.history.undone.length) && doc.clearHistory()), 
                marker.collapsed && (marker.id = ++nextMarkerId, marker.atomic = !0), cm) {
                    if (// Sync editor state
                    updateMaxLine && (cm.curOp.updateMaxLine = !0), marker.collapsed) regChange(cm, from.line, to.line + 1); else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css) for (var i = from.line; i <= to.line; i++) regLineChange(cm, i, "text");
                    marker.atomic && reCheckSelection(cm.doc), signalLater(cm, "markerAdded", cm, marker);
                }
                return marker;
            }
            function markTextShared(doc, from, to, options, type) {
                options = copyObj(options), options.shared = !1;
                var markers = [ markText(doc, from, to, options, type) ], primary = markers[0], widget = options.widgetNode;
                return linkedDocs(doc, function(doc) {
                    widget && (options.widgetNode = widget.cloneNode(!0)), markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
                    for (var i = 0; i < doc.linked.length; ++i) if (doc.linked[i].isParent) return;
                    primary = lst(markers);
                }), new SharedTextMarker(markers, primary);
            }
            function findSharedMarkers(doc) {
                return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function(m) {
                    return m.parent;
                });
            }
            function copySharedMarkers(doc, markers) {
                for (var i = 0; i < markers.length; i++) {
                    var marker = markers[i], pos = marker.find(), mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
                    if (cmp(mFrom, mTo)) {
                        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
                        marker.markers.push(subMark), subMark.parent = marker;
                    }
                }
            }
            function detachSharedMarkers(markers) {
                for (var loop = function(i) {
                    var marker = markers[i], linked = [ marker.primary.doc ];
                    linkedDocs(marker.primary.doc, function(d) {
                        return linked.push(d);
                    });
                    for (var j = 0; j < marker.markers.length; j++) {
                        var subMarker = marker.markers[j];
                        indexOf(linked, subMarker.doc) == -1 && (subMarker.parent = null, marker.markers.splice(j--, 1));
                    }
                }, i = 0; i < markers.length; i++) loop(i);
            }
            function onDrop(e) {
                var cm = this;
                if (clearDragCursor(cm), !signalDOMEvent(cm, e) && !eventInWidget(cm.display, e)) {
                    e_preventDefault(e), ie && (lastDrop = +new Date());
                    var pos = posFromMouse(cm, e, !0), files = e.dataTransfer.files;
                    if (pos && !cm.isReadOnly()) // Might be a file drop, in which case we simply extract the text
                    // and insert it.
                    if (files && files.length && window.FileReader && window.File) for (var n = files.length, text = Array(n), read = 0, loadFile = function(file, i) {
                        if (!cm.options.allowDropFileTypes || indexOf(cm.options.allowDropFileTypes, file.type) != -1) {
                            var reader = new FileReader();
                            reader.onload = operation(cm, function() {
                                var content = reader.result;
                                if (/[\x00-\x08\x0e-\x1f]{2}/.test(content) && (content = ""), text[i] = content, 
                                ++read == n) {
                                    pos = clipPos(cm.doc, pos);
                                    var change = {
                                        from: pos,
                                        to: pos,
                                        text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),
                                        origin: "paste"
                                    };
                                    makeChange(cm.doc, change), setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));
                                }
                            }), reader.readAsText(file);
                        }
                    }, i = 0; i < n; ++i) loadFile(files[i], i); else {
                        // Normal drop
                        // Don't do a replace if the drop happened inside of the selected text.
                        if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) // Ensure the editor is re-focused
                        return cm.state.draggingText(e), void setTimeout(function() {
                            return cm.display.input.focus();
                        }, 20);
                        try {
                            var text$1 = e.dataTransfer.getData("Text");
                            if (text$1) {
                                var selected;
                                if (cm.state.draggingText && !cm.state.draggingText.copy && (selected = cm.listSelections()), 
                                setSelectionNoUndo(cm.doc, simpleSelection(pos, pos)), selected) for (var i$1 = 0; i$1 < selected.length; ++i$1) replaceRange(cm.doc, "", selected[i$1].anchor, selected[i$1].head, "drag");
                                cm.replaceSelection(text$1, "around", "paste"), cm.display.input.focus();
                            }
                        } catch (e) {}
                    }
                }
            }
            function onDragStart(cm, e) {
                if (ie && (!cm.state.draggingText || +new Date() - lastDrop < 100)) return void e_stop(e);
                if (!signalDOMEvent(cm, e) && !eventInWidget(cm.display, e) && (e.dataTransfer.setData("Text", cm.getSelection()), 
                e.dataTransfer.effectAllowed = "copyMove", e.dataTransfer.setDragImage && !safari)) {
                    var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
                    img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==", 
                    presto && (img.width = img.height = 1, cm.display.wrapper.appendChild(img), // Force a relayout, or Opera won't use our image for some obscure reason
                    img._top = img.offsetTop), e.dataTransfer.setDragImage(img, 0, 0), presto && img.parentNode.removeChild(img);
                }
            }
            function onDragOver(cm, e) {
                var pos = posFromMouse(cm, e);
                if (pos) {
                    var frag = document.createDocumentFragment();
                    drawSelectionCursor(cm, pos, frag), cm.display.dragCursor || (cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors"), 
                    cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv)), 
                    removeChildrenAndAdd(cm.display.dragCursor, frag);
                }
            }
            function clearDragCursor(cm) {
                cm.display.dragCursor && (cm.display.lineSpace.removeChild(cm.display.dragCursor), 
                cm.display.dragCursor = null);
            }
            // These must be handled carefully, because naively registering a
            // handler for each editor will cause the editors to never be
            // garbage collected.
            function forEachCodeMirror(f) {
                if (document.getElementsByClassName) for (var byClass = document.getElementsByClassName("CodeMirror"), i = 0; i < byClass.length; i++) {
                    var cm = byClass[i].CodeMirror;
                    cm && f(cm);
                }
            }
            function ensureGlobalHandlers() {
                globalsRegistered || (registerGlobalHandlers(), globalsRegistered = !0);
            }
            function registerGlobalHandlers() {
                // When the window resizes, we need to refresh active editors.
                var resizeTimer;
                on(window, "resize", function() {
                    null == resizeTimer && (resizeTimer = setTimeout(function() {
                        resizeTimer = null, forEachCodeMirror(onResize);
                    }, 100));
                }), // When the window loses focus, we want to show the editor as blurred
                on(window, "blur", function() {
                    return forEachCodeMirror(onBlur);
                });
            }
            // Called when the window resizes
            function onResize(cm) {
                var d = cm.display;
                d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth || (// Might be a text scaling operation, clear size caches.
                d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null, d.scrollbarsClipped = !1, 
                cm.setSize());
            }
            // KEYMAP DISPATCH
            function normalizeKeyName(name) {
                var parts = name.split(/-(?!$)/);
                name = parts[parts.length - 1];
                for (var alt, ctrl, shift, cmd, i = 0; i < parts.length - 1; i++) {
                    var mod = parts[i];
                    if (/^(cmd|meta|m)$/i.test(mod)) cmd = !0; else if (/^a(lt)?$/i.test(mod)) alt = !0; else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = !0; else {
                        if (!/^s(hift)?$/i.test(mod)) throw new Error("Unrecognized modifier name: " + mod);
                        shift = !0;
                    }
                }
                return alt && (name = "Alt-" + name), ctrl && (name = "Ctrl-" + name), cmd && (name = "Cmd-" + name), 
                shift && (name = "Shift-" + name), name;
            }
            // This is a kludge to keep keymaps mostly working as raw objects
            // (backwards compatibility) while at the same time support features
            // like normalization and multi-stroke key bindings. It compiles a
            // new normalized keymap, and then updates the old object to reflect
            // this.
            function normalizeKeyMap(keymap) {
                var copy = {};
                for (var keyname in keymap) if (keymap.hasOwnProperty(keyname)) {
                    var value = keymap[keyname];
                    if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) continue;
                    if ("..." == value) {
                        delete keymap[keyname];
                        continue;
                    }
                    for (var keys = map(keyname.split(" "), normalizeKeyName), i = 0; i < keys.length; i++) {
                        var val = void 0, name = void 0;
                        i == keys.length - 1 ? (name = keys.join(" "), val = value) : (name = keys.slice(0, i + 1).join(" "), 
                        val = "...");
                        var prev = copy[name];
                        if (prev) {
                            if (prev != val) throw new Error("Inconsistent bindings for " + name);
                        } else copy[name] = val;
                    }
                    delete keymap[keyname];
                }
                for (var prop in copy) keymap[prop] = copy[prop];
                return keymap;
            }
            function lookupKey(key, map$$1, handle, context) {
                map$$1 = getKeyMap(map$$1);
                var found = map$$1.call ? map$$1.call(key, context) : map$$1[key];
                if (found === !1) return "nothing";
                if ("..." === found) return "multi";
                if (null != found && handle(found)) return "handled";
                if (map$$1.fallthrough) {
                    if ("[object Array]" != Object.prototype.toString.call(map$$1.fallthrough)) return lookupKey(key, map$$1.fallthrough, handle, context);
                    for (var i = 0; i < map$$1.fallthrough.length; i++) {
                        var result = lookupKey(key, map$$1.fallthrough[i], handle, context);
                        if (result) return result;
                    }
                }
            }
            // Modifier key presses don't count as 'real' key presses for the
            // purpose of keymap fallthrough.
            function isModifierKey(value) {
                var name = "string" == typeof value ? value : keyNames[value.keyCode];
                return "Ctrl" == name || "Alt" == name || "Shift" == name || "Mod" == name;
            }
            function addModifierNames(name, event, noShift) {
                var base = name;
                return event.altKey && "Alt" != base && (name = "Alt-" + name), (flipCtrlCmd ? event.metaKey : event.ctrlKey) && "Ctrl" != base && (name = "Ctrl-" + name), 
                (flipCtrlCmd ? event.ctrlKey : event.metaKey) && "Cmd" != base && (name = "Cmd-" + name), 
                !noShift && event.shiftKey && "Shift" != base && (name = "Shift-" + name), name;
            }
            // Look up the name of a key as indicated by an event object.
            function keyName(event, noShift) {
                if (presto && 34 == event.keyCode && event.char) return !1;
                var name = keyNames[event.keyCode];
                return null != name && !event.altGraphKey && addModifierNames(name, event, noShift);
            }
            function getKeyMap(val) {
                return "string" == typeof val ? keyMap[val] : val;
            }
            // Helper for deleting text near the selection(s), used to implement
            // backspace, delete, and similar functionality.
            function deleteNearSelection(cm, compute) {
                // Build up a set of ranges to kill first, merging overlapping
                // ranges.
                for (var ranges = cm.doc.sel.ranges, kill = [], i = 0; i < ranges.length; i++) {
                    for (var toKill = compute(ranges[i]); kill.length && cmp(toKill.from, lst(kill).to) <= 0; ) {
                        var replaced = kill.pop();
                        if (cmp(replaced.from, toKill.from) < 0) {
                            toKill.from = replaced.from;
                            break;
                        }
                    }
                    kill.push(toKill);
                }
                // Next, remove those actual ranges.
                runInOp(cm, function() {
                    for (var i = kill.length - 1; i >= 0; i--) replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete");
                    ensureCursorVisible(cm);
                });
            }
            function moveCharLogically(line, ch, dir) {
                var target = skipExtendingChars(line.text, ch + dir, dir);
                return target < 0 || target > line.text.length ? null : target;
            }
            function moveLogically(line, start, dir) {
                var ch = moveCharLogically(line, start.ch, dir);
                return null == ch ? null : new Pos(start.line, ch, dir < 0 ? "after" : "before");
            }
            function endOfLine(visually, cm, lineObj, lineNo, dir) {
                if (visually) {
                    var order = getOrder(lineObj, cm.doc.direction);
                    if (order) {
                        var ch, part = dir < 0 ? lst(order) : order[0], moveInStorageOrder = dir < 0 == (1 == part.level), sticky = moveInStorageOrder ? "after" : "before";
                        // With a wrapped rtl chunk (possibly spanning multiple bidi parts),
                        // it could be that the last bidi part is not on the last visual line,
                        // since visual lines contain content order-consecutive chunks.
                        // Thus, in rtl, we are looking for the first (content-order) character
                        // in the rtl chunk that is on the last line (that is, the same line
                        // as the last (content-order) character).
                        if (part.level > 0 || "rtl" == cm.doc.direction) {
                            var prep = prepareMeasureForLine(cm, lineObj);
                            ch = dir < 0 ? lineObj.text.length - 1 : 0;
                            var targetTop = measureCharPrepared(cm, prep, ch).top;
                            ch = findFirst(function(ch) {
                                return measureCharPrepared(cm, prep, ch).top == targetTop;
                            }, dir < 0 == (1 == part.level) ? part.from : part.to - 1, ch), "before" == sticky && (ch = moveCharLogically(lineObj, ch, 1));
                        } else ch = dir < 0 ? part.to : part.from;
                        return new Pos(lineNo, ch, sticky);
                    }
                }
                return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after");
            }
            function moveVisually(cm, line, start, dir) {
                var bidi = getOrder(line, cm.doc.direction);
                if (!bidi) return moveLogically(line, start, dir);
                start.ch >= line.text.length ? (start.ch = line.text.length, start.sticky = "before") : start.ch <= 0 && (start.ch = 0, 
                start.sticky = "after");
                var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];
                if ("ltr" == cm.doc.direction && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,
                // nothing interesting happens.
                return moveLogically(line, start, dir);
                var prep, mv = function(pos, dir) {
                    return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir);
                }, getWrappedLineExtent = function(ch) {
                    return cm.options.lineWrapping ? (prep = prep || prepareMeasureForLine(cm, line), 
                    wrappedLineExtentChar(cm, line, prep, ch)) : {
                        begin: 0,
                        end: line.text.length
                    };
                }, wrappedLineExtent = getWrappedLineExtent("before" == start.sticky ? mv(start, -1) : start.ch);
                if ("rtl" == cm.doc.direction || 1 == part.level) {
                    var moveInStorageOrder = 1 == part.level == dir < 0, ch = mv(start, moveInStorageOrder ? 1 : -1);
                    if (null != ch && (moveInStorageOrder ? ch <= part.to && ch <= wrappedLineExtent.end : ch >= part.from && ch >= wrappedLineExtent.begin)) {
                        // Case 2: We move within an rtl part or in an rtl editor on the same visual line
                        var sticky = moveInStorageOrder ? "before" : "after";
                        return new Pos(start.line, ch, sticky);
                    }
                }
                // Case 3: Could not move within this bidi part in this visual line, so leave
                // the current bidi part
                var searchInVisualLine = function(partPos, dir, wrappedLineExtent) {
                    for (var getRes = function(ch, moveInStorageOrder) {
                        return moveInStorageOrder ? new Pos(start.line, mv(ch, 1), "before") : new Pos(start.line, ch, "after");
                    }; partPos >= 0 && partPos < bidi.length; partPos += dir) {
                        var part = bidi[partPos], moveInStorageOrder = dir > 0 == (1 != part.level), ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);
                        if (part.from <= ch && ch < part.to) return getRes(ch, moveInStorageOrder);
                        if (ch = moveInStorageOrder ? part.from : mv(part.to, -1), wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) return getRes(ch, moveInStorageOrder);
                    }
                }, res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);
                if (res) return res;
                // Case 3b: Look for other bidi parts on the next visual line
                var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);
                return null == nextCh || dir > 0 && nextCh == line.text.length || !(res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh))) ? null : res;
            }
            function lineStart(cm, lineN) {
                var line = getLine(cm.doc, lineN), visual = visualLine(line);
                return visual != line && (lineN = lineNo(visual)), endOfLine(!0, cm, visual, lineN, 1);
            }
            function lineEnd(cm, lineN) {
                var line = getLine(cm.doc, lineN), visual = visualLineEnd(line);
                return visual != line && (lineN = lineNo(visual)), endOfLine(!0, cm, line, lineN, -1);
            }
            function lineStartSmart(cm, pos) {
                var start = lineStart(cm, pos.line), line = getLine(cm.doc, start.line), order = getOrder(line, cm.doc.direction);
                if (!order || 0 == order[0].level) {
                    var firstNonWS = Math.max(0, line.text.search(/\S/)), inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
                    return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky);
                }
                return start;
            }
            // Run a handler that was bound to a key.
            function doHandleBinding(cm, bound, dropShift) {
                if ("string" == typeof bound && (bound = commands[bound], !bound)) return !1;
                // Ensure previous input has been read, so that the handler sees a
                // consistent view of the document
                cm.display.input.ensurePolled();
                var prevShift = cm.display.shift, done = !1;
                try {
                    cm.isReadOnly() && (cm.state.suppressEdits = !0), dropShift && (cm.display.shift = !1), 
                    done = bound(cm) != Pass;
                } finally {
                    cm.display.shift = prevShift, cm.state.suppressEdits = !1;
                }
                return done;
            }
            function lookupKeyForEditor(cm, name, handle) {
                for (var i = 0; i < cm.state.keyMaps.length; i++) {
                    var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
                    if (result) return result;
                }
                return cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm) || lookupKey(name, cm.options.keyMap, handle, cm);
            }
            function dispatchKey(cm, name, e, handle) {
                var seq = cm.state.keySeq;
                if (seq) {
                    if (isModifierKey(name)) return "handled";
                    stopSeq.set(50, function() {
                        cm.state.keySeq == seq && (cm.state.keySeq = null, cm.display.input.reset());
                    }), name = seq + " " + name;
                }
                var result = lookupKeyForEditor(cm, name, handle);
                return "multi" == result && (cm.state.keySeq = name), "handled" == result && signalLater(cm, "keyHandled", cm, name, e), 
                "handled" != result && "multi" != result || (e_preventDefault(e), restartBlink(cm)), 
                seq && !result && /\'$/.test(name) ? (e_preventDefault(e), !0) : !!result;
            }
            // Handle a key from the keydown event.
            function handleKeyBinding(cm, e) {
                var name = keyName(e, !0);
                return !!name && (e.shiftKey && !cm.state.keySeq ? dispatchKey(cm, "Shift-" + name, e, function(b) {
                    return doHandleBinding(cm, b, !0);
                }) || dispatchKey(cm, name, e, function(b) {
                    if ("string" == typeof b ? /^go[A-Z]/.test(b) : b.motion) return doHandleBinding(cm, b);
                }) : dispatchKey(cm, name, e, function(b) {
                    return doHandleBinding(cm, b);
                }));
            }
            // Handle a key from the keypress event
            function handleCharBinding(cm, e, ch) {
                return dispatchKey(cm, "'" + ch + "'", e, function(b) {
                    return doHandleBinding(cm, b, !0);
                });
            }
            function onKeyDown(e) {
                var cm = this;
                if (cm.curOp.focus = activeElt(), !signalDOMEvent(cm, e)) {
                    // IE does strange things with escape.
                    ie && ie_version < 11 && 27 == e.keyCode && (e.returnValue = !1);
                    var code = e.keyCode;
                    cm.display.shift = 16 == code || e.shiftKey;
                    var handled = handleKeyBinding(cm, e);
                    presto && (lastStoppedKey = handled ? code : null, // Opera has no cut event... we try to at least catch the key combo
                    !handled && 88 == code && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey) && cm.replaceSelection("", null, "cut")), 
                    // Turn mouse into crosshair when Alt is held on Mac.
                    18 != code || /\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className) || showCrossHair(cm);
                }
            }
            function showCrossHair(cm) {
                function up(e) {
                    18 != e.keyCode && e.altKey || (rmClass(lineDiv, "CodeMirror-crosshair"), off(document, "keyup", up), 
                    off(document, "mouseover", up));
                }
                var lineDiv = cm.display.lineDiv;
                addClass(lineDiv, "CodeMirror-crosshair"), on(document, "keyup", up), on(document, "mouseover", up);
            }
            function onKeyUp(e) {
                16 == e.keyCode && (this.doc.sel.shift = !1), signalDOMEvent(this, e);
            }
            function onKeyPress(e) {
                var cm = this;
                if (!(eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey)) {
                    var keyCode = e.keyCode, charCode = e.charCode;
                    if (presto && keyCode == lastStoppedKey) return lastStoppedKey = null, void e_preventDefault(e);
                    if (!presto || e.which && !(e.which < 10) || !handleKeyBinding(cm, e)) {
                        var ch = String.fromCharCode(null == charCode ? keyCode : charCode);
                        // Some browsers fire keypress events for backspace
                        "\b" != ch && (handleCharBinding(cm, e, ch) || cm.display.input.onKeyPress(e));
                    }
                }
            }
            function clickRepeat(pos, button) {
                var now = +new Date();
                return lastDoubleClick && lastDoubleClick.compare(now, pos, button) ? (lastClick = lastDoubleClick = null, 
                "triple") : lastClick && lastClick.compare(now, pos, button) ? (lastDoubleClick = new PastClick(now, pos, button), 
                lastClick = null, "double") : (lastClick = new PastClick(now, pos, button), lastDoubleClick = null, 
                "single");
            }
            // A mouse down can be a single click, double click, triple click,
            // start of selection drag, start of text drag, new cursor
            // (ctrl-click), rectangle drag (alt-drag), or xwin
            // middle-click-paste. Or it might be a click on something we should
            // not interfere with, such as a scrollbar or widget.
            function onMouseDown(e) {
                var cm = this, display = cm.display;
                if (!(signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch())) {
                    if (display.input.ensurePolled(), display.shift = e.shiftKey, eventInWidget(display, e)) // Briefly turn off draggability, to allow widgets to do
                    // normal dragging things.
                    return void (webkit || (display.scroller.draggable = !1, setTimeout(function() {
                        return display.scroller.draggable = !0;
                    }, 100)));
                    if (!clickInGutter(cm, e)) {
                        var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : "single";
                        window.focus(), // #3261: make sure, that we're not starting a second selection
                        1 == button && cm.state.selectingText && cm.state.selectingText(e), pos && handleMappedButton(cm, button, pos, repeat, e) || (1 == button ? pos ? leftButtonDown(cm, pos, repeat, e) : e_target(e) == display.scroller && e_preventDefault(e) : 2 == button ? (pos && extendSelection(cm.doc, pos), 
                        setTimeout(function() {
                            return display.input.focus();
                        }, 20)) : 3 == button && (captureRightClick ? onContextMenu(cm, e) : delayBlurEvent(cm)));
                    }
                }
            }
            function handleMappedButton(cm, button, pos, repeat, event) {
                var name = "Click";
                return "double" == repeat ? name = "Double" + name : "triple" == repeat && (name = "Triple" + name), 
                name = (1 == button ? "Left" : 2 == button ? "Middle" : "Right") + name, dispatchKey(cm, addModifierNames(name, event), event, function(bound) {
                    if ("string" == typeof bound && (bound = commands[bound]), !bound) return !1;
                    var done = !1;
                    try {
                        cm.isReadOnly() && (cm.state.suppressEdits = !0), done = bound(cm, pos) != Pass;
                    } finally {
                        cm.state.suppressEdits = !1;
                    }
                    return done;
                });
            }
            function configureMouse(cm, repeat, event) {
                var option = cm.getOption("configureMouse"), value = option ? option(cm, repeat, event) : {};
                if (null == value.unit) {
                    var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;
                    value.unit = rect ? "rectangle" : "single" == repeat ? "char" : "double" == repeat ? "word" : "line";
                }
                return (null == value.extend || cm.doc.extend) && (value.extend = cm.doc.extend || event.shiftKey), 
                null == value.addNew && (value.addNew = mac ? event.metaKey : event.ctrlKey), null == value.moveOnDrag && (value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey)), 
                value;
            }
            function leftButtonDown(cm, pos, repeat, event) {
                ie ? setTimeout(bind(ensureFocus, cm), 0) : cm.curOp.focus = activeElt();
                var contained, behavior = configureMouse(cm, repeat, event), sel = cm.doc.sel;
                cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() && "single" == repeat && (contained = sel.contains(pos)) > -1 && (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) && (cmp(contained.to(), pos) > 0 || pos.xRel < 0) ? leftButtonStartDrag(cm, event, pos, behavior) : leftButtonSelect(cm, event, pos, behavior);
            }
            // Start a text drag. When it ends, see if any dragging actually
            // happen, and treat as a click if it didn't.
            function leftButtonStartDrag(cm, event, pos, behavior) {
                var display = cm.display, moved = !1, dragEnd = operation(cm, function(e) {
                    webkit && (display.scroller.draggable = !1), cm.state.draggingText = !1, off(document, "mouseup", dragEnd), 
                    off(document, "mousemove", mouseMove), off(display.scroller, "dragstart", dragStart), 
                    off(display.scroller, "drop", dragEnd), moved || (e_preventDefault(e), behavior.addNew || extendSelection(cm.doc, pos, null, null, behavior.extend), 
                    // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)
                    webkit || ie && 9 == ie_version ? setTimeout(function() {
                        document.body.focus(), display.input.focus();
                    }, 20) : display.input.focus());
                }), mouseMove = function(e2) {
                    moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;
                }, dragStart = function() {
                    return moved = !0;
                };
                // Let the drag handler handle this.
                webkit && (display.scroller.draggable = !0), cm.state.draggingText = dragEnd, dragEnd.copy = !behavior.moveOnDrag, 
                // IE's approach to draggable
                display.scroller.dragDrop && display.scroller.dragDrop(), on(document, "mouseup", dragEnd), 
                on(document, "mousemove", mouseMove), on(display.scroller, "dragstart", dragStart), 
                on(display.scroller, "drop", dragEnd), delayBlurEvent(cm), setTimeout(function() {
                    return display.input.focus();
                }, 20);
            }
            function rangeForUnit(cm, pos, unit) {
                if ("char" == unit) return new Range(pos, pos);
                if ("word" == unit) return cm.findWordAt(pos);
                if ("line" == unit) return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
                var result = unit(cm, pos);
                return new Range(result.from, result.to);
            }
            // Normal selection, as opposed to text dragging.
            function leftButtonSelect(cm, event, start, behavior) {
                function extendTo(pos) {
                    if (0 != cmp(lastPos, pos)) if (lastPos = pos, "rectangle" == behavior.unit) {
                        for (var ranges = [], tabSize = cm.options.tabSize, startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize), posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize), left = Math.min(startCol, posCol), right = Math.max(startCol, posCol), line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line)); line <= end; line++) {
                            var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);
                            left == right ? ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))) : text.length > leftPos && ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));
                        }
                        ranges.length || ranges.push(new Range(start, start)), setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex), {
                            origin: "*mouse",
                            scroll: !1
                        }), cm.scrollIntoView(pos);
                    } else {
                        var head, oldRange = ourRange, range$$1 = rangeForUnit(cm, pos, behavior.unit), anchor = oldRange.anchor;
                        cmp(range$$1.anchor, anchor) > 0 ? (head = range$$1.head, anchor = minPos(oldRange.from(), range$$1.anchor)) : (head = range$$1.anchor, 
                        anchor = maxPos(oldRange.to(), range$$1.head));
                        var ranges$1 = startSel.ranges.slice(0);
                        ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head)), setSelection(doc, normalizeSelection(ranges$1, ourIndex), sel_mouse);
                    }
                }
                function extend(e) {
                    var curCount = ++counter, cur = posFromMouse(cm, e, !0, "rectangle" == behavior.unit);
                    if (cur) if (0 != cmp(cur, lastPos)) {
                        cm.curOp.focus = activeElt(), extendTo(cur);
                        var visible = visibleLines(display, doc);
                        (cur.line >= visible.to || cur.line < visible.from) && setTimeout(operation(cm, function() {
                            counter == curCount && extend(e);
                        }), 150);
                    } else {
                        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
                        outside && setTimeout(operation(cm, function() {
                            counter == curCount && (display.scroller.scrollTop += outside, extend(e));
                        }), 50);
                    }
                }
                function done(e) {
                    cm.state.selectingText = !1, counter = 1 / 0, e_preventDefault(e), display.input.focus(), 
                    off(document, "mousemove", move), off(document, "mouseup", up), doc.history.lastSelOrigin = null;
                }
                var display = cm.display, doc = cm.doc;
                e_preventDefault(event);
                var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;
                if (behavior.addNew && !behavior.extend ? (ourIndex = doc.sel.contains(start), ourRange = ourIndex > -1 ? ranges[ourIndex] : new Range(start, start)) : (ourRange = doc.sel.primary(), 
                ourIndex = doc.sel.primIndex), "rectangle" == behavior.unit) behavior.addNew || (ourRange = new Range(start, start)), 
                start = posFromMouse(cm, event, !0, !0), ourIndex = -1; else {
                    var range$$1 = rangeForUnit(cm, start, behavior.unit);
                    ourRange = behavior.extend ? extendRange(ourRange, range$$1.anchor, range$$1.head, behavior.extend) : range$$1;
                }
                behavior.addNew ? ourIndex == -1 ? (ourIndex = ranges.length, setSelection(doc, normalizeSelection(ranges.concat([ ourRange ]), ourIndex), {
                    scroll: !1,
                    origin: "*mouse"
                })) : ranges.length > 1 && ranges[ourIndex].empty() && "char" == behavior.unit && !behavior.extend ? (setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0), {
                    scroll: !1,
                    origin: "*mouse"
                }), startSel = doc.sel) : replaceOneSelection(doc, ourIndex, ourRange, sel_mouse) : (ourIndex = 0, 
                setSelection(doc, new Selection([ ourRange ], 0), sel_mouse), startSel = doc.sel);
                var lastPos = start, editorSize = display.wrapper.getBoundingClientRect(), counter = 0, move = operation(cm, function(e) {
                    e_button(e) ? extend(e) : done(e);
                }), up = operation(cm, done);
                cm.state.selectingText = up, on(document, "mousemove", move), on(document, "mouseup", up);
            }
            // Used when mouse-selecting to adjust the anchor to the proper side
            // of a bidi jump depending on the visual position of the head.
            function bidiSimplify(cm, range$$1) {
                var anchor = range$$1.anchor, head = range$$1.head, anchorLine = getLine(cm.doc, anchor.line);
                if (0 == cmp(anchor, head) && anchor.sticky == head.sticky) return range$$1;
                var order = getOrder(anchorLine);
                if (!order) return range$$1;
                var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];
                if (part.from != anchor.ch && part.to != anchor.ch) return range$$1;
                var boundary = index + (part.from == anchor.ch == (1 != part.level) ? 0 : 1);
                if (0 == boundary || boundary == order.length) return range$$1;
                // Compute the relative visual position of the head compared to the
                // anchor (<0 is to the left, >0 to the right)
                var leftSide;
                if (head.line != anchor.line) leftSide = (head.line - anchor.line) * ("ltr" == cm.doc.direction ? 1 : -1) > 0; else {
                    var headIndex = getBidiPartAt(order, head.ch, head.sticky), dir = headIndex - index || (head.ch - anchor.ch) * (1 == part.level ? -1 : 1);
                    leftSide = headIndex == boundary - 1 || headIndex == boundary ? dir < 0 : dir > 0;
                }
                var usePart = order[boundary + (leftSide ? -1 : 0)], from = leftSide == (1 == usePart.level), ch = from ? usePart.from : usePart.to, sticky = from ? "after" : "before";
                return anchor.ch == ch && anchor.sticky == sticky ? range$$1 : new Range(new Pos(anchor.line, ch, sticky), head);
            }
            // Determines whether an event happened in the gutter, and fires the
            // handlers for the corresponding event.
            function gutterEvent(cm, e, type, prevent) {
                var mX, mY;
                if (e.touches) mX = e.touches[0].clientX, mY = e.touches[0].clientY; else try {
                    mX = e.clientX, mY = e.clientY;
                } catch (e) {
                    return !1;
                }
                if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) return !1;
                prevent && e_preventDefault(e);
                var display = cm.display, lineBox = display.lineDiv.getBoundingClientRect();
                if (mY > lineBox.bottom || !hasHandler(cm, type)) return e_defaultPrevented(e);
                mY -= lineBox.top - display.viewOffset;
                for (var i = 0; i < cm.options.gutters.length; ++i) {
                    var g = display.gutters.childNodes[i];
                    if (g && g.getBoundingClientRect().right >= mX) {
                        var line = lineAtHeight(cm.doc, mY), gutter = cm.options.gutters[i];
                        return signal(cm, type, cm, line, gutter, e), e_defaultPrevented(e);
                    }
                }
            }
            function clickInGutter(cm, e) {
                return gutterEvent(cm, e, "gutterClick", !0);
            }
            // CONTEXT MENU HANDLING
            // To make the context menu work, we need to briefly unhide the
            // textarea (making it as unobtrusive as possible) to let the
            // right-click take effect on it.
            function onContextMenu(cm, e) {
                eventInWidget(cm.display, e) || contextMenuInGutter(cm, e) || signalDOMEvent(cm, e, "contextmenu") || cm.display.input.onContextMenu(e);
            }
            function contextMenuInGutter(cm, e) {
                return !!hasHandler(cm, "gutterContextMenu") && gutterEvent(cm, e, "gutterContextMenu", !1);
            }
            function themeChanged(cm) {
                cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-"), 
                clearCaches(cm);
            }
            function defineOptions(CodeMirror) {
                function option(name, deflt, handle, notOnInit) {
                    CodeMirror.defaults[name] = deflt, handle && (optionHandlers[name] = notOnInit ? function(cm, val, old) {
                        old != Init && handle(cm, val, old);
                    } : handle);
                }
                var optionHandlers = CodeMirror.optionHandlers;
                CodeMirror.defineOption = option, // Passed to option handlers when there is no old value.
                CodeMirror.Init = Init, // These two are, on init, called from the constructor because they
                // have to be initialized before the editor can start at all.
                option("value", "", function(cm, val) {
                    return cm.setValue(val);
                }, !0), option("mode", null, function(cm, val) {
                    cm.doc.modeOption = val, loadMode(cm);
                }, !0), option("indentUnit", 2, loadMode, !0), option("indentWithTabs", !1), option("smartIndent", !0), 
                option("tabSize", 4, function(cm) {
                    resetModeState(cm), clearCaches(cm), regChange(cm);
                }, !0), option("lineSeparator", null, function(cm, val) {
                    if (cm.doc.lineSep = val, val) {
                        var newBreaks = [], lineNo = cm.doc.first;
                        cm.doc.iter(function(line) {
                            for (var pos = 0; ;) {
                                var found = line.text.indexOf(val, pos);
                                if (found == -1) break;
                                pos = found + val.length, newBreaks.push(Pos(lineNo, found));
                            }
                            lineNo++;
                        });
                        for (var i = newBreaks.length - 1; i >= 0; i--) replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length));
                    }
                }), option("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g, function(cm, val, old) {
                    cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g"), 
                    old != Init && cm.refresh();
                }), option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function(cm) {
                    return cm.refresh();
                }, !0), option("electricChars", !0), option("inputStyle", mobile ? "contenteditable" : "textarea", function() {
                    throw new Error("inputStyle can not (yet) be changed in a running editor");
                }, !0), option("spellcheck", !1, function(cm, val) {
                    return cm.getInputField().spellcheck = val;
                }, !0), option("rtlMoveVisually", !windows), option("wholeLineUpdateBefore", !0), 
                option("theme", "default", function(cm) {
                    themeChanged(cm), guttersChanged(cm);
                }, !0), option("keyMap", "default", function(cm, val, old) {
                    var next = getKeyMap(val), prev = old != Init && getKeyMap(old);
                    prev && prev.detach && prev.detach(cm, next), next.attach && next.attach(cm, prev || null);
                }), option("extraKeys", null), option("configureMouse", null), option("lineWrapping", !1, wrappingChanged, !0), 
                option("gutters", [], function(cm) {
                    setGuttersForLineNumbers(cm.options), guttersChanged(cm);
                }, !0), option("fixedGutter", !0, function(cm, val) {
                    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0", 
                    cm.refresh();
                }, !0), option("coverGutterNextToScrollbar", !1, function(cm) {
                    return updateScrollbars(cm);
                }, !0), option("scrollbarStyle", "native", function(cm) {
                    initScrollbars(cm), updateScrollbars(cm), cm.display.scrollbars.setScrollTop(cm.doc.scrollTop), 
                    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
                }, !0), option("lineNumbers", !1, function(cm) {
                    setGuttersForLineNumbers(cm.options), guttersChanged(cm);
                }, !0), option("firstLineNumber", 1, guttersChanged, !0), option("lineNumberFormatter", function(integer) {
                    return integer;
                }, guttersChanged, !0), option("showCursorWhenSelecting", !1, updateSelection, !0), 
                option("resetSelectionOnContextMenu", !0), option("lineWiseCopyCut", !0), option("pasteLinesPerSelection", !0), 
                option("readOnly", !1, function(cm, val) {
                    "nocursor" == val && (onBlur(cm), cm.display.input.blur()), cm.display.input.readOnlyChanged(val);
                }), option("disableInput", !1, function(cm, val) {
                    val || cm.display.input.reset();
                }, !0), option("dragDrop", !0, dragDropChanged), option("allowDropFileTypes", null), 
                option("cursorBlinkRate", 530), option("cursorScrollMargin", 0), option("cursorHeight", 1, updateSelection, !0), 
                option("singleCursorHeightPerLine", !0, updateSelection, !0), option("workTime", 100), 
                option("workDelay", 100), option("flattenSpans", !0, resetModeState, !0), option("addModeClass", !1, resetModeState, !0), 
                option("pollInterval", 100), option("undoDepth", 200, function(cm, val) {
                    return cm.doc.history.undoDepth = val;
                }), option("historyEventDelay", 1250), option("viewportMargin", 10, function(cm) {
                    return cm.refresh();
                }, !0), option("maxHighlightLength", 1e4, resetModeState, !0), option("moveInputWithCursor", !0, function(cm, val) {
                    val || cm.display.input.resetPosition();
                }), option("tabindex", null, function(cm, val) {
                    return cm.display.input.getField().tabIndex = val || "";
                }), option("autofocus", null), option("direction", "ltr", function(cm, val) {
                    return cm.doc.setDirection(val);
                }, !0);
            }
            function guttersChanged(cm) {
                updateGutters(cm), regChange(cm), alignHorizontally(cm);
            }
            function dragDropChanged(cm, value, old) {
                var wasOn = old && old != Init;
                if (!value != !wasOn) {
                    var funcs = cm.display.dragFunctions, toggle = value ? on : off;
                    toggle(cm.display.scroller, "dragstart", funcs.start), toggle(cm.display.scroller, "dragenter", funcs.enter), 
                    toggle(cm.display.scroller, "dragover", funcs.over), toggle(cm.display.scroller, "dragleave", funcs.leave), 
                    toggle(cm.display.scroller, "drop", funcs.drop);
                }
            }
            function wrappingChanged(cm) {
                cm.options.lineWrapping ? (addClass(cm.display.wrapper, "CodeMirror-wrap"), cm.display.sizer.style.minWidth = "", 
                cm.display.sizerWidth = null) : (rmClass(cm.display.wrapper, "CodeMirror-wrap"), 
                findMaxLine(cm)), estimateLineHeights(cm), regChange(cm), clearCaches(cm), setTimeout(function() {
                    return updateScrollbars(cm);
                }, 100);
            }
            // A CodeMirror instance represents an editor. This is the object
            // that user code is usually dealing with.
            function CodeMirror$1(place, options) {
                var this$1 = this;
                if (!(this instanceof CodeMirror$1)) return new CodeMirror$1(place, options);
                this.options = options = options ? copyObj(options) : {}, // Determine effective options based on given values and defaults.
                copyObj(defaults, options, !1), setGuttersForLineNumbers(options);
                var doc = options.value;
                "string" == typeof doc && (doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction)), 
                this.doc = doc;
                var input = new CodeMirror$1.inputStyles[options.inputStyle](this), display = this.display = new Display(place, doc, input);
                display.wrapper.CodeMirror = this, updateGutters(this), themeChanged(this), options.lineWrapping && (this.display.wrapper.className += " CodeMirror-wrap"), 
                initScrollbars(this), this.state = {
                    keyMaps: [],
                    // stores maps added by addKeyMap
                    overlays: [],
                    // highlighting overlays, as added by addOverlay
                    modeGen: 0,
                    // bumped when mode/overlay changes, used to invalidate highlighting info
                    overwrite: !1,
                    delayingBlurEvent: !1,
                    focused: !1,
                    suppressEdits: !1,
                    // used to disable editing during key handlers when in readOnly mode
                    pasteIncoming: !1,
                    cutIncoming: !1,
                    // help recognize paste/cut edits in input.poll
                    selectingText: !1,
                    draggingText: !1,
                    highlight: new Delayed(),
                    // stores highlight worker timeout
                    keySeq: null,
                    // Unfinished key sequence
                    specialChars: null
                }, options.autofocus && !mobile && display.input.focus(), // Override magic textarea content restore that IE sometimes does
                // on our hidden textarea on reload
                ie && ie_version < 11 && setTimeout(function() {
                    return this$1.display.input.reset(!0);
                }, 20), registerEventHandlers(this), ensureGlobalHandlers(), startOperation(this), 
                this.curOp.forceUpdate = !0, attachDoc(this, doc), options.autofocus && !mobile || this.hasFocus() ? setTimeout(bind(onFocus, this), 20) : onBlur(this);
                for (var opt in optionHandlers) optionHandlers.hasOwnProperty(opt) && optionHandlers[opt](this$1, options[opt], Init);
                maybeUpdateLineNumberWidth(this), options.finishInit && options.finishInit(this);
                for (var i = 0; i < initHooks.length; ++i) initHooks[i](this$1);
                endOperation(this), // Suppress optimizelegibility in Webkit, since it breaks text
                // measuring on line wrapping boundaries.
                webkit && options.lineWrapping && "optimizelegibility" == getComputedStyle(display.lineDiv).textRendering && (display.lineDiv.style.textRendering = "auto");
            }
            // Attach the necessary event handlers when initializing the editor
            function registerEventHandlers(cm) {
                function finishTouch() {
                    d.activeTouch && (touchFinished = setTimeout(function() {
                        return d.activeTouch = null;
                    }, 1e3), prevTouch = d.activeTouch, prevTouch.end = +new Date());
                }
                function isMouseLikeTouchEvent(e) {
                    if (1 != e.touches.length) return !1;
                    var touch = e.touches[0];
                    return touch.radiusX <= 1 && touch.radiusY <= 1;
                }
                function farAway(touch, other) {
                    if (null == other.left) return !0;
                    var dx = other.left - touch.left, dy = other.top - touch.top;
                    return dx * dx + dy * dy > 400;
                }
                var d = cm.display;
                on(d.scroller, "mousedown", operation(cm, onMouseDown)), // Older IE's will not fire a second mousedown for a double click
                ie && ie_version < 11 ? on(d.scroller, "dblclick", operation(cm, function(e) {
                    if (!signalDOMEvent(cm, e)) {
                        var pos = posFromMouse(cm, e);
                        if (pos && !clickInGutter(cm, e) && !eventInWidget(cm.display, e)) {
                            e_preventDefault(e);
                            var word = cm.findWordAt(pos);
                            extendSelection(cm.doc, word.anchor, word.head);
                        }
                    }
                })) : on(d.scroller, "dblclick", function(e) {
                    return signalDOMEvent(cm, e) || e_preventDefault(e);
                }), // Some browsers fire contextmenu *after* opening the menu, at
                // which point we can't mess with it anymore. Context menu is
                // handled in onMouseDown for these browsers.
                captureRightClick || on(d.scroller, "contextmenu", function(e) {
                    return onContextMenu(cm, e);
                });
                // Used to suppress mouse event handling when a touch happens
                var touchFinished, prevTouch = {
                    end: 0
                };
                on(d.scroller, "touchstart", function(e) {
                    if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {
                        d.input.ensurePolled(), clearTimeout(touchFinished);
                        var now = +new Date();
                        d.activeTouch = {
                            start: now,
                            moved: !1,
                            prev: now - prevTouch.end <= 300 ? prevTouch : null
                        }, 1 == e.touches.length && (d.activeTouch.left = e.touches[0].pageX, d.activeTouch.top = e.touches[0].pageY);
                    }
                }), on(d.scroller, "touchmove", function() {
                    d.activeTouch && (d.activeTouch.moved = !0);
                }), on(d.scroller, "touchend", function(e) {
                    var touch = d.activeTouch;
                    if (touch && !eventInWidget(d, e) && null != touch.left && !touch.moved && new Date() - touch.start < 300) {
                        var range, pos = cm.coordsChar(d.activeTouch, "page");
                        range = !touch.prev || farAway(touch, touch.prev) ? new Range(pos, pos) : !touch.prev.prev || farAway(touch, touch.prev.prev) ? cm.findWordAt(pos) : new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))), 
                        cm.setSelection(range.anchor, range.head), cm.focus(), e_preventDefault(e);
                    }
                    finishTouch();
                }), on(d.scroller, "touchcancel", finishTouch), // Sync scrolling between fake scrollbars and real scrollable
                // area, ensure viewport is updated when scrolling.
                on(d.scroller, "scroll", function() {
                    d.scroller.clientHeight && (updateScrollTop(cm, d.scroller.scrollTop), setScrollLeft(cm, d.scroller.scrollLeft, !0), 
                    signal(cm, "scroll", cm));
                }), // Listen to wheel events in order to try and update the viewport on time.
                on(d.scroller, "mousewheel", function(e) {
                    return onScrollWheel(cm, e);
                }), on(d.scroller, "DOMMouseScroll", function(e) {
                    return onScrollWheel(cm, e);
                }), // Prevent wrapper from ever scrolling
                on(d.wrapper, "scroll", function() {
                    return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0;
                }), d.dragFunctions = {
                    enter: function(e) {
                        signalDOMEvent(cm, e) || e_stop(e);
                    },
                    over: function(e) {
                        signalDOMEvent(cm, e) || (onDragOver(cm, e), e_stop(e));
                    },
                    start: function(e) {
                        return onDragStart(cm, e);
                    },
                    drop: operation(cm, onDrop),
                    leave: function(e) {
                        signalDOMEvent(cm, e) || clearDragCursor(cm);
                    }
                };
                var inp = d.input.getField();
                on(inp, "keyup", function(e) {
                    return onKeyUp.call(cm, e);
                }), on(inp, "keydown", operation(cm, onKeyDown)), on(inp, "keypress", operation(cm, onKeyPress)), 
                on(inp, "focus", function(e) {
                    return onFocus(cm, e);
                }), on(inp, "blur", function(e) {
                    return onBlur(cm, e);
                });
            }
            // Indent the given line. The how parameter can be "smart",
            // "add"/null, "subtract", or "prev". When aggressive is false
            // (typically set to true for forced single-line indents), empty
            // lines are not indented, and places where the mode returns Pass
            // are left alone.
            function indentLine(cm, n, how, aggressive) {
                var state, doc = cm.doc;
                null == how && (how = "add"), "smart" == how && (// Fall back to "prev" when the mode doesn't have an indentation
                // method.
                doc.mode.indent ? state = getContextBefore(cm, n).state : how = "prev");
                var tabSize = cm.options.tabSize, line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
                line.stateAfter && (line.stateAfter = null);
                var indentation, curSpaceString = line.text.match(/^\s*/)[0];
                if (aggressive || /\S/.test(line.text)) {
                    if ("smart" == how && (indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text), 
                    indentation == Pass || indentation > 150)) {
                        if (!aggressive) return;
                        how = "prev";
                    }
                } else indentation = 0, how = "not";
                "prev" == how ? indentation = n > doc.first ? countColumn(getLine(doc, n - 1).text, null, tabSize) : 0 : "add" == how ? indentation = curSpace + cm.options.indentUnit : "subtract" == how ? indentation = curSpace - cm.options.indentUnit : "number" == typeof how && (indentation = curSpace + how), 
                indentation = Math.max(0, indentation);
                var indentString = "", pos = 0;
                if (cm.options.indentWithTabs) for (var i = Math.floor(indentation / tabSize); i; --i) pos += tabSize, 
                indentString += "\t";
                if (pos < indentation && (indentString += spaceStr(indentation - pos)), indentString != curSpaceString) return replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input"), 
                line.stateAfter = null, !0;
                // Ensure that, if the cursor was in the whitespace at the start
                // of the line, it is moved to the end of that space.
                for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {
                    var range = doc.sel.ranges[i$1];
                    if (range.head.line == n && range.head.ch < curSpaceString.length) {
                        var pos$1 = Pos(n, curSpaceString.length);
                        replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));
                        break;
                    }
                }
            }
            function setLastCopied(newLastCopied) {
                lastCopied = newLastCopied;
            }
            function applyTextInput(cm, inserted, deleted, sel, origin) {
                var doc = cm.doc;
                cm.display.shift = !1, sel || (sel = doc.sel);
                var paste = cm.state.pasteIncoming || "paste" == origin, textLines = splitLinesAuto(inserted), multiPaste = null;
                // When pasing N lines into N selections, insert one line per selection
                if (paste && sel.ranges.length > 1) if (lastCopied && lastCopied.text.join("\n") == inserted) {
                    if (sel.ranges.length % lastCopied.text.length == 0) {
                        multiPaste = [];
                        for (var i = 0; i < lastCopied.text.length; i++) multiPaste.push(doc.splitLines(lastCopied.text[i]));
                    }
                } else textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection && (multiPaste = map(textLines, function(l) {
                    return [ l ];
                }));
                // Normal behavior is to insert the new text into every selection
                for (var updateInput, i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {
                    var range$$1 = sel.ranges[i$1], from = range$$1.from(), to = range$$1.to();
                    range$$1.empty() && (deleted && deleted > 0 ? from = Pos(from.line, from.ch - deleted) : cm.state.overwrite && !paste ? to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)) : lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == inserted && (from = to = Pos(from.line, 0))), 
                    updateInput = cm.curOp.updateInput;
                    var changeEvent = {
                        from: from,
                        to: to,
                        text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,
                        origin: origin || (paste ? "paste" : cm.state.cutIncoming ? "cut" : "+input")
                    };
                    makeChange(cm.doc, changeEvent), signalLater(cm, "inputRead", cm, changeEvent);
                }
                inserted && !paste && triggerElectric(cm, inserted), ensureCursorVisible(cm), cm.curOp.updateInput = updateInput, 
                cm.curOp.typing = !0, cm.state.pasteIncoming = cm.state.cutIncoming = !1;
            }
            function handlePaste(e, cm) {
                var pasted = e.clipboardData && e.clipboardData.getData("Text");
                if (pasted) return e.preventDefault(), cm.isReadOnly() || cm.options.disableInput || runInOp(cm, function() {
                    return applyTextInput(cm, pasted, 0, null, "paste");
                }), !0;
            }
            function triggerElectric(cm, inserted) {
                // When an 'electric' character is inserted, immediately trigger a reindent
                if (cm.options.electricChars && cm.options.smartIndent) for (var sel = cm.doc.sel, i = sel.ranges.length - 1; i >= 0; i--) {
                    var range$$1 = sel.ranges[i];
                    if (!(range$$1.head.ch > 100 || i && sel.ranges[i - 1].head.line == range$$1.head.line)) {
                        var mode = cm.getModeAt(range$$1.head), indented = !1;
                        if (mode.electricChars) {
                            for (var j = 0; j < mode.electricChars.length; j++) if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
                                indented = indentLine(cm, range$$1.head.line, "smart");
                                break;
                            }
                        } else mode.electricInput && mode.electricInput.test(getLine(cm.doc, range$$1.head.line).text.slice(0, range$$1.head.ch)) && (indented = indentLine(cm, range$$1.head.line, "smart"));
                        indented && signalLater(cm, "electricInput", cm, range$$1.head.line);
                    }
                }
            }
            function copyableRanges(cm) {
                for (var text = [], ranges = [], i = 0; i < cm.doc.sel.ranges.length; i++) {
                    var line = cm.doc.sel.ranges[i].head.line, lineRange = {
                        anchor: Pos(line, 0),
                        head: Pos(line + 1, 0)
                    };
                    ranges.push(lineRange), text.push(cm.getRange(lineRange.anchor, lineRange.head));
                }
                return {
                    text: text,
                    ranges: ranges
                };
            }
            function disableBrowserMagic(field, spellcheck) {
                field.setAttribute("autocorrect", "off"), field.setAttribute("autocapitalize", "off"), 
                field.setAttribute("spellcheck", !!spellcheck);
            }
            function hiddenTextarea() {
                var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"), div = elt("div", [ te ], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
                // The textarea is kept positioned near the cursor to prevent the
                // fact that it'll be scrolled into view on input from scrolling
                // our fake cursor out of view. On webkit, when wrap=off, paste is
                // very slow. So make the area wide instead.
                // If border: 0; -- iOS fails to open keyboard (issue #1287)
                return webkit ? te.style.width = "1000px" : te.setAttribute("wrap", "off"), ios && (te.style.border = "1px solid black"), 
                disableBrowserMagic(te), div;
            }
            // Used for horizontal relative motion. Dir is -1 or 1 (left or
            // right), unit can be "char", "column" (like char, but doesn't
            // cross line boundaries), "word" (across next word), or "group" (to
            // the start of next group of word or non-word-non-whitespace
            // chars). The visually param controls whether, in right-to-left
            // text, direction 1 means to move towards the next index in the
            // string, or towards the character to the right of the current
            // position. The resulting position will have a hitSide=true
            // property if it reached the end of the document.
            function findPosH(doc, pos, dir, unit, visually) {
                function findNextLine() {
                    var l = pos.line + dir;
                    return !(l < doc.first || l >= doc.first + doc.size) && (pos = new Pos(l, pos.ch, pos.sticky), 
                    lineObj = getLine(doc, l));
                }
                function moveOnce(boundToLine) {
                    var next;
                    if (next = visually ? moveVisually(doc.cm, lineObj, pos, dir) : moveLogically(lineObj, pos, dir), 
                    null == next) {
                        if (boundToLine || !findNextLine()) return !1;
                        pos = endOfLine(visually, doc.cm, lineObj, pos.line, dir);
                    } else pos = next;
                    return !0;
                }
                var oldPos = pos, origDir = dir, lineObj = getLine(doc, pos.line);
                if ("char" == unit) moveOnce(); else if ("column" == unit) moveOnce(!0); else if ("word" == unit || "group" == unit) for (var sawType = null, group = "group" == unit, helper = doc.cm && doc.cm.getHelper(pos, "wordChars"), first = !0; !(dir < 0) || moveOnce(!first); first = !1) {
                    var cur = lineObj.text.charAt(pos.ch) || "\n", type = isWordChar(cur, helper) ? "w" : group && "\n" == cur ? "n" : !group || /\s/.test(cur) ? null : "p";
                    if (!group || first || type || (type = "s"), sawType && sawType != type) {
                        dir < 0 && (dir = 1, moveOnce(), pos.sticky = "after");
                        break;
                    }
                    if (type && (sawType = type), dir > 0 && !moveOnce(!first)) break;
                }
                var result = skipAtomic(doc, pos, oldPos, origDir, !0);
                return equalCursorPos(oldPos, result) && (result.hitSide = !0), result;
            }
            // For relative vertical movement. Dir may be -1 or 1. Unit can be
            // "page" or "line". The resulting position will have a hitSide=true
            // property if it reached the end of the document.
            function findPosV(cm, pos, dir, unit) {
                var y, doc = cm.doc, x = pos.left;
                if ("page" == unit) {
                    var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight), moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);
                    y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;
                } else "line" == unit && (y = dir > 0 ? pos.bottom + 3 : pos.top - 3);
                for (var target; target = coordsChar(cm, x, y), target.outside; ) {
                    if (dir < 0 ? y <= 0 : y >= doc.height) {
                        target.hitSide = !0;
                        break;
                    }
                    y += 5 * dir;
                }
                return target;
            }
            function posToDOM(cm, pos) {
                var view = findViewForLine(cm, pos.line);
                if (!view || view.hidden) return null;
                var line = getLine(cm.doc, pos.line), info = mapFromLineView(view, line, pos.line), order = getOrder(line, cm.doc.direction), side = "left";
                if (order) {
                    var partPos = getBidiPartAt(order, pos.ch);
                    side = partPos % 2 ? "right" : "left";
                }
                var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
                return result.offset = "right" == result.collapse ? result.end : result.start, result;
            }
            function isInGutter(node) {
                for (var scan = node; scan; scan = scan.parentNode) if (/CodeMirror-gutter-wrapper/.test(scan.className)) return !0;
                return !1;
            }
            function badPos(pos, bad) {
                return bad && (pos.bad = !0), pos;
            }
            function domTextBetween(cm, from, to, fromLine, toLine) {
                function recognizeMarker(id) {
                    return function(marker) {
                        return marker.id == id;
                    };
                }
                function close() {
                    closing && (text += lineSep, closing = !1);
                }
                function addText(str) {
                    str && (close(), text += str);
                }
                function walk(node) {
                    if (1 == node.nodeType) {
                        var cmText = node.getAttribute("cm-text");
                        if (null != cmText) return void addText(cmText || node.textContent.replace(/\u200b/g, ""));
                        var range$$1, markerID = node.getAttribute("cm-marker");
                        if (markerID) {
                            var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
                            return void (found.length && (range$$1 = found[0].find(0)) && addText(getBetween(cm.doc, range$$1.from, range$$1.to).join(lineSep)));
                        }
                        if ("false" == node.getAttribute("contenteditable")) return;
                        var isBlock = /^(pre|div|p)$/i.test(node.nodeName);
                        isBlock && close();
                        for (var i = 0; i < node.childNodes.length; i++) walk(node.childNodes[i]);
                        isBlock && (closing = !0);
                    } else 3 == node.nodeType && addText(node.nodeValue);
                }
                for (var text = "", closing = !1, lineSep = cm.doc.lineSeparator(); walk(from), 
                from != to; ) from = from.nextSibling;
                return text;
            }
            function domToPos(cm, node, offset) {
                var lineNode;
                if (node == cm.display.lineDiv) {
                    if (lineNode = cm.display.lineDiv.childNodes[offset], !lineNode) return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), !0);
                    node = null, offset = 0;
                } else for (lineNode = node; ;lineNode = lineNode.parentNode) {
                    if (!lineNode || lineNode == cm.display.lineDiv) return null;
                    if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) break;
                }
                for (var i = 0; i < cm.display.view.length; i++) {
                    var lineView = cm.display.view[i];
                    if (lineView.node == lineNode) return locateNodeInLineView(lineView, node, offset);
                }
            }
            function locateNodeInLineView(lineView, node, offset) {
                function find(textNode, topNode, offset) {
                    for (var i = -1; i < (maps ? maps.length : 0); i++) for (var map$$1 = i < 0 ? measure.map : maps[i], j = 0; j < map$$1.length; j += 3) {
                        var curNode = map$$1[j + 2];
                        if (curNode == textNode || curNode == topNode) {
                            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]), ch = map$$1[j] + offset;
                            return (offset < 0 || curNode != textNode) && (ch = map$$1[j + (offset ? 1 : 0)]), 
                            Pos(line, ch);
                        }
                    }
                }
                var wrapper = lineView.text.firstChild, bad = !1;
                if (!node || !contains(wrapper, node)) return badPos(Pos(lineNo(lineView.line), 0), !0);
                if (node == wrapper && (bad = !0, node = wrapper.childNodes[offset], offset = 0, 
                !node)) {
                    var line = lineView.rest ? lst(lineView.rest) : lineView.line;
                    return badPos(Pos(lineNo(line), line.text.length), bad);
                }
                var textNode = 3 == node.nodeType ? node : null, topNode = node;
                for (textNode || 1 != node.childNodes.length || 3 != node.firstChild.nodeType || (textNode = node.firstChild, 
                offset && (offset = textNode.nodeValue.length)); topNode.parentNode != wrapper; ) topNode = topNode.parentNode;
                var measure = lineView.measure, maps = measure.maps, found = find(textNode, topNode, offset);
                if (found) return badPos(found, bad);
                // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems
                for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
                    if (found = find(after, after.firstChild, 0)) return badPos(Pos(found.line, found.ch - dist), bad);
                    dist += after.textContent.length;
                }
                for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {
                    if (found = find(before, before.firstChild, -1)) return badPos(Pos(found.line, found.ch + dist$1), bad);
                    dist$1 += before.textContent.length;
                }
            }
            function fromTextArea(textarea, options) {
                function save() {
                    textarea.value = cm.getValue();
                }
                // Set autofocus to true if this textarea is focused, or if it has
                // autofocus and no other element is focused.
                if (options = options ? copyObj(options) : {}, options.value = textarea.value, !options.tabindex && textarea.tabIndex && (options.tabindex = textarea.tabIndex), 
                !options.placeholder && textarea.placeholder && (options.placeholder = textarea.placeholder), 
                null == options.autofocus) {
                    var hasFocus = activeElt();
                    options.autofocus = hasFocus == textarea || null != textarea.getAttribute("autofocus") && hasFocus == document.body;
                }
                var realSubmit;
                if (textarea.form && (on(textarea.form, "submit", save), !options.leaveSubmitMethodAlone)) {
                    var form = textarea.form;
                    realSubmit = form.submit;
                    try {
                        var wrappedSubmit = form.submit = function() {
                            save(), form.submit = realSubmit, form.submit(), form.submit = wrappedSubmit;
                        };
                    } catch (e) {}
                }
                options.finishInit = function(cm) {
                    cm.save = save, cm.getTextArea = function() {
                        return textarea;
                    }, cm.toTextArea = function() {
                        cm.toTextArea = isNaN, // Prevent this from being ran twice
                        save(), textarea.parentNode.removeChild(cm.getWrapperElement()), textarea.style.display = "", 
                        textarea.form && (off(textarea.form, "submit", save), "function" == typeof textarea.form.submit && (textarea.form.submit = realSubmit));
                    };
                }, textarea.style.display = "none";
                var cm = CodeMirror$1(function(node) {
                    return textarea.parentNode.insertBefore(node, textarea.nextSibling);
                }, options);
                return cm;
            }
            function addLegacyProps(CodeMirror) {
                CodeMirror.off = off, CodeMirror.on = on, CodeMirror.wheelEventPixels = wheelEventPixels, 
                CodeMirror.Doc = Doc, CodeMirror.splitLines = splitLinesAuto, CodeMirror.countColumn = countColumn, 
                CodeMirror.findColumn = findColumn, CodeMirror.isWordChar = isWordCharBasic, CodeMirror.Pass = Pass, 
                CodeMirror.signal = signal, CodeMirror.Line = Line, CodeMirror.changeEnd = changeEnd, 
                CodeMirror.scrollbarModel = scrollbarModel, CodeMirror.Pos = Pos, CodeMirror.cmpPos = cmp, 
                CodeMirror.modes = modes, CodeMirror.mimeModes = mimeModes, CodeMirror.resolveMode = resolveMode, 
                CodeMirror.getMode = getMode, CodeMirror.modeExtensions = modeExtensions, CodeMirror.extendMode = extendMode, 
                CodeMirror.copyState = copyState, CodeMirror.startState = startState, CodeMirror.innerMode = innerMode, 
                CodeMirror.commands = commands, CodeMirror.keyMap = keyMap, CodeMirror.keyName = keyName, 
                CodeMirror.isModifierKey = isModifierKey, CodeMirror.lookupKey = lookupKey, CodeMirror.normalizeKeyMap = normalizeKeyMap, 
                CodeMirror.StringStream = StringStream, CodeMirror.SharedTextMarker = SharedTextMarker, 
                CodeMirror.TextMarker = TextMarker, CodeMirror.LineWidget = LineWidget, CodeMirror.e_preventDefault = e_preventDefault, 
                CodeMirror.e_stopPropagation = e_stopPropagation, CodeMirror.e_stop = e_stop, CodeMirror.addClass = addClass, 
                CodeMirror.contains = contains, CodeMirror.rmClass = rmClass, CodeMirror.keyNames = keyNames;
            }
            // Kludges for bugs and behavior differences that can't be feature
            // detected are enabled based on userAgent etc sniffing.
            var userAgent = navigator.userAgent, platform = navigator.platform, gecko = /gecko\/\d/i.test(userAgent), ie_upto10 = /MSIE \d/.test(userAgent), ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent), edge = /Edge\/(\d+)/.exec(userAgent), ie = ie_upto10 || ie_11up || edge, ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]), webkit = !edge && /WebKit\//.test(userAgent), qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent), chrome = !edge && /Chrome\//.test(userAgent), presto = /Opera\//.test(userAgent), safari = /Apple Computer/.test(navigator.vendor), mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent), phantom = /PhantomJS/.test(userAgent), ios = !edge && /AppleWebKit/.test(userAgent) && /Mobile\/\w+/.test(userAgent), android = /Android/.test(userAgent), mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent), mac = ios || /Mac/.test(platform), chromeOS = /\bCrOS\b/.test(userAgent), windows = /win/i.test(platform), presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
            presto_version && (presto_version = Number(presto_version[1])), presto_version && presto_version >= 15 && (presto = !1, 
            webkit = !0);
            // Some browsers use the wrong event properties to signal cmd/ctrl on OS X
            var range, flipCtrlCmd = mac && (qtwebkit || presto && (null == presto_version || presto_version < 12.11)), captureRightClick = gecko || ie && ie_version >= 9, rmClass = function(node, cls) {
                var current = node.className, match = classTest(cls).exec(current);
                if (match) {
                    var after = current.slice(match.index + match[0].length);
                    node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
                }
            };
            range = document.createRange ? function(node, start, end, endNode) {
                var r = document.createRange();
                return r.setEnd(endNode || node, end), r.setStart(node, start), r;
            } : function(node, start, end) {
                var r = document.body.createTextRange();
                try {
                    r.moveToElementText(node.parentNode);
                } catch (e) {
                    return r;
                }
                return r.collapse(!0), r.moveEnd("character", end), r.moveStart("character", start), 
                r;
            };
            var selectInput = function(node) {
                node.select();
            };
            ios ? selectInput = function(node) {
                node.selectionStart = 0, node.selectionEnd = node.value.length;
            } : ie && (selectInput = function(node) {
                try {
                    node.select();
                } catch (_e) {}
            });
            var Delayed = function() {
                this.id = null;
            };
            Delayed.prototype.set = function(ms, f) {
                clearTimeout(this.id), this.id = setTimeout(f, ms);
            };
            // Number of pixels added to scroller and sizer to hide scrollbar
            var zwspSupported, badBidiRects, scrollerGap = 30, Pass = {
                toString: function() {
                    return "CodeMirror.Pass";
                }
            }, sel_dontScroll = {
                scroll: !1
            }, sel_mouse = {
                origin: "*mouse"
            }, sel_move = {
                origin: "+move"
            }, spaceStrs = [ "" ], nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/, extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/, sawReadOnlySpans = !1, sawCollapsedSpans = !1, bidiOther = null, bidiOrdering = function() {
                function charType(code) {
                    return code <= 247 ? lowTypes.charAt(code) : 1424 <= code && code <= 1524 ? "R" : 1536 <= code && code <= 1785 ? arabicTypes.charAt(code - 1536) : 1774 <= code && code <= 2220 ? "r" : 8192 <= code && code <= 8203 ? "w" : 8204 == code ? "b" : "L";
                }
                function BidiSpan(level, from, to) {
                    this.level = level, this.from = from, this.to = to;
                }
                // Character types for codepoints 0 to 0xff
                var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN", arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111", bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/, isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
                return function(str, direction) {
                    var outerType = "ltr" == direction ? "L" : "R";
                    if (0 == str.length || "ltr" == direction && !bidiRE.test(str)) return !1;
                    for (var len = str.length, types = [], i = 0; i < len; ++i) types.push(charType(str.charCodeAt(i)));
                    // W1. Examine each non-spacing mark (NSM) in the level run, and
                    // change the type of the NSM to the type of the previous
                    // character. If the NSM is at the start of the level run, it will
                    // get the type of sor.
                    for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {
                        var type = types[i$1];
                        "m" == type ? types[i$1] = prev : prev = type;
                    }
                    // W2. Search backwards from each instance of a European number
                    // until the first strong type (R, L, AL, or sor) is found. If an
                    // AL is found, change the type of the European number to Arabic
                    // number.
                    // W3. Change all ALs to R.
                    for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {
                        var type$1 = types[i$2];
                        "1" == type$1 && "r" == cur ? types[i$2] = "n" : isStrong.test(type$1) && (cur = type$1, 
                        "r" == type$1 && (types[i$2] = "R"));
                    }
                    // W4. A single European separator between two European numbers
                    // changes to a European number. A single common separator between
                    // two numbers of the same type changes to that type.
                    for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {
                        var type$2 = types[i$3];
                        "+" == type$2 && "1" == prev$1 && "1" == types[i$3 + 1] ? types[i$3] = "1" : "," != type$2 || prev$1 != types[i$3 + 1] || "1" != prev$1 && "n" != prev$1 || (types[i$3] = prev$1), 
                        prev$1 = type$2;
                    }
                    // W5. A sequence of European terminators adjacent to European
                    // numbers changes to all European numbers.
                    // W6. Otherwise, separators and terminators change to Other
                    // Neutral.
                    for (var i$4 = 0; i$4 < len; ++i$4) {
                        var type$3 = types[i$4];
                        if ("," == type$3) types[i$4] = "N"; else if ("%" == type$3) {
                            var end = void 0;
                            for (end = i$4 + 1; end < len && "%" == types[end]; ++end) ;
                            for (var replace = i$4 && "!" == types[i$4 - 1] || end < len && "1" == types[end] ? "1" : "N", j = i$4; j < end; ++j) types[j] = replace;
                            i$4 = end - 1;
                        }
                    }
                    // W7. Search backwards from each instance of a European number
                    // until the first strong type (R, L, or sor) is found. If an L is
                    // found, then change the type of the European number to L.
                    for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
                        var type$4 = types[i$5];
                        "L" == cur$1 && "1" == type$4 ? types[i$5] = "L" : isStrong.test(type$4) && (cur$1 = type$4);
                    }
                    // N1. A sequence of neutrals takes the direction of the
                    // surrounding strong text if the text on both sides has the same
                    // direction. European and Arabic numbers act as if they were R in
                    // terms of their influence on neutrals. Start-of-level-run (sor)
                    // and end-of-level-run (eor) are used at level run boundaries.
                    // N2. Any remaining neutrals take the embedding direction.
                    for (var i$6 = 0; i$6 < len; ++i$6) if (isNeutral.test(types[i$6])) {
                        var end$1 = void 0;
                        for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) ;
                        for (var before = "L" == (i$6 ? types[i$6 - 1] : outerType), after = "L" == (end$1 < len ? types[end$1] : outerType), replace$1 = before == after ? before ? "L" : "R" : outerType, j$1 = i$6; j$1 < end$1; ++j$1) types[j$1] = replace$1;
                        i$6 = end$1 - 1;
                    }
                    for (var m, order = [], i$7 = 0; i$7 < len; ) if (countsAsLeft.test(types[i$7])) {
                        var start = i$7;
                        for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) ;
                        order.push(new BidiSpan(0, start, i$7));
                    } else {
                        var pos = i$7, at = order.length;
                        for (++i$7; i$7 < len && "L" != types[i$7]; ++i$7) ;
                        for (var j$2 = pos; j$2 < i$7; ) if (countsAsNum.test(types[j$2])) {
                            pos < j$2 && order.splice(at, 0, new BidiSpan(1, pos, j$2));
                            var nstart = j$2;
                            for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) ;
                            order.splice(at, 0, new BidiSpan(2, nstart, j$2)), pos = j$2;
                        } else ++j$2;
                        pos < i$7 && order.splice(at, 0, new BidiSpan(1, pos, i$7));
                    }
                    return "ltr" == direction && (1 == order[0].level && (m = str.match(/^\s+/)) && (order[0].from = m[0].length, 
                    order.unshift(new BidiSpan(0, 0, m[0].length))), 1 == lst(order).level && (m = str.match(/\s+$/)) && (lst(order).to -= m[0].length, 
                    order.push(new BidiSpan(0, len - m[0].length, len)))), "rtl" == direction ? order.reverse() : order;
                };
            }(), noHandlers = [], on = function(emitter, type, f) {
                if (emitter.addEventListener) emitter.addEventListener(type, f, !1); else if (emitter.attachEvent) emitter.attachEvent("on" + type, f); else {
                    var map$$1 = emitter._handlers || (emitter._handlers = {});
                    map$$1[type] = (map$$1[type] || noHandlers).concat(f);
                }
            }, dragAndDrop = function() {
                // There is *some* kind of drag-and-drop support in IE6-8, but I
                // couldn't get it to work yet.
                if (ie && ie_version < 9) return !1;
                var div = elt("div");
                return "draggable" in div || "dragDrop" in div;
            }(), splitLinesAuto = 3 != "\n\nb".split(/\n/).length ? function(string) {
                for (var pos = 0, result = [], l = string.length; pos <= l; ) {
                    var nl = string.indexOf("\n", pos);
                    nl == -1 && (nl = string.length);
                    var line = string.slice(pos, "\r" == string.charAt(nl - 1) ? nl - 1 : nl), rt = line.indexOf("\r");
                    rt != -1 ? (result.push(line.slice(0, rt)), pos += rt + 1) : (result.push(line), 
                    pos = nl + 1);
                }
                return result;
            } : function(string) {
                return string.split(/\r\n?|\n/);
            }, hasSelection = window.getSelection ? function(te) {
                try {
                    return te.selectionStart != te.selectionEnd;
                } catch (e) {
                    return !1;
                }
            } : function(te) {
                var range$$1;
                try {
                    range$$1 = te.ownerDocument.selection.createRange();
                } catch (e) {}
                return !(!range$$1 || range$$1.parentElement() != te) && 0 != range$$1.compareEndPoints("StartToEnd", range$$1);
            }, hasCopyEvent = function() {
                var e = elt("div");
                return "oncopy" in e || (e.setAttribute("oncopy", "return;"), "function" == typeof e.oncopy);
            }(), badZoomedRects = null, modes = {}, mimeModes = {}, modeExtensions = {}, StringStream = function(string, tabSize, lineOracle) {
                this.pos = this.start = 0, this.string = string, this.tabSize = tabSize || 8, this.lastColumnPos = this.lastColumnValue = 0, 
                this.lineStart = 0, this.lineOracle = lineOracle;
            };
            StringStream.prototype.eol = function() {
                return this.pos >= this.string.length;
            }, StringStream.prototype.sol = function() {
                return this.pos == this.lineStart;
            }, StringStream.prototype.peek = function() {
                return this.string.charAt(this.pos) || void 0;
            }, StringStream.prototype.next = function() {
                if (this.pos < this.string.length) return this.string.charAt(this.pos++);
            }, StringStream.prototype.eat = function(match) {
                var ok, ch = this.string.charAt(this.pos);
                if (ok = "string" == typeof match ? ch == match : ch && (match.test ? match.test(ch) : match(ch))) return ++this.pos, 
                ch;
            }, StringStream.prototype.eatWhile = function(match) {
                for (var start = this.pos; this.eat(match); ) ;
                return this.pos > start;
            }, StringStream.prototype.eatSpace = function() {
                for (var this$1 = this, start = this.pos; /[\s\u00a0]/.test(this.string.charAt(this.pos)); ) ++this$1.pos;
                return this.pos > start;
            }, StringStream.prototype.skipToEnd = function() {
                this.pos = this.string.length;
            }, StringStream.prototype.skipTo = function(ch) {
                var found = this.string.indexOf(ch, this.pos);
                if (found > -1) return this.pos = found, !0;
            }, StringStream.prototype.backUp = function(n) {
                this.pos -= n;
            }, StringStream.prototype.column = function() {
                return this.lastColumnPos < this.start && (this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue), 
                this.lastColumnPos = this.start), this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
            }, StringStream.prototype.indentation = function() {
                return countColumn(this.string, null, this.tabSize) - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
            }, StringStream.prototype.match = function(pattern, consume, caseInsensitive) {
                if ("string" != typeof pattern) {
                    var match = this.string.slice(this.pos).match(pattern);
                    return match && match.index > 0 ? null : (match && consume !== !1 && (this.pos += match[0].length), 
                    match);
                }
                var cased = function(str) {
                    return caseInsensitive ? str.toLowerCase() : str;
                }, substr = this.string.substr(this.pos, pattern.length);
                if (cased(substr) == cased(pattern)) return consume !== !1 && (this.pos += pattern.length), 
                !0;
            }, StringStream.prototype.current = function() {
                return this.string.slice(this.start, this.pos);
            }, StringStream.prototype.hideFirstChars = function(n, inner) {
                this.lineStart += n;
                try {
                    return inner();
                } finally {
                    this.lineStart -= n;
                }
            }, StringStream.prototype.lookAhead = function(n) {
                var oracle = this.lineOracle;
                return oracle && oracle.lookAhead(n);
            }, StringStream.prototype.baseToken = function() {
                var oracle = this.lineOracle;
                return oracle && oracle.baseToken(this.pos);
            };
            var SavedContext = function(state, lookAhead) {
                this.state = state, this.lookAhead = lookAhead;
            }, Context = function(doc, state, line, lookAhead) {
                this.state = state, this.doc = doc, this.line = line, this.maxLookAhead = lookAhead || 0, 
                this.baseTokens = null, this.baseTokenPos = 1;
            };
            Context.prototype.lookAhead = function(n) {
                var line = this.doc.getLine(this.line + n);
                return null != line && n > this.maxLookAhead && (this.maxLookAhead = n), line;
            }, Context.prototype.baseToken = function(n) {
                var this$1 = this;
                if (!this.baseTokens) return null;
                for (;this.baseTokens[this.baseTokenPos] <= n; ) this$1.baseTokenPos += 2;
                var type = this.baseTokens[this.baseTokenPos + 1];
                return {
                    type: type && type.replace(/( |^)overlay .*/, ""),
                    size: this.baseTokens[this.baseTokenPos] - n
                };
            }, Context.prototype.nextLine = function() {
                this.line++, this.maxLookAhead > 0 && this.maxLookAhead--;
            }, Context.fromSaved = function(doc, saved, line) {
                return saved instanceof SavedContext ? new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead) : new Context(doc, copyState(doc.mode, saved), line);
            }, Context.prototype.save = function(copy) {
                var state = copy !== !1 ? copyState(this.doc.mode, this.state) : this.state;
                return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state;
            };
            var Token = function(stream, type, state) {
                this.start = stream.start, this.end = stream.pos, this.string = stream.current(), 
                this.type = type || null, this.state = state;
            }, Line = function(text, markedSpans, estimateHeight) {
                this.text = text, attachMarkedSpans(this, markedSpans), this.height = estimateHeight ? estimateHeight(this) : 1;
            };
            Line.prototype.lineNo = function() {
                return lineNo(this);
            }, eventMixin(Line);
            // Convert a style as returned by a mode (either null, or a string
            // containing one or more styles) to a CSS style. This is cached,
            // and also looks for line-wide styles.
            var measureText, styleToClassCache = {}, styleToClassCacheWithMode = {}, operationGroup = null, orphanDelayedCallbacks = null, nullRect = {
                left: 0,
                right: 0,
                top: 0,
                bottom: 0
            }, NativeScrollbars = function(place, scroll, cm) {
                this.cm = cm;
                var vert = this.vert = elt("div", [ elt("div", null, null, "min-width: 1px") ], "CodeMirror-vscrollbar"), horiz = this.horiz = elt("div", [ elt("div", null, null, "height: 100%; min-height: 1px") ], "CodeMirror-hscrollbar");
                place(vert), place(horiz), on(vert, "scroll", function() {
                    vert.clientHeight && scroll(vert.scrollTop, "vertical");
                }), on(horiz, "scroll", function() {
                    horiz.clientWidth && scroll(horiz.scrollLeft, "horizontal");
                }), this.checkedZeroWidth = !1, // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
                ie && ie_version < 8 && (this.horiz.style.minHeight = this.vert.style.minWidth = "18px");
            };
            NativeScrollbars.prototype.update = function(measure) {
                var needsH = measure.scrollWidth > measure.clientWidth + 1, needsV = measure.scrollHeight > measure.clientHeight + 1, sWidth = measure.nativeBarWidth;
                if (needsV) {
                    this.vert.style.display = "block", this.vert.style.bottom = needsH ? sWidth + "px" : "0";
                    var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
                    // A bug in IE8 can cause this value to be negative, so guard it.
                    this.vert.firstChild.style.height = Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
                } else this.vert.style.display = "", this.vert.firstChild.style.height = "0";
                if (needsH) {
                    this.horiz.style.display = "block", this.horiz.style.right = needsV ? sWidth + "px" : "0", 
                    this.horiz.style.left = measure.barLeft + "px";
                    var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
                    this.horiz.firstChild.style.width = Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
                } else this.horiz.style.display = "", this.horiz.firstChild.style.width = "0";
                return !this.checkedZeroWidth && measure.clientHeight > 0 && (0 == sWidth && this.zeroWidthHack(), 
                this.checkedZeroWidth = !0), {
                    right: needsV ? sWidth : 0,
                    bottom: needsH ? sWidth : 0
                };
            }, NativeScrollbars.prototype.setScrollLeft = function(pos) {
                this.horiz.scrollLeft != pos && (this.horiz.scrollLeft = pos), this.disableHoriz && this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz");
            }, NativeScrollbars.prototype.setScrollTop = function(pos) {
                this.vert.scrollTop != pos && (this.vert.scrollTop = pos), this.disableVert && this.enableZeroWidthBar(this.vert, this.disableVert, "vert");
            }, NativeScrollbars.prototype.zeroWidthHack = function() {
                var w = mac && !mac_geMountainLion ? "12px" : "18px";
                this.horiz.style.height = this.vert.style.width = w, this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none", 
                this.disableHoriz = new Delayed(), this.disableVert = new Delayed();
            }, NativeScrollbars.prototype.enableZeroWidthBar = function(bar, delay, type) {
                function maybeDisable() {
                    // To find out whether the scrollbar is still visible, we
                    // check whether the element under the pixel in the bottom
                    // right corner of the scrollbar box is the scrollbar box
                    // itself (when the bar is still visible) or its filler child
                    // (when the bar is hidden). If it is still visible, we keep
                    // it enabled, if it's hidden, we disable pointer events.
                    var box = bar.getBoundingClientRect(), elt$$1 = "vert" == type ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2) : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);
                    elt$$1 != bar ? bar.style.pointerEvents = "none" : delay.set(1e3, maybeDisable);
                }
                bar.style.pointerEvents = "auto", delay.set(1e3, maybeDisable);
            }, NativeScrollbars.prototype.clear = function() {
                var parent = this.horiz.parentNode;
                parent.removeChild(this.horiz), parent.removeChild(this.vert);
            };
            var NullScrollbars = function() {};
            NullScrollbars.prototype.update = function() {
                return {
                    bottom: 0,
                    right: 0
                };
            }, NullScrollbars.prototype.setScrollLeft = function() {}, NullScrollbars.prototype.setScrollTop = function() {}, 
            NullScrollbars.prototype.clear = function() {};
            var scrollbarModel = {
                native: NativeScrollbars,
                null: NullScrollbars
            }, nextOpId = 0, DisplayUpdate = function(cm, viewport, force) {
                var display = cm.display;
                this.viewport = viewport, // Store some values that we'll need later (but don't want to force a relayout for)
                this.visible = visibleLines(display, cm.doc, viewport), this.editorIsHidden = !display.wrapper.offsetWidth, 
                this.wrapperHeight = display.wrapper.clientHeight, this.wrapperWidth = display.wrapper.clientWidth, 
                this.oldDisplayWidth = displayWidth(cm), this.force = force, this.dims = getDimensions(cm), 
                this.events = [];
            };
            DisplayUpdate.prototype.signal = function(emitter, type) {
                hasHandler(emitter, type) && this.events.push(arguments);
            }, DisplayUpdate.prototype.finish = function() {
                for (var this$1 = this, i = 0; i < this.events.length; i++) signal.apply(null, this$1.events[i]);
            };
            // Since the delta values reported on mouse wheel events are
            // unstandardized between browsers and even browser versions, and
            // generally horribly unpredictable, this code starts by measuring
            // the scroll effect that the first few mouse wheel events have,
            // and, from that, detects the way it can convert deltas to pixel
            // offsets afterwards.
            //
            // The reason we want to know the amount a wheel event will scroll
            // is that it gives us a chance to update the display before the
            // actual scrolling happens, reducing flickering.
            var wheelSamples = 0, wheelPixelsPerUnit = null;
            // Fill in a browser-detected starting value on browsers where we
            // know one. These don't have to be accurate -- the result of them
            // being wrong would just be a slight flicker on the first wheel
            // scroll (if it is large enough).
            ie ? wheelPixelsPerUnit = -.53 : gecko ? wheelPixelsPerUnit = 15 : chrome ? wheelPixelsPerUnit = -.7 : safari && (wheelPixelsPerUnit = -1 / 3);
            // Selection objects are immutable. A new one is created every time
            // the selection changes. A selection is one or more non-overlapping
            // (and non-touching) ranges, sorted, and an integer that indicates
            // which one is the primary selection (the one that's scrolled into
            // view, that getCursor returns, etc).
            var Selection = function(ranges, primIndex) {
                this.ranges = ranges, this.primIndex = primIndex;
            };
            Selection.prototype.primary = function() {
                return this.ranges[this.primIndex];
            }, Selection.prototype.equals = function(other) {
                var this$1 = this;
                if (other == this) return !0;
                if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) return !1;
                for (var i = 0; i < this.ranges.length; i++) {
                    var here = this$1.ranges[i], there = other.ranges[i];
                    if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) return !1;
                }
                return !0;
            }, Selection.prototype.deepCopy = function() {
                for (var this$1 = this, out = [], i = 0; i < this.ranges.length; i++) out[i] = new Range(copyPos(this$1.ranges[i].anchor), copyPos(this$1.ranges[i].head));
                return new Selection(out, this.primIndex);
            }, Selection.prototype.somethingSelected = function() {
                for (var this$1 = this, i = 0; i < this.ranges.length; i++) if (!this$1.ranges[i].empty()) return !0;
                return !1;
            }, Selection.prototype.contains = function(pos, end) {
                var this$1 = this;
                end || (end = pos);
                for (var i = 0; i < this.ranges.length; i++) {
                    var range = this$1.ranges[i];
                    if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0) return i;
                }
                return -1;
            };
            var Range = function(anchor, head) {
                this.anchor = anchor, this.head = head;
            };
            Range.prototype.from = function() {
                return minPos(this.anchor, this.head);
            }, Range.prototype.to = function() {
                return maxPos(this.anchor, this.head);
            }, Range.prototype.empty = function() {
                return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
            }, LeafChunk.prototype = {
                chunkSize: function() {
                    return this.lines.length;
                },
                // Remove the n lines at offset 'at'.
                removeInner: function(at, n) {
                    for (var this$1 = this, i = at, e = at + n; i < e; ++i) {
                        var line = this$1.lines[i];
                        this$1.height -= line.height, cleanUpLine(line), signalLater(line, "delete");
                    }
                    this.lines.splice(at, n);
                },
                // Helper used to collapse a small branch into a single leaf.
                collapse: function(lines) {
                    lines.push.apply(lines, this.lines);
                },
                // Insert the given array of lines at offset 'at', count them as
                // having the given height.
                insertInner: function(at, lines, height) {
                    var this$1 = this;
                    this.height += height, this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
                    for (var i = 0; i < lines.length; ++i) lines[i].parent = this$1;
                },
                // Used to iterate over a part of the tree.
                iterN: function(at, n, op) {
                    for (var this$1 = this, e = at + n; at < e; ++at) if (op(this$1.lines[at])) return !0;
                }
            }, BranchChunk.prototype = {
                chunkSize: function() {
                    return this.size;
                },
                removeInner: function(at, n) {
                    var this$1 = this;
                    this.size -= n;
                    for (var i = 0; i < this.children.length; ++i) {
                        var child = this$1.children[i], sz = child.chunkSize();
                        if (at < sz) {
                            var rm = Math.min(n, sz - at), oldHeight = child.height;
                            if (child.removeInner(at, rm), this$1.height -= oldHeight - child.height, sz == rm && (this$1.children.splice(i--, 1), 
                            child.parent = null), 0 == (n -= rm)) break;
                            at = 0;
                        } else at -= sz;
                    }
                    // If the result is smaller than 25 lines, ensure that it is a
                    // single leaf node.
                    if (this.size - n < 25 && (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
                        var lines = [];
                        this.collapse(lines), this.children = [ new LeafChunk(lines) ], this.children[0].parent = this;
                    }
                },
                collapse: function(lines) {
                    for (var this$1 = this, i = 0; i < this.children.length; ++i) this$1.children[i].collapse(lines);
                },
                insertInner: function(at, lines, height) {
                    var this$1 = this;
                    this.size += lines.length, this.height += height;
                    for (var i = 0; i < this.children.length; ++i) {
                        var child = this$1.children[i], sz = child.chunkSize();
                        if (at <= sz) {
                            if (child.insertInner(at, lines, height), child.lines && child.lines.length > 50) {
                                for (var remaining = child.lines.length % 25 + 25, pos = remaining; pos < child.lines.length; ) {
                                    var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
                                    child.height -= leaf.height, this$1.children.splice(++i, 0, leaf), leaf.parent = this$1;
                                }
                                child.lines = child.lines.slice(0, remaining), this$1.maybeSpill();
                            }
                            break;
                        }
                        at -= sz;
                    }
                },
                // When a node has grown, check whether it should be split.
                maybeSpill: function() {
                    if (!(this.children.length <= 10)) {
                        var me = this;
                        do {
                            var spilled = me.children.splice(me.children.length - 5, 5), sibling = new BranchChunk(spilled);
                            if (me.parent) {
                                me.size -= sibling.size, me.height -= sibling.height;
                                var myIndex = indexOf(me.parent.children, me);
                                me.parent.children.splice(myIndex + 1, 0, sibling);
                            } else {
                                // Become the parent node
                                var copy = new BranchChunk(me.children);
                                copy.parent = me, me.children = [ copy, sibling ], me = copy;
                            }
                            sibling.parent = me.parent;
                        } while (me.children.length > 10);
                        me.parent.maybeSpill();
                    }
                },
                iterN: function(at, n, op) {
                    for (var this$1 = this, i = 0; i < this.children.length; ++i) {
                        var child = this$1.children[i], sz = child.chunkSize();
                        if (at < sz) {
                            var used = Math.min(n, sz - at);
                            if (child.iterN(at, used, op)) return !0;
                            if (0 == (n -= used)) break;
                            at = 0;
                        } else at -= sz;
                    }
                }
            };
            // Line widgets are block elements displayed above or below a line.
            var LineWidget = function(doc, node, options) {
                var this$1 = this;
                if (options) for (var opt in options) options.hasOwnProperty(opt) && (this$1[opt] = options[opt]);
                this.doc = doc, this.node = node;
            };
            LineWidget.prototype.clear = function() {
                var this$1 = this, cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
                if (null != no && ws) {
                    for (var i = 0; i < ws.length; ++i) ws[i] == this$1 && ws.splice(i--, 1);
                    ws.length || (line.widgets = null);
                    var height = widgetHeight(this);
                    updateLineHeight(line, Math.max(0, line.height - height)), cm && (runInOp(cm, function() {
                        adjustScrollWhenAboveVisible(cm, line, -height), regLineChange(cm, no, "widget");
                    }), signalLater(cm, "lineWidgetCleared", cm, this, no));
                }
            }, LineWidget.prototype.changed = function() {
                var this$1 = this, oldH = this.height, cm = this.doc.cm, line = this.line;
                this.height = null;
                var diff = widgetHeight(this) - oldH;
                diff && (updateLineHeight(line, line.height + diff), cm && runInOp(cm, function() {
                    cm.curOp.forceUpdate = !0, adjustScrollWhenAboveVisible(cm, line, diff), signalLater(cm, "lineWidgetChanged", cm, this$1, lineNo(line));
                }));
            }, eventMixin(LineWidget);
            // TEXTMARKERS
            // Created with markText and setBookmark methods. A TextMarker is a
            // handle that can be used to clear or find a marked position in the
            // document. Line objects hold arrays (markedSpans) containing
            // {from, to, marker} object pointing to such marker objects, and
            // indicating that such a marker is present on that line. Multiple
            // lines may point to the same marker when it spans across lines.
            // The spans will have null for their from/to properties when the
            // marker continues beyond the start/end of the line. Markers have
            // links back to the lines they currently touch.
            // Collapsed markers have unique ids, in order to be able to order
            // them, which is needed for uniquely determining an outer marker
            // when they overlap (they may nest, but not partially overlap).
            var nextMarkerId = 0, TextMarker = function(doc, type) {
                this.lines = [], this.type = type, this.doc = doc, this.id = ++nextMarkerId;
            };
            // Clear the marker.
            TextMarker.prototype.clear = function() {
                var this$1 = this;
                if (!this.explicitlyCleared) {
                    var cm = this.doc.cm, withOp = cm && !cm.curOp;
                    if (withOp && startOperation(cm), hasHandler(this, "clear")) {
                        var found = this.find();
                        found && signalLater(this, "clear", found.from, found.to);
                    }
                    for (var min = null, max = null, i = 0; i < this.lines.length; ++i) {
                        var line = this$1.lines[i], span = getMarkedSpanFor(line.markedSpans, this$1);
                        cm && !this$1.collapsed ? regLineChange(cm, lineNo(line), "text") : cm && (null != span.to && (max = lineNo(line)), 
                        null != span.from && (min = lineNo(line))), line.markedSpans = removeMarkedSpan(line.markedSpans, span), 
                        null == span.from && this$1.collapsed && !lineIsHidden(this$1.doc, line) && cm && updateLineHeight(line, textHeight(cm.display));
                    }
                    if (cm && this.collapsed && !cm.options.lineWrapping) for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {
                        var visual = visualLine(this$1.lines[i$1]), len = lineLength(visual);
                        len > cm.display.maxLineLength && (cm.display.maxLine = visual, cm.display.maxLineLength = len, 
                        cm.display.maxLineChanged = !0);
                    }
                    null != min && cm && this.collapsed && regChange(cm, min, max + 1), this.lines.length = 0, 
                    this.explicitlyCleared = !0, this.atomic && this.doc.cantEdit && (this.doc.cantEdit = !1, 
                    cm && reCheckSelection(cm.doc)), cm && signalLater(cm, "markerCleared", cm, this, min, max), 
                    withOp && endOperation(cm), this.parent && this.parent.clear();
                }
            }, // Find the position of the marker in the document. Returns a {from,
            // to} object by default. Side can be passed to get a specific side
            // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
            // Pos objects returned contain a line object, rather than a line
            // number (used to prevent looking up the same line twice).
            TextMarker.prototype.find = function(side, lineObj) {
                var this$1 = this;
                null == side && "bookmark" == this.type && (side = 1);
                for (var from, to, i = 0; i < this.lines.length; ++i) {
                    var line = this$1.lines[i], span = getMarkedSpanFor(line.markedSpans, this$1);
                    if (null != span.from && (from = Pos(lineObj ? line : lineNo(line), span.from), 
                    side == -1)) return from;
                    if (null != span.to && (to = Pos(lineObj ? line : lineNo(line), span.to), 1 == side)) return to;
                }
                return from && {
                    from: from,
                    to: to
                };
            }, // Signals that the marker's widget changed, and surrounding layout
            // should be recomputed.
            TextMarker.prototype.changed = function() {
                var this$1 = this, pos = this.find(-1, !0), widget = this, cm = this.doc.cm;
                pos && cm && runInOp(cm, function() {
                    var line = pos.line, lineN = lineNo(pos.line), view = findViewForLine(cm, lineN);
                    if (view && (clearLineMeasurementCacheFor(view), cm.curOp.selectionChanged = cm.curOp.forceUpdate = !0), 
                    cm.curOp.updateMaxLine = !0, !lineIsHidden(widget.doc, line) && null != widget.height) {
                        var oldHeight = widget.height;
                        widget.height = null;
                        var dHeight = widgetHeight(widget) - oldHeight;
                        dHeight && updateLineHeight(line, line.height + dHeight);
                    }
                    signalLater(cm, "markerChanged", cm, this$1);
                });
            }, TextMarker.prototype.attachLine = function(line) {
                if (!this.lines.length && this.doc.cm) {
                    var op = this.doc.cm.curOp;
                    op.maybeHiddenMarkers && indexOf(op.maybeHiddenMarkers, this) != -1 || (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
                }
                this.lines.push(line);
            }, TextMarker.prototype.detachLine = function(line) {
                if (this.lines.splice(indexOf(this.lines, line), 1), !this.lines.length && this.doc.cm) {
                    var op = this.doc.cm.curOp;
                    (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
                }
            }, eventMixin(TextMarker);
            // SHARED TEXTMARKERS
            // A shared marker spans multiple linked documents. It is
            // implemented as a meta-marker-object controlling multiple normal
            // markers.
            var SharedTextMarker = function(markers, primary) {
                var this$1 = this;
                this.markers = markers, this.primary = primary;
                for (var i = 0; i < markers.length; ++i) markers[i].parent = this$1;
            };
            SharedTextMarker.prototype.clear = function() {
                var this$1 = this;
                if (!this.explicitlyCleared) {
                    this.explicitlyCleared = !0;
                    for (var i = 0; i < this.markers.length; ++i) this$1.markers[i].clear();
                    signalLater(this, "clear");
                }
            }, SharedTextMarker.prototype.find = function(side, lineObj) {
                return this.primary.find(side, lineObj);
            }, eventMixin(SharedTextMarker);
            var nextDocId = 0, Doc = function(text, mode, firstLine, lineSep, direction) {
                if (!(this instanceof Doc)) return new Doc(text, mode, firstLine, lineSep, direction);
                null == firstLine && (firstLine = 0), BranchChunk.call(this, [ new LeafChunk([ new Line("", null) ]) ]), 
                this.first = firstLine, this.scrollTop = this.scrollLeft = 0, this.cantEdit = !1, 
                this.cleanGeneration = 1, this.modeFrontier = this.highlightFrontier = firstLine;
                var start = Pos(firstLine, 0);
                this.sel = simpleSelection(start), this.history = new History(null), this.id = ++nextDocId, 
                this.modeOption = mode, this.lineSep = lineSep, this.direction = "rtl" == direction ? "rtl" : "ltr", 
                this.extend = !1, "string" == typeof text && (text = this.splitLines(text)), updateDoc(this, {
                    from: start,
                    to: start,
                    text: text
                }), setSelection(this, simpleSelection(start), sel_dontScroll);
            };
            Doc.prototype = createObj(BranchChunk.prototype, {
                constructor: Doc,
                // Iterate over the document. Supports two forms -- with only one
                // argument, it calls that for each line in the document. With
                // three, it iterates over the range given by the first two (with
                // the second being non-inclusive).
                iter: function(from, to, op) {
                    op ? this.iterN(from - this.first, to - from, op) : this.iterN(this.first, this.first + this.size, from);
                },
                // Non-public interface for adding and removing lines.
                insert: function(at, lines) {
                    for (var height = 0, i = 0; i < lines.length; ++i) height += lines[i].height;
                    this.insertInner(at - this.first, lines, height);
                },
                remove: function(at, n) {
                    this.removeInner(at - this.first, n);
                },
                // From here, the methods are part of the public interface. Most
                // are also available from CodeMirror (editor) instances.
                getValue: function(lineSep) {
                    var lines = getLines(this, this.first, this.first + this.size);
                    return lineSep === !1 ? lines : lines.join(lineSep || this.lineSeparator());
                },
                setValue: docMethodOp(function(code) {
                    var top = Pos(this.first, 0), last = this.first + this.size - 1;
                    makeChange(this, {
                        from: top,
                        to: Pos(last, getLine(this, last).text.length),
                        text: this.splitLines(code),
                        origin: "setValue",
                        full: !0
                    }, !0), this.cm && scrollToCoords(this.cm, 0, 0), setSelection(this, simpleSelection(top), sel_dontScroll);
                }),
                replaceRange: function(code, from, to, origin) {
                    from = clipPos(this, from), to = to ? clipPos(this, to) : from, replaceRange(this, code, from, to, origin);
                },
                getRange: function(from, to, lineSep) {
                    var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
                    return lineSep === !1 ? lines : lines.join(lineSep || this.lineSeparator());
                },
                getLine: function(line) {
                    var l = this.getLineHandle(line);
                    return l && l.text;
                },
                getLineHandle: function(line) {
                    if (isLine(this, line)) return getLine(this, line);
                },
                getLineNumber: function(line) {
                    return lineNo(line);
                },
                getLineHandleVisualStart: function(line) {
                    return "number" == typeof line && (line = getLine(this, line)), visualLine(line);
                },
                lineCount: function() {
                    return this.size;
                },
                firstLine: function() {
                    return this.first;
                },
                lastLine: function() {
                    return this.first + this.size - 1;
                },
                clipPos: function(pos) {
                    return clipPos(this, pos);
                },
                getCursor: function(start) {
                    var pos, range$$1 = this.sel.primary();
                    return pos = null == start || "head" == start ? range$$1.head : "anchor" == start ? range$$1.anchor : "end" == start || "to" == start || start === !1 ? range$$1.to() : range$$1.from();
                },
                listSelections: function() {
                    return this.sel.ranges;
                },
                somethingSelected: function() {
                    return this.sel.somethingSelected();
                },
                setCursor: docMethodOp(function(line, ch, options) {
                    setSimpleSelection(this, clipPos(this, "number" == typeof line ? Pos(line, ch || 0) : line), null, options);
                }),
                setSelection: docMethodOp(function(anchor, head, options) {
                    setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
                }),
                extendSelection: docMethodOp(function(head, other, options) {
                    extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
                }),
                extendSelections: docMethodOp(function(heads, options) {
                    extendSelections(this, clipPosArray(this, heads), options);
                }),
                extendSelectionsBy: docMethodOp(function(f, options) {
                    var heads = map(this.sel.ranges, f);
                    extendSelections(this, clipPosArray(this, heads), options);
                }),
                setSelections: docMethodOp(function(ranges, primary, options) {
                    var this$1 = this;
                    if (ranges.length) {
                        for (var out = [], i = 0; i < ranges.length; i++) out[i] = new Range(clipPos(this$1, ranges[i].anchor), clipPos(this$1, ranges[i].head));
                        null == primary && (primary = Math.min(ranges.length - 1, this.sel.primIndex)), 
                        setSelection(this, normalizeSelection(out, primary), options);
                    }
                }),
                addSelection: docMethodOp(function(anchor, head, options) {
                    var ranges = this.sel.ranges.slice(0);
                    ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor))), setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);
                }),
                getSelection: function(lineSep) {
                    for (var lines, this$1 = this, ranges = this.sel.ranges, i = 0; i < ranges.length; i++) {
                        var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());
                        lines = lines ? lines.concat(sel) : sel;
                    }
                    return lineSep === !1 ? lines : lines.join(lineSep || this.lineSeparator());
                },
                getSelections: function(lineSep) {
                    for (var this$1 = this, parts = [], ranges = this.sel.ranges, i = 0; i < ranges.length; i++) {
                        var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());
                        lineSep !== !1 && (sel = sel.join(lineSep || this$1.lineSeparator())), parts[i] = sel;
                    }
                    return parts;
                },
                replaceSelection: function(code, collapse, origin) {
                    for (var dup = [], i = 0; i < this.sel.ranges.length; i++) dup[i] = code;
                    this.replaceSelections(dup, collapse, origin || "+input");
                },
                replaceSelections: docMethodOp(function(code, collapse, origin) {
                    for (var this$1 = this, changes = [], sel = this.sel, i = 0; i < sel.ranges.length; i++) {
                        var range$$1 = sel.ranges[i];
                        changes[i] = {
                            from: range$$1.from(),
                            to: range$$1.to(),
                            text: this$1.splitLines(code[i]),
                            origin: origin
                        };
                    }
                    for (var newSel = collapse && "end" != collapse && computeReplacedSel(this, changes, collapse), i$1 = changes.length - 1; i$1 >= 0; i$1--) makeChange(this$1, changes[i$1]);
                    newSel ? setSelectionReplaceHistory(this, newSel) : this.cm && ensureCursorVisible(this.cm);
                }),
                undo: docMethodOp(function() {
                    makeChangeFromHistory(this, "undo");
                }),
                redo: docMethodOp(function() {
                    makeChangeFromHistory(this, "redo");
                }),
                undoSelection: docMethodOp(function() {
                    makeChangeFromHistory(this, "undo", !0);
                }),
                redoSelection: docMethodOp(function() {
                    makeChangeFromHistory(this, "redo", !0);
                }),
                setExtending: function(val) {
                    this.extend = val;
                },
                getExtending: function() {
                    return this.extend;
                },
                historySize: function() {
                    for (var hist = this.history, done = 0, undone = 0, i = 0; i < hist.done.length; i++) hist.done[i].ranges || ++done;
                    for (var i$1 = 0; i$1 < hist.undone.length; i$1++) hist.undone[i$1].ranges || ++undone;
                    return {
                        undo: done,
                        redo: undone
                    };
                },
                clearHistory: function() {
                    this.history = new History(this.history.maxGeneration);
                },
                markClean: function() {
                    this.cleanGeneration = this.changeGeneration(!0);
                },
                changeGeneration: function(forceSplit) {
                    return forceSplit && (this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null), 
                    this.history.generation;
                },
                isClean: function(gen) {
                    return this.history.generation == (gen || this.cleanGeneration);
                },
                getHistory: function() {
                    return {
                        done: copyHistoryArray(this.history.done),
                        undone: copyHistoryArray(this.history.undone)
                    };
                },
                setHistory: function(histData) {
                    var hist = this.history = new History(this.history.maxGeneration);
                    hist.done = copyHistoryArray(histData.done.slice(0), null, !0), hist.undone = copyHistoryArray(histData.undone.slice(0), null, !0);
                },
                setGutterMarker: docMethodOp(function(line, gutterID, value) {
                    return changeLine(this, line, "gutter", function(line) {
                        var markers = line.gutterMarkers || (line.gutterMarkers = {});
                        return markers[gutterID] = value, !value && isEmpty(markers) && (line.gutterMarkers = null), 
                        !0;
                    });
                }),
                clearGutter: docMethodOp(function(gutterID) {
                    var this$1 = this;
                    this.iter(function(line) {
                        line.gutterMarkers && line.gutterMarkers[gutterID] && changeLine(this$1, line, "gutter", function() {
                            return line.gutterMarkers[gutterID] = null, isEmpty(line.gutterMarkers) && (line.gutterMarkers = null), 
                            !0;
                        });
                    });
                }),
                lineInfo: function(line) {
                    var n;
                    if ("number" == typeof line) {
                        if (!isLine(this, line)) return null;
                        if (n = line, line = getLine(this, line), !line) return null;
                    } else if (n = lineNo(line), null == n) return null;
                    return {
                        line: n,
                        handle: line,
                        text: line.text,
                        gutterMarkers: line.gutterMarkers,
                        textClass: line.textClass,
                        bgClass: line.bgClass,
                        wrapClass: line.wrapClass,
                        widgets: line.widgets
                    };
                },
                addLineClass: docMethodOp(function(handle, where, cls) {
                    return changeLine(this, handle, "gutter" == where ? "gutter" : "class", function(line) {
                        var prop = "text" == where ? "textClass" : "background" == where ? "bgClass" : "gutter" == where ? "gutterClass" : "wrapClass";
                        if (line[prop]) {
                            if (classTest(cls).test(line[prop])) return !1;
                            line[prop] += " " + cls;
                        } else line[prop] = cls;
                        return !0;
                    });
                }),
                removeLineClass: docMethodOp(function(handle, where, cls) {
                    return changeLine(this, handle, "gutter" == where ? "gutter" : "class", function(line) {
                        var prop = "text" == where ? "textClass" : "background" == where ? "bgClass" : "gutter" == where ? "gutterClass" : "wrapClass", cur = line[prop];
                        if (!cur) return !1;
                        if (null == cls) line[prop] = null; else {
                            var found = cur.match(classTest(cls));
                            if (!found) return !1;
                            var end = found.index + found[0].length;
                            line[prop] = cur.slice(0, found.index) + (found.index && end != cur.length ? " " : "") + cur.slice(end) || null;
                        }
                        return !0;
                    });
                }),
                addLineWidget: docMethodOp(function(handle, node, options) {
                    return addLineWidget(this, handle, node, options);
                }),
                removeLineWidget: function(widget) {
                    widget.clear();
                },
                markText: function(from, to, options) {
                    return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range");
                },
                setBookmark: function(pos, options) {
                    var realOpts = {
                        replacedWith: options && (null == options.nodeType ? options.widget : options),
                        insertLeft: options && options.insertLeft,
                        clearWhenEmpty: !1,
                        shared: options && options.shared,
                        handleMouseEvents: options && options.handleMouseEvents
                    };
                    return pos = clipPos(this, pos), markText(this, pos, pos, realOpts, "bookmark");
                },
                findMarksAt: function(pos) {
                    pos = clipPos(this, pos);
                    var markers = [], spans = getLine(this, pos.line).markedSpans;
                    if (spans) for (var i = 0; i < spans.length; ++i) {
                        var span = spans[i];
                        (null == span.from || span.from <= pos.ch) && (null == span.to || span.to >= pos.ch) && markers.push(span.marker.parent || span.marker);
                    }
                    return markers;
                },
                findMarks: function(from, to, filter) {
                    from = clipPos(this, from), to = clipPos(this, to);
                    var found = [], lineNo$$1 = from.line;
                    return this.iter(from.line, to.line + 1, function(line) {
                        var spans = line.markedSpans;
                        if (spans) for (var i = 0; i < spans.length; i++) {
                            var span = spans[i];
                            null != span.to && lineNo$$1 == from.line && from.ch >= span.to || null == span.from && lineNo$$1 != from.line || null != span.from && lineNo$$1 == to.line && span.from >= to.ch || filter && !filter(span.marker) || found.push(span.marker.parent || span.marker);
                        }
                        ++lineNo$$1;
                    }), found;
                },
                getAllMarks: function() {
                    var markers = [];
                    return this.iter(function(line) {
                        var sps = line.markedSpans;
                        if (sps) for (var i = 0; i < sps.length; ++i) null != sps[i].from && markers.push(sps[i].marker);
                    }), markers;
                },
                posFromIndex: function(off) {
                    var ch, lineNo$$1 = this.first, sepSize = this.lineSeparator().length;
                    return this.iter(function(line) {
                        var sz = line.text.length + sepSize;
                        return sz > off ? (ch = off, !0) : (off -= sz, void ++lineNo$$1);
                    }), clipPos(this, Pos(lineNo$$1, ch));
                },
                indexFromPos: function(coords) {
                    coords = clipPos(this, coords);
                    var index = coords.ch;
                    if (coords.line < this.first || coords.ch < 0) return 0;
                    var sepSize = this.lineSeparator().length;
                    return this.iter(this.first, coords.line, function(line) {
                        // iter aborts when callback returns a truthy value
                        index += line.text.length + sepSize;
                    }), index;
                },
                copy: function(copyHistory) {
                    var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep, this.direction);
                    return doc.scrollTop = this.scrollTop, doc.scrollLeft = this.scrollLeft, doc.sel = this.sel, 
                    doc.extend = !1, copyHistory && (doc.history.undoDepth = this.history.undoDepth, 
                    doc.setHistory(this.getHistory())), doc;
                },
                linkedDoc: function(options) {
                    options || (options = {});
                    var from = this.first, to = this.first + this.size;
                    null != options.from && options.from > from && (from = options.from), null != options.to && options.to < to && (to = options.to);
                    var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);
                    return options.sharedHist && (copy.history = this.history), (this.linked || (this.linked = [])).push({
                        doc: copy,
                        sharedHist: options.sharedHist
                    }), copy.linked = [ {
                        doc: this,
                        isParent: !0,
                        sharedHist: options.sharedHist
                    } ], copySharedMarkers(copy, findSharedMarkers(this)), copy;
                },
                unlinkDoc: function(other) {
                    var this$1 = this;
                    if (other instanceof CodeMirror$1 && (other = other.doc), this.linked) for (var i = 0; i < this.linked.length; ++i) {
                        var link = this$1.linked[i];
                        if (link.doc == other) {
                            this$1.linked.splice(i, 1), other.unlinkDoc(this$1), detachSharedMarkers(findSharedMarkers(this$1));
                            break;
                        }
                    }
                    // If the histories were shared, split them again
                    if (other.history == this.history) {
                        var splitIds = [ other.id ];
                        linkedDocs(other, function(doc) {
                            return splitIds.push(doc.id);
                        }, !0), other.history = new History(null), other.history.done = copyHistoryArray(this.history.done, splitIds), 
                        other.history.undone = copyHistoryArray(this.history.undone, splitIds);
                    }
                },
                iterLinkedDocs: function(f) {
                    linkedDocs(this, f);
                },
                getMode: function() {
                    return this.mode;
                },
                getEditor: function() {
                    return this.cm;
                },
                splitLines: function(str) {
                    return this.lineSep ? str.split(this.lineSep) : splitLinesAuto(str);
                },
                lineSeparator: function() {
                    return this.lineSep || "\n";
                },
                setDirection: docMethodOp(function(dir) {
                    "rtl" != dir && (dir = "ltr"), dir != this.direction && (this.direction = dir, this.iter(function(line) {
                        return line.order = null;
                    }), this.cm && directionChanged(this.cm));
                })
            }), // Public alias.
            Doc.prototype.eachLine = Doc.prototype.iter;
            // Number keys
            for (var lastDrop = 0, globalsRegistered = !1, keyNames = {
                3: "Enter",
                8: "Backspace",
                9: "Tab",
                13: "Enter",
                16: "Shift",
                17: "Ctrl",
                18: "Alt",
                19: "Pause",
                20: "CapsLock",
                27: "Esc",
                32: "Space",
                33: "PageUp",
                34: "PageDown",
                35: "End",
                36: "Home",
                37: "Left",
                38: "Up",
                39: "Right",
                40: "Down",
                44: "PrintScrn",
                45: "Insert",
                46: "Delete",
                59: ";",
                61: "=",
                91: "Mod",
                92: "Mod",
                93: "Mod",
                106: "*",
                107: "=",
                109: "-",
                110: ".",
                111: "/",
                127: "Delete",
                173: "-",
                186: ";",
                187: "=",
                188: ",",
                189: "-",
                190: ".",
                191: "/",
                192: "`",
                219: "[",
                220: "\\",
                221: "]",
                222: "'",
                63232: "Up",
                63233: "Down",
                63234: "Left",
                63235: "Right",
                63272: "Delete",
                63273: "Home",
                63275: "End",
                63276: "PageUp",
                63277: "PageDown",
                63302: "Insert"
            }, i = 0; i < 10; i++) keyNames[i + 48] = keyNames[i + 96] = String(i);
            // Alphabetic keys
            for (var i$1 = 65; i$1 <= 90; i$1++) keyNames[i$1] = String.fromCharCode(i$1);
            // Function keys
            for (var i$2 = 1; i$2 <= 12; i$2++) keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2;
            var keyMap = {};
            keyMap.basic = {
                Left: "goCharLeft",
                Right: "goCharRight",
                Up: "goLineUp",
                Down: "goLineDown",
                End: "goLineEnd",
                Home: "goLineStartSmart",
                PageUp: "goPageUp",
                PageDown: "goPageDown",
                Delete: "delCharAfter",
                Backspace: "delCharBefore",
                "Shift-Backspace": "delCharBefore",
                Tab: "defaultTab",
                "Shift-Tab": "indentAuto",
                Enter: "newlineAndIndent",
                Insert: "toggleOverwrite",
                Esc: "singleSelection"
            }, // Note that the save and find-related commands aren't defined by
            // default. User code or addons can define them. Unknown commands
            // are simply ignored.
            keyMap.pcDefault = {
                "Ctrl-A": "selectAll",
                "Ctrl-D": "deleteLine",
                "Ctrl-Z": "undo",
                "Shift-Ctrl-Z": "redo",
                "Ctrl-Y": "redo",
                "Ctrl-Home": "goDocStart",
                "Ctrl-End": "goDocEnd",
                "Ctrl-Up": "goLineUp",
                "Ctrl-Down": "goLineDown",
                "Ctrl-Left": "goGroupLeft",
                "Ctrl-Right": "goGroupRight",
                "Alt-Left": "goLineStart",
                "Alt-Right": "goLineEnd",
                "Ctrl-Backspace": "delGroupBefore",
                "Ctrl-Delete": "delGroupAfter",
                "Ctrl-S": "save",
                "Ctrl-F": "find",
                "Ctrl-G": "findNext",
                "Shift-Ctrl-G": "findPrev",
                "Shift-Ctrl-F": "replace",
                "Shift-Ctrl-R": "replaceAll",
                "Ctrl-[": "indentLess",
                "Ctrl-]": "indentMore",
                "Ctrl-U": "undoSelection",
                "Shift-Ctrl-U": "redoSelection",
                "Alt-U": "redoSelection",
                fallthrough: "basic"
            }, // Very basic readline/emacs-style bindings, which are standard on Mac.
            keyMap.emacsy = {
                "Ctrl-F": "goCharRight",
                "Ctrl-B": "goCharLeft",
                "Ctrl-P": "goLineUp",
                "Ctrl-N": "goLineDown",
                "Alt-F": "goWordRight",
                "Alt-B": "goWordLeft",
                "Ctrl-A": "goLineStart",
                "Ctrl-E": "goLineEnd",
                "Ctrl-V": "goPageDown",
                "Shift-Ctrl-V": "goPageUp",
                "Ctrl-D": "delCharAfter",
                "Ctrl-H": "delCharBefore",
                "Alt-D": "delWordAfter",
                "Alt-Backspace": "delWordBefore",
                "Ctrl-K": "killLine",
                "Ctrl-T": "transposeChars",
                "Ctrl-O": "openLine"
            }, keyMap.macDefault = {
                "Cmd-A": "selectAll",
                "Cmd-D": "deleteLine",
                "Cmd-Z": "undo",
                "Shift-Cmd-Z": "redo",
                "Cmd-Y": "redo",
                "Cmd-Home": "goDocStart",
                "Cmd-Up": "goDocStart",
                "Cmd-End": "goDocEnd",
                "Cmd-Down": "goDocEnd",
                "Alt-Left": "goGroupLeft",
                "Alt-Right": "goGroupRight",
                "Cmd-Left": "goLineLeft",
                "Cmd-Right": "goLineRight",
                "Alt-Backspace": "delGroupBefore",
                "Ctrl-Alt-Backspace": "delGroupAfter",
                "Alt-Delete": "delGroupAfter",
                "Cmd-S": "save",
                "Cmd-F": "find",
                "Cmd-G": "findNext",
                "Shift-Cmd-G": "findPrev",
                "Cmd-Alt-F": "replace",
                "Shift-Cmd-Alt-F": "replaceAll",
                "Cmd-[": "indentLess",
                "Cmd-]": "indentMore",
                "Cmd-Backspace": "delWrappedLineLeft",
                "Cmd-Delete": "delWrappedLineRight",
                "Cmd-U": "undoSelection",
                "Shift-Cmd-U": "redoSelection",
                "Ctrl-Up": "goDocStart",
                "Ctrl-Down": "goDocEnd",
                fallthrough: [ "basic", "emacsy" ]
            }, keyMap.default = mac ? keyMap.macDefault : keyMap.pcDefault;
            // Commands are parameter-less actions that can be performed on an
            // editor, mostly used for keybindings.
            var commands = {
                selectAll: selectAll,
                singleSelection: function(cm) {
                    return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll);
                },
                killLine: function(cm) {
                    return deleteNearSelection(cm, function(range) {
                        if (range.empty()) {
                            var len = getLine(cm.doc, range.head.line).text.length;
                            return range.head.ch == len && range.head.line < cm.lastLine() ? {
                                from: range.head,
                                to: Pos(range.head.line + 1, 0)
                            } : {
                                from: range.head,
                                to: Pos(range.head.line, len)
                            };
                        }
                        return {
                            from: range.from(),
                            to: range.to()
                        };
                    });
                },
                deleteLine: function(cm) {
                    return deleteNearSelection(cm, function(range) {
                        return {
                            from: Pos(range.from().line, 0),
                            to: clipPos(cm.doc, Pos(range.to().line + 1, 0))
                        };
                    });
                },
                delLineLeft: function(cm) {
                    return deleteNearSelection(cm, function(range) {
                        return {
                            from: Pos(range.from().line, 0),
                            to: range.from()
                        };
                    });
                },
                delWrappedLineLeft: function(cm) {
                    return deleteNearSelection(cm, function(range) {
                        var top = cm.charCoords(range.head, "div").top + 5, leftPos = cm.coordsChar({
                            left: 0,
                            top: top
                        }, "div");
                        return {
                            from: leftPos,
                            to: range.from()
                        };
                    });
                },
                delWrappedLineRight: function(cm) {
                    return deleteNearSelection(cm, function(range) {
                        var top = cm.charCoords(range.head, "div").top + 5, rightPos = cm.coordsChar({
                            left: cm.display.lineDiv.offsetWidth + 100,
                            top: top
                        }, "div");
                        return {
                            from: range.from(),
                            to: rightPos
                        };
                    });
                },
                undo: function(cm) {
                    return cm.undo();
                },
                redo: function(cm) {
                    return cm.redo();
                },
                undoSelection: function(cm) {
                    return cm.undoSelection();
                },
                redoSelection: function(cm) {
                    return cm.redoSelection();
                },
                goDocStart: function(cm) {
                    return cm.extendSelection(Pos(cm.firstLine(), 0));
                },
                goDocEnd: function(cm) {
                    return cm.extendSelection(Pos(cm.lastLine()));
                },
                goLineStart: function(cm) {
                    return cm.extendSelectionsBy(function(range) {
                        return lineStart(cm, range.head.line);
                    }, {
                        origin: "+move",
                        bias: 1
                    });
                },
                goLineStartSmart: function(cm) {
                    return cm.extendSelectionsBy(function(range) {
                        return lineStartSmart(cm, range.head);
                    }, {
                        origin: "+move",
                        bias: 1
                    });
                },
                goLineEnd: function(cm) {
                    return cm.extendSelectionsBy(function(range) {
                        return lineEnd(cm, range.head.line);
                    }, {
                        origin: "+move",
                        bias: -1
                    });
                },
                goLineRight: function(cm) {
                    return cm.extendSelectionsBy(function(range) {
                        var top = cm.cursorCoords(range.head, "div").top + 5;
                        return cm.coordsChar({
                            left: cm.display.lineDiv.offsetWidth + 100,
                            top: top
                        }, "div");
                    }, sel_move);
                },
                goLineLeft: function(cm) {
                    return cm.extendSelectionsBy(function(range) {
                        var top = cm.cursorCoords(range.head, "div").top + 5;
                        return cm.coordsChar({
                            left: 0,
                            top: top
                        }, "div");
                    }, sel_move);
                },
                goLineLeftSmart: function(cm) {
                    return cm.extendSelectionsBy(function(range) {
                        var top = cm.cursorCoords(range.head, "div").top + 5, pos = cm.coordsChar({
                            left: 0,
                            top: top
                        }, "div");
                        return pos.ch < cm.getLine(pos.line).search(/\S/) ? lineStartSmart(cm, range.head) : pos;
                    }, sel_move);
                },
                goLineUp: function(cm) {
                    return cm.moveV(-1, "line");
                },
                goLineDown: function(cm) {
                    return cm.moveV(1, "line");
                },
                goPageUp: function(cm) {
                    return cm.moveV(-1, "page");
                },
                goPageDown: function(cm) {
                    return cm.moveV(1, "page");
                },
                goCharLeft: function(cm) {
                    return cm.moveH(-1, "char");
                },
                goCharRight: function(cm) {
                    return cm.moveH(1, "char");
                },
                goColumnLeft: function(cm) {
                    return cm.moveH(-1, "column");
                },
                goColumnRight: function(cm) {
                    return cm.moveH(1, "column");
                },
                goWordLeft: function(cm) {
                    return cm.moveH(-1, "word");
                },
                goGroupRight: function(cm) {
                    return cm.moveH(1, "group");
                },
                goGroupLeft: function(cm) {
                    return cm.moveH(-1, "group");
                },
                goWordRight: function(cm) {
                    return cm.moveH(1, "word");
                },
                delCharBefore: function(cm) {
                    return cm.deleteH(-1, "char");
                },
                delCharAfter: function(cm) {
                    return cm.deleteH(1, "char");
                },
                delWordBefore: function(cm) {
                    return cm.deleteH(-1, "word");
                },
                delWordAfter: function(cm) {
                    return cm.deleteH(1, "word");
                },
                delGroupBefore: function(cm) {
                    return cm.deleteH(-1, "group");
                },
                delGroupAfter: function(cm) {
                    return cm.deleteH(1, "group");
                },
                indentAuto: function(cm) {
                    return cm.indentSelection("smart");
                },
                indentMore: function(cm) {
                    return cm.indentSelection("add");
                },
                indentLess: function(cm) {
                    return cm.indentSelection("subtract");
                },
                insertTab: function(cm) {
                    return cm.replaceSelection("\t");
                },
                insertSoftTab: function(cm) {
                    for (var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize, i = 0; i < ranges.length; i++) {
                        var pos = ranges[i].from(), col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
                        spaces.push(spaceStr(tabSize - col % tabSize));
                    }
                    cm.replaceSelections(spaces);
                },
                defaultTab: function(cm) {
                    cm.somethingSelected() ? cm.indentSelection("add") : cm.execCommand("insertTab");
                },
                // Swap the two chars left and right of each selection's head.
                // Move cursor behind the two swapped characters afterwards.
                //
                // Doesn't consider line feeds a character.
                // Doesn't scan more than one line above to find a character.
                // Doesn't do anything on an empty line.
                // Doesn't do anything with non-empty selections.
                transposeChars: function(cm) {
                    return runInOp(cm, function() {
                        for (var ranges = cm.listSelections(), newSel = [], i = 0; i < ranges.length; i++) if (ranges[i].empty()) {
                            var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;
                            if (line) if (cur.ch == line.length && (cur = new Pos(cur.line, cur.ch - 1)), cur.ch > 0) cur = new Pos(cur.line, cur.ch + 1), 
                            cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2), Pos(cur.line, cur.ch - 2), cur, "+transpose"); else if (cur.line > cm.doc.first) {
                                var prev = getLine(cm.doc, cur.line - 1).text;
                                prev && (cur = new Pos(cur.line, 1), cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() + prev.charAt(prev.length - 1), Pos(cur.line - 1, prev.length - 1), cur, "+transpose"));
                            }
                            newSel.push(new Range(cur, cur));
                        }
                        cm.setSelections(newSel);
                    });
                },
                newlineAndIndent: function(cm) {
                    return runInOp(cm, function() {
                        for (var sels = cm.listSelections(), i = sels.length - 1; i >= 0; i--) cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, "+input");
                        sels = cm.listSelections();
                        for (var i$1 = 0; i$1 < sels.length; i$1++) cm.indentLine(sels[i$1].from().line, null, !0);
                        ensureCursorVisible(cm);
                    });
                },
                openLine: function(cm) {
                    return cm.replaceSelection("\n", "start");
                },
                toggleOverwrite: function(cm) {
                    return cm.toggleOverwrite();
                }
            }, stopSeq = new Delayed(), lastStoppedKey = null, DOUBLECLICK_DELAY = 400, PastClick = function(time, pos, button) {
                this.time = time, this.pos = pos, this.button = button;
            };
            PastClick.prototype.compare = function(time, pos, button) {
                return this.time + DOUBLECLICK_DELAY > time && 0 == cmp(pos, this.pos) && button == this.button;
            };
            var lastClick, lastDoubleClick, Init = {
                toString: function() {
                    return "CodeMirror.Init";
                }
            }, defaults = {}, optionHandlers = {};
            // The default configuration options.
            CodeMirror$1.defaults = defaults, // Functions to run when options are changed.
            CodeMirror$1.optionHandlers = optionHandlers;
            var initHooks = [];
            CodeMirror$1.defineInitHook = function(f) {
                return initHooks.push(f);
            };
            // This will be set to a {lineWise: bool, text: [string]} object, so
            // that, when pasting, we know what kind of selections the copied
            // text was made out of.
            var lastCopied = null, addEditorMethods = function(CodeMirror) {
                var optionHandlers = CodeMirror.optionHandlers, helpers = CodeMirror.helpers = {};
                CodeMirror.prototype = {
                    constructor: CodeMirror,
                    focus: function() {
                        window.focus(), this.display.input.focus();
                    },
                    setOption: function(option, value) {
                        var options = this.options, old = options[option];
                        options[option] == value && "mode" != option || (options[option] = value, optionHandlers.hasOwnProperty(option) && operation(this, optionHandlers[option])(this, value, old), 
                        signal(this, "optionChange", this, option));
                    },
                    getOption: function(option) {
                        return this.options[option];
                    },
                    getDoc: function() {
                        return this.doc;
                    },
                    addKeyMap: function(map$$1, bottom) {
                        this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map$$1));
                    },
                    removeKeyMap: function(map$$1) {
                        for (var maps = this.state.keyMaps, i = 0; i < maps.length; ++i) if (maps[i] == map$$1 || maps[i].name == map$$1) return maps.splice(i, 1), 
                        !0;
                    },
                    addOverlay: methodOp(function(spec, options) {
                        var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
                        if (mode.startState) throw new Error("Overlays may not be stateful.");
                        insertSorted(this.state.overlays, {
                            mode: mode,
                            modeSpec: spec,
                            opaque: options && options.opaque,
                            priority: options && options.priority || 0
                        }, function(overlay) {
                            return overlay.priority;
                        }), this.state.modeGen++, regChange(this);
                    }),
                    removeOverlay: methodOp(function(spec) {
                        for (var this$1 = this, overlays = this.state.overlays, i = 0; i < overlays.length; ++i) {
                            var cur = overlays[i].modeSpec;
                            if (cur == spec || "string" == typeof spec && cur.name == spec) return overlays.splice(i, 1), 
                            this$1.state.modeGen++, void regChange(this$1);
                        }
                    }),
                    indentLine: methodOp(function(n, dir, aggressive) {
                        "string" != typeof dir && "number" != typeof dir && (dir = null == dir ? this.options.smartIndent ? "smart" : "prev" : dir ? "add" : "subtract"), 
                        isLine(this.doc, n) && indentLine(this, n, dir, aggressive);
                    }),
                    indentSelection: methodOp(function(how) {
                        for (var this$1 = this, ranges = this.doc.sel.ranges, end = -1, i = 0; i < ranges.length; i++) {
                            var range$$1 = ranges[i];
                            if (range$$1.empty()) range$$1.head.line > end && (indentLine(this$1, range$$1.head.line, how, !0), 
                            end = range$$1.head.line, i == this$1.doc.sel.primIndex && ensureCursorVisible(this$1)); else {
                                var from = range$$1.from(), to = range$$1.to(), start = Math.max(end, from.line);
                                end = Math.min(this$1.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
                                for (var j = start; j < end; ++j) indentLine(this$1, j, how);
                                var newRanges = this$1.doc.sel.ranges;
                                0 == from.ch && ranges.length == newRanges.length && newRanges[i].from().ch > 0 && replaceOneSelection(this$1.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);
                            }
                        }
                    }),
                    // Fetch the parser token for a given character. Useful for hacks
                    // that want to inspect the mode state (say, for completion).
                    getTokenAt: function(pos, precise) {
                        return takeToken(this, pos, precise);
                    },
                    getLineTokens: function(line, precise) {
                        return takeToken(this, Pos(line), precise, !0);
                    },
                    getTokenTypeAt: function(pos) {
                        pos = clipPos(this.doc, pos);
                        var type, styles = getLineStyles(this, getLine(this.doc, pos.line)), before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
                        if (0 == ch) type = styles[2]; else for (;;) {
                            var mid = before + after >> 1;
                            if ((mid ? styles[2 * mid - 1] : 0) >= ch) after = mid; else {
                                if (!(styles[2 * mid + 1] < ch)) {
                                    type = styles[2 * mid + 2];
                                    break;
                                }
                                before = mid + 1;
                            }
                        }
                        var cut = type ? type.indexOf("overlay ") : -1;
                        return cut < 0 ? type : 0 == cut ? null : type.slice(0, cut - 1);
                    },
                    getModeAt: function(pos) {
                        var mode = this.doc.mode;
                        return mode.innerMode ? CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode : mode;
                    },
                    getHelper: function(pos, type) {
                        return this.getHelpers(pos, type)[0];
                    },
                    getHelpers: function(pos, type) {
                        var this$1 = this, found = [];
                        if (!helpers.hasOwnProperty(type)) return found;
                        var help = helpers[type], mode = this.getModeAt(pos);
                        if ("string" == typeof mode[type]) help[mode[type]] && found.push(help[mode[type]]); else if (mode[type]) for (var i = 0; i < mode[type].length; i++) {
                            var val = help[mode[type][i]];
                            val && found.push(val);
                        } else mode.helperType && help[mode.helperType] ? found.push(help[mode.helperType]) : help[mode.name] && found.push(help[mode.name]);
                        for (var i$1 = 0; i$1 < help._global.length; i$1++) {
                            var cur = help._global[i$1];
                            cur.pred(mode, this$1) && indexOf(found, cur.val) == -1 && found.push(cur.val);
                        }
                        return found;
                    },
                    getStateAfter: function(line, precise) {
                        var doc = this.doc;
                        return line = clipLine(doc, null == line ? doc.first + doc.size - 1 : line), getContextBefore(this, line + 1, precise).state;
                    },
                    cursorCoords: function(start, mode) {
                        var pos, range$$1 = this.doc.sel.primary();
                        return pos = null == start ? range$$1.head : "object" == typeof start ? clipPos(this.doc, start) : start ? range$$1.from() : range$$1.to(), 
                        cursorCoords(this, pos, mode || "page");
                    },
                    charCoords: function(pos, mode) {
                        return charCoords(this, clipPos(this.doc, pos), mode || "page");
                    },
                    coordsChar: function(coords, mode) {
                        return coords = fromCoordSystem(this, coords, mode || "page"), coordsChar(this, coords.left, coords.top);
                    },
                    lineAtHeight: function(height, mode) {
                        return height = fromCoordSystem(this, {
                            top: height,
                            left: 0
                        }, mode || "page").top, lineAtHeight(this.doc, height + this.display.viewOffset);
                    },
                    heightAtLine: function(line, mode, includeWidgets) {
                        var lineObj, end = !1;
                        if ("number" == typeof line) {
                            var last = this.doc.first + this.doc.size - 1;
                            line < this.doc.first ? line = this.doc.first : line > last && (line = last, end = !0), 
                            lineObj = getLine(this.doc, line);
                        } else lineObj = line;
                        return intoCoordSystem(this, lineObj, {
                            top: 0,
                            left: 0
                        }, mode || "page", includeWidgets || end).top + (end ? this.doc.height - heightAtLine(lineObj) : 0);
                    },
                    defaultTextHeight: function() {
                        return textHeight(this.display);
                    },
                    defaultCharWidth: function() {
                        return charWidth(this.display);
                    },
                    getViewport: function() {
                        return {
                            from: this.display.viewFrom,
                            to: this.display.viewTo
                        };
                    },
                    addWidget: function(pos, node, scroll, vert, horiz) {
                        var display = this.display;
                        pos = cursorCoords(this, clipPos(this.doc, pos));
                        var top = pos.bottom, left = pos.left;
                        if (node.style.position = "absolute", node.setAttribute("cm-ignore-events", "true"), 
                        this.display.input.setUneditable(node), display.sizer.appendChild(node), "over" == vert) top = pos.top; else if ("above" == vert || "near" == vert) {
                            var vspace = Math.max(display.wrapper.clientHeight, this.doc.height), hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
                            // Default to positioning above (if specified and possible); otherwise default to positioning below
                            ("above" == vert || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight ? top = pos.top - node.offsetHeight : pos.bottom + node.offsetHeight <= vspace && (top = pos.bottom), 
                            left + node.offsetWidth > hspace && (left = hspace - node.offsetWidth);
                        }
                        node.style.top = top + "px", node.style.left = node.style.right = "", "right" == horiz ? (left = display.sizer.clientWidth - node.offsetWidth, 
                        node.style.right = "0px") : ("left" == horiz ? left = 0 : "middle" == horiz && (left = (display.sizer.clientWidth - node.offsetWidth) / 2), 
                        node.style.left = left + "px"), scroll && scrollIntoView(this, {
                            left: left,
                            top: top,
                            right: left + node.offsetWidth,
                            bottom: top + node.offsetHeight
                        });
                    },
                    triggerOnKeyDown: methodOp(onKeyDown),
                    triggerOnKeyPress: methodOp(onKeyPress),
                    triggerOnKeyUp: onKeyUp,
                    triggerOnMouseDown: methodOp(onMouseDown),
                    execCommand: function(cmd) {
                        if (commands.hasOwnProperty(cmd)) return commands[cmd].call(null, this);
                    },
                    triggerElectric: methodOp(function(text) {
                        triggerElectric(this, text);
                    }),
                    findPosH: function(from, amount, unit, visually) {
                        var this$1 = this, dir = 1;
                        amount < 0 && (dir = -1, amount = -amount);
                        for (var cur = clipPos(this.doc, from), i = 0; i < amount && (cur = findPosH(this$1.doc, cur, dir, unit, visually), 
                        !cur.hitSide); ++i) ;
                        return cur;
                    },
                    moveH: methodOp(function(dir, unit) {
                        var this$1 = this;
                        this.extendSelectionsBy(function(range$$1) {
                            return this$1.display.shift || this$1.doc.extend || range$$1.empty() ? findPosH(this$1.doc, range$$1.head, dir, unit, this$1.options.rtlMoveVisually) : dir < 0 ? range$$1.from() : range$$1.to();
                        }, sel_move);
                    }),
                    deleteH: methodOp(function(dir, unit) {
                        var sel = this.doc.sel, doc = this.doc;
                        sel.somethingSelected() ? doc.replaceSelection("", null, "+delete") : deleteNearSelection(this, function(range$$1) {
                            var other = findPosH(doc, range$$1.head, dir, unit, !1);
                            return dir < 0 ? {
                                from: other,
                                to: range$$1.head
                            } : {
                                from: range$$1.head,
                                to: other
                            };
                        });
                    }),
                    findPosV: function(from, amount, unit, goalColumn) {
                        var this$1 = this, dir = 1, x = goalColumn;
                        amount < 0 && (dir = -1, amount = -amount);
                        for (var cur = clipPos(this.doc, from), i = 0; i < amount; ++i) {
                            var coords = cursorCoords(this$1, cur, "div");
                            if (null == x ? x = coords.left : coords.left = x, cur = findPosV(this$1, coords, dir, unit), 
                            cur.hitSide) break;
                        }
                        return cur;
                    },
                    moveV: methodOp(function(dir, unit) {
                        var this$1 = this, doc = this.doc, goals = [], collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();
                        if (doc.extendSelectionsBy(function(range$$1) {
                            if (collapse) return dir < 0 ? range$$1.from() : range$$1.to();
                            var headPos = cursorCoords(this$1, range$$1.head, "div");
                            null != range$$1.goalColumn && (headPos.left = range$$1.goalColumn), goals.push(headPos.left);
                            var pos = findPosV(this$1, headPos, dir, unit);
                            return "page" == unit && range$$1 == doc.sel.primary() && addToScrollTop(this$1, charCoords(this$1, pos, "div").top - headPos.top), 
                            pos;
                        }, sel_move), goals.length) for (var i = 0; i < doc.sel.ranges.length; i++) doc.sel.ranges[i].goalColumn = goals[i];
                    }),
                    // Find the word at the given position (as returned by coordsChar).
                    findWordAt: function(pos) {
                        var doc = this.doc, line = getLine(doc, pos.line).text, start = pos.ch, end = pos.ch;
                        if (line) {
                            var helper = this.getHelper(pos, "wordChars");
                            "before" != pos.sticky && end != line.length || !start ? ++end : --start;
                            for (var startChar = line.charAt(start), check = isWordChar(startChar, helper) ? function(ch) {
                                return isWordChar(ch, helper);
                            } : /\s/.test(startChar) ? function(ch) {
                                return /\s/.test(ch);
                            } : function(ch) {
                                return !/\s/.test(ch) && !isWordChar(ch);
                            }; start > 0 && check(line.charAt(start - 1)); ) --start;
                            for (;end < line.length && check(line.charAt(end)); ) ++end;
                        }
                        return new Range(Pos(pos.line, start), Pos(pos.line, end));
                    },
                    toggleOverwrite: function(value) {
                        null != value && value == this.state.overwrite || ((this.state.overwrite = !this.state.overwrite) ? addClass(this.display.cursorDiv, "CodeMirror-overwrite") : rmClass(this.display.cursorDiv, "CodeMirror-overwrite"), 
                        signal(this, "overwriteToggle", this, this.state.overwrite));
                    },
                    hasFocus: function() {
                        return this.display.input.getField() == activeElt();
                    },
                    isReadOnly: function() {
                        return !(!this.options.readOnly && !this.doc.cantEdit);
                    },
                    scrollTo: methodOp(function(x, y) {
                        scrollToCoords(this, x, y);
                    }),
                    getScrollInfo: function() {
                        var scroller = this.display.scroller;
                        return {
                            left: scroller.scrollLeft,
                            top: scroller.scrollTop,
                            height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
                            width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
                            clientHeight: displayHeight(this),
                            clientWidth: displayWidth(this)
                        };
                    },
                    scrollIntoView: methodOp(function(range$$1, margin) {
                        null == range$$1 ? (range$$1 = {
                            from: this.doc.sel.primary().head,
                            to: null
                        }, null == margin && (margin = this.options.cursorScrollMargin)) : "number" == typeof range$$1 ? range$$1 = {
                            from: Pos(range$$1, 0),
                            to: null
                        } : null == range$$1.from && (range$$1 = {
                            from: range$$1,
                            to: null
                        }), range$$1.to || (range$$1.to = range$$1.from), range$$1.margin = margin || 0, 
                        null != range$$1.from.line ? scrollToRange(this, range$$1) : scrollToCoordsRange(this, range$$1.from, range$$1.to, range$$1.margin);
                    }),
                    setSize: methodOp(function(width, height) {
                        var this$1 = this, interpret = function(val) {
                            return "number" == typeof val || /^\d+$/.test(String(val)) ? val + "px" : val;
                        };
                        null != width && (this.display.wrapper.style.width = interpret(width)), null != height && (this.display.wrapper.style.height = interpret(height)), 
                        this.options.lineWrapping && clearLineMeasurementCache(this);
                        var lineNo$$1 = this.display.viewFrom;
                        this.doc.iter(lineNo$$1, this.display.viewTo, function(line) {
                            if (line.widgets) for (var i = 0; i < line.widgets.length; i++) if (line.widgets[i].noHScroll) {
                                regLineChange(this$1, lineNo$$1, "widget");
                                break;
                            }
                            ++lineNo$$1;
                        }), this.curOp.forceUpdate = !0, signal(this, "refresh", this);
                    }),
                    operation: function(f) {
                        return runInOp(this, f);
                    },
                    startOperation: function() {
                        return startOperation(this);
                    },
                    endOperation: function() {
                        return endOperation(this);
                    },
                    refresh: methodOp(function() {
                        var oldHeight = this.display.cachedTextHeight;
                        regChange(this), this.curOp.forceUpdate = !0, clearCaches(this), scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop), 
                        updateGutterSpace(this), (null == oldHeight || Math.abs(oldHeight - textHeight(this.display)) > .5) && estimateLineHeights(this), 
                        signal(this, "refresh", this);
                    }),
                    swapDoc: methodOp(function(doc) {
                        var old = this.doc;
                        return old.cm = null, attachDoc(this, doc), clearCaches(this), this.display.input.reset(), 
                        scrollToCoords(this, doc.scrollLeft, doc.scrollTop), this.curOp.forceScroll = !0, 
                        signalLater(this, "swapDoc", this, old), old;
                    }),
                    getInputField: function() {
                        return this.display.input.getField();
                    },
                    getWrapperElement: function() {
                        return this.display.wrapper;
                    },
                    getScrollerElement: function() {
                        return this.display.scroller;
                    },
                    getGutterElement: function() {
                        return this.display.gutters;
                    }
                }, eventMixin(CodeMirror), CodeMirror.registerHelper = function(type, name, value) {
                    helpers.hasOwnProperty(type) || (helpers[type] = CodeMirror[type] = {
                        _global: []
                    }), helpers[type][name] = value;
                }, CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
                    CodeMirror.registerHelper(type, name, value), helpers[type]._global.push({
                        pred: predicate,
                        val: value
                    });
                };
            }, ContentEditableInput = function(cm) {
                this.cm = cm, this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null, 
                this.polling = new Delayed(), this.composing = null, this.gracePeriod = !1, this.readDOMTimeout = null;
            };
            ContentEditableInput.prototype.init = function(display) {
                function onCopyCut(e) {
                    if (!signalDOMEvent(cm, e)) {
                        if (cm.somethingSelected()) setLastCopied({
                            lineWise: !1,
                            text: cm.getSelections()
                        }), "cut" == e.type && cm.replaceSelection("", null, "cut"); else {
                            if (!cm.options.lineWiseCopyCut) return;
                            var ranges = copyableRanges(cm);
                            setLastCopied({
                                lineWise: !0,
                                text: ranges.text
                            }), "cut" == e.type && cm.operation(function() {
                                cm.setSelections(ranges.ranges, 0, sel_dontScroll), cm.replaceSelection("", null, "cut");
                            });
                        }
                        if (e.clipboardData) {
                            e.clipboardData.clearData();
                            var content = lastCopied.text.join("\n");
                            if (// iOS exposes the clipboard API, but seems to discard content inserted into it
                            e.clipboardData.setData("Text", content), e.clipboardData.getData("Text") == content) return void e.preventDefault();
                        }
                        // Old-fashioned briefly-focus-a-textarea hack
                        var kludge = hiddenTextarea(), te = kludge.firstChild;
                        cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild), te.value = lastCopied.text.join("\n");
                        var hadFocus = document.activeElement;
                        selectInput(te), setTimeout(function() {
                            cm.display.lineSpace.removeChild(kludge), hadFocus.focus(), hadFocus == div && input.showPrimarySelection();
                        }, 50);
                    }
                }
                var this$1 = this, input = this, cm = input.cm, div = input.div = display.lineDiv;
                disableBrowserMagic(div, cm.options.spellcheck), on(div, "paste", function(e) {
                    signalDOMEvent(cm, e) || handlePaste(e, cm) || // IE doesn't fire input events, so we schedule a read for the pasted content in this way
                    ie_version <= 11 && setTimeout(operation(cm, function() {
                        return this$1.updateFromDOM();
                    }), 20);
                }), on(div, "compositionstart", function(e) {
                    this$1.composing = {
                        data: e.data,
                        done: !1
                    };
                }), on(div, "compositionupdate", function(e) {
                    this$1.composing || (this$1.composing = {
                        data: e.data,
                        done: !1
                    });
                }), on(div, "compositionend", function(e) {
                    this$1.composing && (e.data != this$1.composing.data && this$1.readFromDOMSoon(), 
                    this$1.composing.done = !0);
                }), on(div, "touchstart", function() {
                    return input.forceCompositionEnd();
                }), on(div, "input", function() {
                    this$1.composing || this$1.readFromDOMSoon();
                }), on(div, "copy", onCopyCut), on(div, "cut", onCopyCut);
            }, ContentEditableInput.prototype.prepareSelection = function() {
                var result = prepareSelection(this.cm, !1);
                return result.focus = this.cm.state.focused, result;
            }, ContentEditableInput.prototype.showSelection = function(info, takeFocus) {
                info && this.cm.display.view.length && ((info.focus || takeFocus) && this.showPrimarySelection(), 
                this.showMultipleSelections(info));
            }, ContentEditableInput.prototype.showPrimarySelection = function() {
                var sel = window.getSelection(), cm = this.cm, prim = cm.doc.sel.primary(), from = prim.from(), to = prim.to();
                if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) return void sel.removeAllRanges();
                var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset), curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);
                if (!curAnchor || curAnchor.bad || !curFocus || curFocus.bad || 0 != cmp(minPos(curAnchor, curFocus), from) || 0 != cmp(maxPos(curAnchor, curFocus), to)) {
                    var view = cm.display.view, start = from.line >= cm.display.viewFrom && posToDOM(cm, from) || {
                        node: view[0].measure.map[2],
                        offset: 0
                    }, end = to.line < cm.display.viewTo && posToDOM(cm, to);
                    if (!end) {
                        var measure = view[view.length - 1].measure, map$$1 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
                        end = {
                            node: map$$1[map$$1.length - 1],
                            offset: map$$1[map$$1.length - 2] - map$$1[map$$1.length - 3]
                        };
                    }
                    if (!start || !end) return void sel.removeAllRanges();
                    var rng, old = sel.rangeCount && sel.getRangeAt(0);
                    try {
                        rng = range(start.node, start.offset, end.offset, end.node);
                    } catch (e) {}
                    // Our model of the DOM might be outdated, in which case the range we try to set can be impossible
                    rng && (!gecko && cm.state.focused ? (sel.collapse(start.node, start.offset), rng.collapsed || (sel.removeAllRanges(), 
                    sel.addRange(rng))) : (sel.removeAllRanges(), sel.addRange(rng)), old && null == sel.anchorNode ? sel.addRange(old) : gecko && this.startGracePeriod()), 
                    this.rememberSelection();
                }
            }, ContentEditableInput.prototype.startGracePeriod = function() {
                var this$1 = this;
                clearTimeout(this.gracePeriod), this.gracePeriod = setTimeout(function() {
                    this$1.gracePeriod = !1, this$1.selectionChanged() && this$1.cm.operation(function() {
                        return this$1.cm.curOp.selectionChanged = !0;
                    });
                }, 20);
            }, ContentEditableInput.prototype.showMultipleSelections = function(info) {
                removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors), removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
            }, ContentEditableInput.prototype.rememberSelection = function() {
                var sel = window.getSelection();
                this.lastAnchorNode = sel.anchorNode, this.lastAnchorOffset = sel.anchorOffset, 
                this.lastFocusNode = sel.focusNode, this.lastFocusOffset = sel.focusOffset;
            }, ContentEditableInput.prototype.selectionInEditor = function() {
                var sel = window.getSelection();
                if (!sel.rangeCount) return !1;
                var node = sel.getRangeAt(0).commonAncestorContainer;
                return contains(this.div, node);
            }, ContentEditableInput.prototype.focus = function() {
                "nocursor" != this.cm.options.readOnly && (this.selectionInEditor() || this.showSelection(this.prepareSelection(), !0), 
                this.div.focus());
            }, ContentEditableInput.prototype.blur = function() {
                this.div.blur();
            }, ContentEditableInput.prototype.getField = function() {
                return this.div;
            }, ContentEditableInput.prototype.supportsTouch = function() {
                return !0;
            }, ContentEditableInput.prototype.receivedFocus = function() {
                function poll() {
                    input.cm.state.focused && (input.pollSelection(), input.polling.set(input.cm.options.pollInterval, poll));
                }
                var input = this;
                this.selectionInEditor() ? this.pollSelection() : runInOp(this.cm, function() {
                    return input.cm.curOp.selectionChanged = !0;
                }), this.polling.set(this.cm.options.pollInterval, poll);
            }, ContentEditableInput.prototype.selectionChanged = function() {
                var sel = window.getSelection();
                return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;
            }, ContentEditableInput.prototype.pollSelection = function() {
                if (null == this.readDOMTimeout && !this.gracePeriod && this.selectionChanged()) {
                    var sel = window.getSelection(), cm = this.cm;
                    // On Android Chrome (version 56, at least), backspacing into an
                    // uneditable block element will put the cursor in that element,
                    // and then, because it's not editable, hide the virtual keyboard.
                    // Because Android doesn't allow us to actually detect backspace
                    // presses in a sane way, this code checks for when that happens
                    // and simulates a backspace press in this case.
                    if (android && chrome && this.cm.options.gutters.length && isInGutter(sel.anchorNode)) return this.cm.triggerOnKeyDown({
                        type: "keydown",
                        keyCode: 8,
                        preventDefault: Math.abs
                    }), this.blur(), void this.focus();
                    if (!this.composing) {
                        this.rememberSelection();
                        var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset), head = domToPos(cm, sel.focusNode, sel.focusOffset);
                        anchor && head && runInOp(cm, function() {
                            setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll), (anchor.bad || head.bad) && (cm.curOp.selectionChanged = !0);
                        });
                    }
                }
            }, ContentEditableInput.prototype.pollContent = function() {
                null != this.readDOMTimeout && (clearTimeout(this.readDOMTimeout), this.readDOMTimeout = null);
                var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary(), from = sel.from(), to = sel.to();
                if (0 == from.ch && from.line > cm.firstLine() && (from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length)), 
                to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine() && (to = Pos(to.line + 1, 0)), 
                from.line < display.viewFrom || to.line > display.viewTo - 1) return !1;
                var fromIndex, fromLine, fromNode;
                from.line == display.viewFrom || 0 == (fromIndex = findViewIndex(cm, from.line)) ? (fromLine = lineNo(display.view[0].line), 
                fromNode = display.view[0].node) : (fromLine = lineNo(display.view[fromIndex].line), 
                fromNode = display.view[fromIndex - 1].node.nextSibling);
                var toLine, toNode, toIndex = findViewIndex(cm, to.line);
                if (toIndex == display.view.length - 1 ? (toLine = display.viewTo - 1, toNode = display.lineDiv.lastChild) : (toLine = lineNo(display.view[toIndex + 1].line) - 1, 
                toNode = display.view[toIndex + 1].node.previousSibling), !fromNode) return !1;
                for (var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine)), oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length)); newText.length > 1 && oldText.length > 1; ) if (lst(newText) == lst(oldText)) newText.pop(), 
                oldText.pop(), toLine--; else {
                    if (newText[0] != oldText[0]) break;
                    newText.shift(), oldText.shift(), fromLine++;
                }
                for (var cutFront = 0, cutEnd = 0, newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length); cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront); ) ++cutFront;
                for (var newBot = lst(newText), oldBot = lst(oldText), maxCutEnd = Math.min(newBot.length - (1 == newText.length ? cutFront : 0), oldBot.length - (1 == oldText.length ? cutFront : 0)); cutEnd < maxCutEnd && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1); ) ++cutEnd;
                // Try to move start of change to start of selection if ambiguous
                if (1 == newText.length && 1 == oldText.length && fromLine == from.line) for (;cutFront && cutFront > from.ch && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1); ) cutFront--, 
                cutEnd++;
                newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, ""), 
                newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");
                var chFrom = Pos(fromLine, cutFront), chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
                return newText.length > 1 || newText[0] || cmp(chFrom, chTo) ? (replaceRange(cm.doc, newText, chFrom, chTo, "+input"), 
                !0) : void 0;
            }, ContentEditableInput.prototype.ensurePolled = function() {
                this.forceCompositionEnd();
            }, ContentEditableInput.prototype.reset = function() {
                this.forceCompositionEnd();
            }, ContentEditableInput.prototype.forceCompositionEnd = function() {
                this.composing && (clearTimeout(this.readDOMTimeout), this.composing = null, this.updateFromDOM(), 
                this.div.blur(), this.div.focus());
            }, ContentEditableInput.prototype.readFromDOMSoon = function() {
                var this$1 = this;
                null == this.readDOMTimeout && (this.readDOMTimeout = setTimeout(function() {
                    if (this$1.readDOMTimeout = null, this$1.composing) {
                        if (!this$1.composing.done) return;
                        this$1.composing = null;
                    }
                    this$1.updateFromDOM();
                }, 80));
            }, ContentEditableInput.prototype.updateFromDOM = function() {
                var this$1 = this;
                !this.cm.isReadOnly() && this.pollContent() || runInOp(this.cm, function() {
                    return regChange(this$1.cm);
                });
            }, ContentEditableInput.prototype.setUneditable = function(node) {
                node.contentEditable = "false";
            }, ContentEditableInput.prototype.onKeyPress = function(e) {
                0 != e.charCode && (e.preventDefault(), this.cm.isReadOnly() || operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(null == e.charCode ? e.keyCode : e.charCode), 0));
            }, ContentEditableInput.prototype.readOnlyChanged = function(val) {
                this.div.contentEditable = String("nocursor" != val);
            }, ContentEditableInput.prototype.onContextMenu = function() {}, ContentEditableInput.prototype.resetPosition = function() {}, 
            ContentEditableInput.prototype.needsContentAttribute = !0;
            // TEXTAREA INPUT STYLE
            var TextareaInput = function(cm) {
                this.cm = cm, // See input.poll and input.reset
                this.prevInput = "", // Flag that indicates whether we expect input to appear real soon
                // now (after some event like 'keypress' or 'input') and are
                // polling intensively.
                this.pollingFast = !1, // Self-resetting timeout for the poller
                this.polling = new Delayed(), // Used to work around IE issue with selection being forgotten when focus moves away from textarea
                this.hasSelection = !1, this.composing = null;
            };
            TextareaInput.prototype.init = function(display) {
                function prepareCopyCut(e) {
                    if (!signalDOMEvent(cm, e)) {
                        if (cm.somethingSelected()) setLastCopied({
                            lineWise: !1,
                            text: cm.getSelections()
                        }); else {
                            if (!cm.options.lineWiseCopyCut) return;
                            var ranges = copyableRanges(cm);
                            setLastCopied({
                                lineWise: !0,
                                text: ranges.text
                            }), "cut" == e.type ? cm.setSelections(ranges.ranges, null, sel_dontScroll) : (input.prevInput = "", 
                            te.value = ranges.text.join("\n"), selectInput(te));
                        }
                        "cut" == e.type && (cm.state.cutIncoming = !0);
                    }
                }
                var this$1 = this, input = this, cm = this.cm, div = this.wrapper = hiddenTextarea(), te = this.textarea = div.firstChild;
                display.wrapper.insertBefore(div, display.wrapper.firstChild), // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)
                ios && (te.style.width = "0px"), on(te, "input", function() {
                    ie && ie_version >= 9 && this$1.hasSelection && (this$1.hasSelection = null), input.poll();
                }), on(te, "paste", function(e) {
                    signalDOMEvent(cm, e) || handlePaste(e, cm) || (cm.state.pasteIncoming = !0, input.fastPoll());
                }), on(te, "cut", prepareCopyCut), on(te, "copy", prepareCopyCut), on(display.scroller, "paste", function(e) {
                    eventInWidget(display, e) || signalDOMEvent(cm, e) || (cm.state.pasteIncoming = !0, 
                    input.focus());
                }), // Prevent normal selection in the editor (we handle our own)
                on(display.lineSpace, "selectstart", function(e) {
                    eventInWidget(display, e) || e_preventDefault(e);
                }), on(te, "compositionstart", function() {
                    var start = cm.getCursor("from");
                    input.composing && input.composing.range.clear(), input.composing = {
                        start: start,
                        range: cm.markText(start, cm.getCursor("to"), {
                            className: "CodeMirror-composing"
                        })
                    };
                }), on(te, "compositionend", function() {
                    input.composing && (input.poll(), input.composing.range.clear(), input.composing = null);
                });
            }, TextareaInput.prototype.prepareSelection = function() {
                // Redraw the selection and/or cursor
                var cm = this.cm, display = cm.display, doc = cm.doc, result = prepareSelection(cm);
                // Move the hidden textarea near the cursor to prevent scrolling artifacts
                if (cm.options.moveInputWithCursor) {
                    var headPos = cursorCoords(cm, doc.sel.primary().head, "div"), wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
                    result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top)), 
                    result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left));
                }
                return result;
            }, TextareaInput.prototype.showSelection = function(drawn) {
                var cm = this.cm, display = cm.display;
                removeChildrenAndAdd(display.cursorDiv, drawn.cursors), removeChildrenAndAdd(display.selectionDiv, drawn.selection), 
                null != drawn.teTop && (this.wrapper.style.top = drawn.teTop + "px", this.wrapper.style.left = drawn.teLeft + "px");
            }, // Reset the input to correspond to the selection (or to be empty,
            // when not typing and nothing is selected)
            TextareaInput.prototype.reset = function(typing) {
                if (!this.contextMenuPending && !this.composing) {
                    var cm = this.cm;
                    if (cm.somethingSelected()) {
                        this.prevInput = "";
                        var content = cm.getSelection();
                        this.textarea.value = content, cm.state.focused && selectInput(this.textarea), ie && ie_version >= 9 && (this.hasSelection = content);
                    } else typing || (this.prevInput = this.textarea.value = "", ie && ie_version >= 9 && (this.hasSelection = null));
                }
            }, TextareaInput.prototype.getField = function() {
                return this.textarea;
            }, TextareaInput.prototype.supportsTouch = function() {
                return !1;
            }, TextareaInput.prototype.focus = function() {
                if ("nocursor" != this.cm.options.readOnly && (!mobile || activeElt() != this.textarea)) try {
                    this.textarea.focus();
                } catch (e) {}
            }, TextareaInput.prototype.blur = function() {
                this.textarea.blur();
            }, TextareaInput.prototype.resetPosition = function() {
                this.wrapper.style.top = this.wrapper.style.left = 0;
            }, TextareaInput.prototype.receivedFocus = function() {
                this.slowPoll();
            }, // Poll for input changes, using the normal rate of polling. This
            // runs as long as the editor is focused.
            TextareaInput.prototype.slowPoll = function() {
                var this$1 = this;
                this.pollingFast || this.polling.set(this.cm.options.pollInterval, function() {
                    this$1.poll(), this$1.cm.state.focused && this$1.slowPoll();
                });
            }, // When an event has just come in that is likely to add or change
            // something in the input textarea, we poll faster, to ensure that
            // the change appears on the screen quickly.
            TextareaInput.prototype.fastPoll = function() {
                function p() {
                    var changed = input.poll();
                    changed || missed ? (input.pollingFast = !1, input.slowPoll()) : (missed = !0, input.polling.set(60, p));
                }
                var missed = !1, input = this;
                input.pollingFast = !0, input.polling.set(20, p);
            }, // Read input from the textarea, and update the document to match.
            // When something is selected, it is present in the textarea, and
            // selected (unless it is huge, in which case a placeholder is
            // used). When nothing is selected, the cursor sits after previously
            // seen text (can be empty), which is stored in prevInput (we must
            // not reset the textarea when typing, because that breaks IME).
            TextareaInput.prototype.poll = function() {
                var this$1 = this, cm = this.cm, input = this.textarea, prevInput = this.prevInput;
                // Since this is called a *lot*, try to bail out as cheaply as
                // possible when it is clear that nothing happened. hasSelection
                // will be the case when there is a lot of text in the textarea,
                // in which case reading its value would be expensive.
                if (this.contextMenuPending || !cm.state.focused || hasSelection(input) && !prevInput && !this.composing || cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq) return !1;
                var text = input.value;
                // If nothing changed, bail.
                if (text == prevInput && !cm.somethingSelected()) return !1;
                // Work around nonsensical selection resetting in IE9/10, and
                // inexplicable appearance of private area unicode characters on
                // some key combos in Mac (#2689).
                if (ie && ie_version >= 9 && this.hasSelection === text || mac && /[\uf700-\uf7ff]/.test(text)) return cm.display.input.reset(), 
                !1;
                if (cm.doc.sel == cm.display.selForContextMenu) {
                    var first = text.charCodeAt(0);
                    if (8203 != first || prevInput || (prevInput = "​"), 8666 == first) return this.reset(), 
                    this.cm.execCommand("undo");
                }
                for (// Find the part of the input that is actually new
                var same = 0, l = Math.min(prevInput.length, text.length); same < l && prevInput.charCodeAt(same) == text.charCodeAt(same); ) ++same;
                return runInOp(cm, function() {
                    applyTextInput(cm, text.slice(same), prevInput.length - same, null, this$1.composing ? "*compose" : null), 
                    // Don't leave long text in the textarea, since it makes further polling slow
                    text.length > 1e3 || text.indexOf("\n") > -1 ? input.value = this$1.prevInput = "" : this$1.prevInput = text, 
                    this$1.composing && (this$1.composing.range.clear(), this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor("to"), {
                        className: "CodeMirror-composing"
                    }));
                }), !0;
            }, TextareaInput.prototype.ensurePolled = function() {
                this.pollingFast && this.poll() && (this.pollingFast = !1);
            }, TextareaInput.prototype.onKeyPress = function() {
                ie && ie_version >= 9 && (this.hasSelection = null), this.fastPoll();
            }, TextareaInput.prototype.onContextMenu = function(e) {
                // Select-all will be greyed out if there's nothing to select, so
                // this adds a zero-width space so that we can later check whether
                // it got selected.
                function prepareSelectAllHack() {
                    if (null != te.selectionStart) {
                        var selected = cm.somethingSelected(), extval = "​" + (selected ? te.value : "");
                        te.value = "⇚", // Used to catch context-menu undo
                        te.value = extval, input.prevInput = selected ? "" : "​", te.selectionStart = 1, 
                        te.selectionEnd = extval.length, // Re-set this, in case some other handler touched the
                        // selection in the meantime.
                        display.selForContextMenu = cm.doc.sel;
                    }
                }
                function rehide() {
                    // Try to detect the user choosing select-all
                    if (input.contextMenuPending = !1, input.wrapper.style.cssText = oldWrapperCSS, 
                    te.style.cssText = oldCSS, ie && ie_version < 9 && display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos), 
                    null != te.selectionStart) {
                        (!ie || ie && ie_version < 9) && prepareSelectAllHack();
                        var i = 0, poll = function() {
                            display.selForContextMenu == cm.doc.sel && 0 == te.selectionStart && te.selectionEnd > 0 && "​" == input.prevInput ? operation(cm, selectAll)(cm) : i++ < 10 ? display.detectingSelectAll = setTimeout(poll, 500) : (display.selForContextMenu = null, 
                            display.input.reset());
                        };
                        display.detectingSelectAll = setTimeout(poll, 200);
                    }
                }
                var input = this, cm = input.cm, display = cm.display, te = input.textarea, pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
                if (pos && !presto) {
                    // Opera is difficult.
                    // Reset the current text selection only if the click is done outside of the selection
                    // and 'resetSelectionOnContextMenu' option is true.
                    var reset = cm.options.resetSelectionOnContextMenu;
                    reset && cm.doc.sel.contains(pos) == -1 && operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);
                    var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;
                    input.wrapper.style.cssText = "position: absolute";
                    var wrapperBox = input.wrapper.getBoundingClientRect();
                    te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
                    var oldScrollY;
                    if (webkit && (oldScrollY = window.scrollY), // Work around Chrome issue (#2712)
                    display.input.focus(), webkit && window.scrollTo(null, oldScrollY), display.input.reset(), 
                    // Adds "Select all" to context menu in FF
                    cm.somethingSelected() || (te.value = input.prevInput = " "), input.contextMenuPending = !0, 
                    display.selForContextMenu = cm.doc.sel, clearTimeout(display.detectingSelectAll), 
                    ie && ie_version >= 9 && prepareSelectAllHack(), captureRightClick) {
                        e_stop(e);
                        var mouseup = function() {
                            off(window, "mouseup", mouseup), setTimeout(rehide, 20);
                        };
                        on(window, "mouseup", mouseup);
                    } else setTimeout(rehide, 50);
                }
            }, TextareaInput.prototype.readOnlyChanged = function(val) {
                val || this.reset(), this.textarea.disabled = "nocursor" == val;
            }, TextareaInput.prototype.setUneditable = function() {}, TextareaInput.prototype.needsContentAttribute = !1, 
            // EDITOR CONSTRUCTOR
            defineOptions(CodeMirror$1), addEditorMethods(CodeMirror$1);
            // Set up methods on CodeMirror's prototype to redirect to the editor's document.
            var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
            for (var prop in Doc.prototype) Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0 && (CodeMirror$1.prototype[prop] = function(method) {
                return function() {
                    return method.apply(this.doc, arguments);
                };
            }(Doc.prototype[prop]));
            // INPUT HANDLING
            // MODE DEFINITION AND QUERYING
            // Extra arguments are stored as the mode's dependencies, which is
            // used by (legacy) mechanisms like loadmode.js to automatically
            // load a mode. (Preferred mechanism is the require/define calls.)
            // Minimal default mode.
            // EXTENSIONS
            return eventMixin(Doc), CodeMirror$1.inputStyles = {
                textarea: TextareaInput,
                contenteditable: ContentEditableInput
            }, CodeMirror$1.defineMode = function(name) {
                CodeMirror$1.defaults.mode || "null" == name || (CodeMirror$1.defaults.mode = name), 
                defineMode.apply(this, arguments);
            }, CodeMirror$1.defineMIME = defineMIME, CodeMirror$1.defineMode("null", function() {
                return {
                    token: function(stream) {
                        return stream.skipToEnd();
                    }
                };
            }), CodeMirror$1.defineMIME("text/plain", "null"), CodeMirror$1.defineExtension = function(name, func) {
                CodeMirror$1.prototype[name] = func;
            }, CodeMirror$1.defineDocExtension = function(name, func) {
                Doc.prototype[name] = func;
            }, CodeMirror$1.fromTextArea = fromTextArea, addLegacyProps(CodeMirror$1), CodeMirror$1.version = "5.31.0", 
            CodeMirror$1;
        });
    }, /* 129 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(process, module) {
            "use strict";
            function _interopDefault(ex) {
                return ex && "object" == typeof ex && "default" in ex ? ex.default : ex;
            }
            // 
            function isFunction(test) {
                return "function" == typeof test;
            }
            // 
            function getComponentName(target) {
                return target.displayName || target.name || "Component";
            }
            // 
            function isStyledComponent(target) {
                return target && "string" == typeof target.styledComponentId;
            }
            /**
	 * super basic version of sprintf
	 */
            function format() {
                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                var a = args[0], b = [], c = void 0;
                for (c = 1; c < args.length; c += 1) b.push(args[c]);
                return b.forEach(function(d) {
                    a = a.replace(/%[a-z]/, d);
                }), a;
            }
            function stringifyRules(rules, selector, prefix) {
                var componentId = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "&", flatCSS = rules.join("").replace(COMMENT_REGEX, ""), cssStr = selector && prefix ? prefix + " " + selector + " { " + flatCSS + " }" : flatCSS;
                // stylis has no concept of state to be passed to plugins
                // but since JS is single=threaded, we can rely on that to ensure
                // these properties stay in sync with the current stylis run
                return _componentId = componentId, _selector = selector, _selectorRegexp = new RegExp("\\" + _selector + "\\b", "g"), 
                stylis(prefix || !selector ? "" : selector, cssStr);
            }
            /**
	 * Hyphenates a camelcased CSS property name, for example:
	 *
	 *   > hyphenateStyleName('backgroundColor')
	 *   < "background-color"
	 *   > hyphenateStyleName('MozTransition')
	 *   < "-moz-transition"
	 *   > hyphenateStyleName('msTransition')
	 *   < "-ms-transition"
	 *
	 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
	 * is converted to `-ms-`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
            function hyphenateStyleName(string) {
                return string.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern, "-ms-");
            }
            function flatten(chunk, executionContext, styleSheet) {
                if (Array.isArray(chunk)) {
                    for (var result, ruleSet = [], i = 0, len = chunk.length; i < len; i += 1) result = flatten(chunk[i], executionContext, styleSheet), 
                    null !== result && (Array.isArray(result) ? ruleSet.push.apply(ruleSet, result) : ruleSet.push(result));
                    return ruleSet;
                }
                if (isFalsish(chunk)) return null;
                /* Handle other components */
                if (isStyledComponent(chunk)) return "." + chunk.styledComponentId;
                /* Either execute or defer the function */
                if (isFunction(chunk)) {
                    if (executionContext) {
                        if ("production" !== process.env.NODE_ENV) /* Warn if not referring styled component */
                        try {
                            // eslint-disable-next-line new-cap
                            reactIs.isElement(new chunk(executionContext)) && console.warn(getComponentName(chunk) + " is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.");
                        } catch (e) {}
                        return flatten(chunk(executionContext), executionContext, styleSheet);
                    }
                    return chunk;
                }
                return chunk instanceof Keyframes ? styleSheet ? (chunk.inject(styleSheet), chunk.getName()) : chunk : isPlainObject(chunk) ? objToCss(chunk) : chunk.toString();
            }
            // 
            function css(styles) {
                for (var _len = arguments.length, interpolations = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) interpolations[_key - 1] = arguments[_key];
                return flatten(isFunction(styles) || isPlainObject(styles) ? interleave(EMPTY_ARRAY, [ styles ].concat(interpolations)) : interleave(styles, interpolations));
            }
            // 
            function constructWithOptions(componentConstructor, tag) {
                var options = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : EMPTY_OBJECT;
                if (!reactIs.isValidElementType(tag)) throw new StyledComponentsError(1, String(tag));
                /* This is callable directly as a template function */
                // $FlowFixMe: Not typed to avoid destructuring arguments
                var templateFunction = function() {
                    return componentConstructor(tag, options, css.apply(void 0, arguments));
                };
                /* If config methods are called, wrap up a new template function and merge options */
                return templateFunction.withConfig = function(config) {
                    return constructWithOptions(componentConstructor, tag, _extends({}, options, config));
                }, templateFunction.attrs = function(attrs) {
                    return constructWithOptions(componentConstructor, tag, _extends({}, options, {
                        attrs: _extends({}, options.attrs || EMPTY_OBJECT, attrs)
                    }));
                }, templateFunction;
            }
            // 
            // Source: https://github.com/garycourt/murmurhash-js/blob/master/murmurhash2_gc.js
            function murmurhash(c) {
                for (var b, e = 0 | c.length, a = 0 | e, d = 0; e >= 4; ) b = 255 & c.charCodeAt(d) | (255 & c.charCodeAt(++d)) << 8 | (255 & c.charCodeAt(++d)) << 16 | (255 & c.charCodeAt(++d)) << 24, 
                b = 1540483477 * (65535 & b) + ((1540483477 * (b >>> 16) & 65535) << 16), b ^= b >>> 24, 
                b = 1540483477 * (65535 & b) + ((1540483477 * (b >>> 16) & 65535) << 16), a = 1540483477 * (65535 & a) + ((1540483477 * (a >>> 16) & 65535) << 16) ^ b, 
                e -= 4, ++d;
                switch (e) {
                  case 3:
                    a ^= (255 & c.charCodeAt(d + 2)) << 16;

                  case 2:
                    a ^= (255 & c.charCodeAt(d + 1)) << 8;

                  case 1:
                    a ^= 255 & c.charCodeAt(d), a = 1540483477 * (65535 & a) + ((1540483477 * (a >>> 16) & 65535) << 16);
                }
                return a ^= a >>> 13, a = 1540483477 * (65535 & a) + ((1540483477 * (a >>> 16) & 65535) << 16), 
                (a ^ a >>> 15) >>> 0;
            }
            /* input a number, usually a hash and convert it to base-52 */
            function generateAlphabeticName(code) {
                var name = "", x = void 0;
                /* get a char and divide by alphabet-length */
                for (x = code; x > charsLength; x = Math.floor(x / charsLength)) name = getAlphabeticChar(x % charsLength) + name;
                return getAlphabeticChar(x % charsLength) + name;
            }
            // 
            function isStaticRules(rules, attrs) {
                for (var i = 0; i < rules.length; i += 1) {
                    var rule = rules[i];
                    // recursive case
                    if (Array.isArray(rule) && !isStaticRules(rule)) return !1;
                    if (isFunction(rule) && !isStyledComponent(rule)) // functions are allowed to be static if they're just being
                    // used to get the classname of a nested styled component
                    return !1;
                }
                if (void 0 !== attrs) // eslint-disable-next-line guard-for-in, no-restricted-syntax
                for (var key in attrs) {
                    var value = attrs[key];
                    if (isFunction(value)) return !1;
                }
                return !0;
            }
            /**
	 * TODO: Explore using CSS.escape when it becomes more available
	 * in evergreen browsers.
	 */
            function escape(str) {
                return str.replace(escapeRegex, "-").replace(dashesAtEnds, "");
            }
            // 
            function isTag(target) {
                return "string" == typeof target;
            }
            // 
            function generateDisplayName(target) {
                return isTag(target) ? "styled." + target : "Styled(" + getComponentName(target) + ")";
            }
            function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
                if ("string" != typeof sourceComponent) {
                    // don't hoist over string (html) components
                    var inheritedComponent = getPrototypeOf(sourceComponent);
                    inheritedComponent && inheritedComponent !== objectPrototype && hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
                    // eslint-disable-next-line no-plusplus
                    for (var keys = arrayPrototype.concat(getOwnPropertyNames(sourceComponent), // $FlowFixMe
                    getOwnPropertySymbols(sourceComponent)), targetStatics = TYPE_STATICS[targetComponent.$$typeof] || REACT_STATICS, sourceStatics = TYPE_STATICS[sourceComponent.$$typeof] || REACT_STATICS, i = keys.length, descriptor = void 0, key = void 0; i--; ) if (key = keys[i], 
                    // $FlowFixMe
                    !(KNOWN_STATICS[key] || blacklist && blacklist[key] || sourceStatics && sourceStatics[key] || targetStatics && targetStatics[key]) && (descriptor = getOwnPropertyDescriptor(sourceComponent, key))) try {
                        // Avoid failures from read-only properties
                        defineProperty$1(targetComponent, key, descriptor);
                    } catch (e) {}
                    return targetComponent;
                }
                return targetComponent;
            }
            // 
            function isDerivedReactComponent(fn) {
                return !!(fn && fn.prototype && fn.prototype.isReactComponent);
            }
            /* We depend on components having unique IDs */
            function generateId(_ComponentStyle, _displayName, parentComponentId) {
                var displayName = "string" != typeof _displayName ? "sc" : escape(_displayName), nr = (identifiers[displayName] || 0) + 1;
                identifiers[displayName] = nr;
                var componentId = displayName + "-" + _ComponentStyle.generateName(displayName + nr);
                return parentComponentId ? parentComponentId + "-" + componentId : componentId;
            }
            function createStyledComponent(target, options, rules) {
                var isTargetStyledComp = isStyledComponent(target), isClass = !isTag(target), _options$displayName = options.displayName, displayName = void 0 === _options$displayName ? generateDisplayName(target) : _options$displayName, _options$componentId = options.componentId, componentId = void 0 === _options$componentId ? generateId(ComponentStyle, options.displayName, options.parentComponentId) : _options$componentId, _options$ParentCompon = options.ParentComponent, ParentComponent = void 0 === _options$ParentCompon ? StyledComponent : _options$ParentCompon, attrs = options.attrs, styledComponentId = options.displayName && options.componentId ? escape(options.displayName) + "-" + options.componentId : options.componentId || componentId, finalAttrs = // $FlowFixMe
                isTargetStyledComp && target.attrs ? _extends({}, target.attrs, attrs) : attrs, componentStyle = new ComponentStyle(isTargetStyledComp ? // fold the underlying StyledComponent rules up (implicit extend)
                // $FlowFixMe
                target.componentStyle.rules.concat(rules) : rules, finalAttrs, styledComponentId), WrappedStyledComponent = React__default.forwardRef(function(props, ref) {
                    return React__default.createElement(ParentComponent, _extends({}, props, {
                        forwardedClass: WrappedStyledComponent,
                        forwardedRef: ref
                    }));
                });
                // $FlowFixMe
                // $FlowFixMe
                // $FlowFixMe
                // fold the underlying StyledComponent target up since we folded the styles
                // $FlowFixMe
                // $FlowFixMe
                // $FlowFixMe
                // $FlowFixMe
                return WrappedStyledComponent.attrs = finalAttrs, WrappedStyledComponent.componentStyle = componentStyle, 
                WrappedStyledComponent.displayName = displayName, WrappedStyledComponent.styledComponentId = styledComponentId, 
                WrappedStyledComponent.target = isTargetStyledComp ? target.target : target, WrappedStyledComponent.withComponent = function(tag) {
                    var previousComponentId = options.componentId, optionsToCopy = objectWithoutProperties(options, [ "componentId" ]), newComponentId = previousComponentId && previousComponentId + "-" + (isTag(tag) ? tag : escape(getComponentName(tag))), newOptions = _extends({}, optionsToCopy, {
                        attrs: finalAttrs,
                        componentId: newComponentId,
                        ParentComponent: ParentComponent
                    });
                    return createStyledComponent(tag, newOptions, rules);
                }, "production" !== process.env.NODE_ENV && (WrappedStyledComponent.warnTooManyClasses = createWarnTooManyClasses(displayName)), 
                WrappedStyledComponent.toString = function() {
                    return "." + WrappedStyledComponent.styledComponentId;
                }, isClass && hoistNonReactStatics(WrappedStyledComponent, target, {
                    // all SC-specific things should not be hoisted
                    attrs: !0,
                    componentStyle: !0,
                    displayName: !0,
                    styledComponentId: !0,
                    target: !0,
                    warnTooManyClasses: !0,
                    withComponent: !0
                }), WrappedStyledComponent;
            }
            function createGlobalStyle(strings) {
                for (var _len = arguments.length, interpolations = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) interpolations[_key - 1] = arguments[_key];
                var rules = css.apply(void 0, [ strings ].concat(interpolations)), id = "sc-global-" + murmurhash(JSON.stringify(rules)), style = new GlobalStyle(rules, id), GlobalStyleComponent = function(_React$Component) {
                    function GlobalStyleComponent() {
                        classCallCheck(this, GlobalStyleComponent);
                        var _this = possibleConstructorReturn(this, _React$Component.call(this)), _this$constructor = _this.constructor, globalStyle = _this$constructor.globalStyle, styledComponentId = _this$constructor.styledComponentId;
                        /**
	       * This fixes HMR compatiblility. Don't ask me why, but this combination of
	       * caching the closure variables via statics and then persisting the statics in
	       * state works across HMR where no other combination did. ¯\_(ツ)_/¯
	       */
                        return IS_BROWSER && (window.scCGSHMRCache[styledComponentId] = (window.scCGSHMRCache[styledComponentId] || 0) + 1), 
                        _this.state = {
                            globalStyle: globalStyle,
                            styledComponentId: styledComponentId
                        }, _this;
                    }
                    return inherits(GlobalStyleComponent, _React$Component), GlobalStyleComponent.prototype.componentDidMount = function() {
                        "production" !== process.env.NODE_ENV && IS_BROWSER && window.scCGSHMRCache[this.state.styledComponentId] > 1 && !this.props.suppressMultiMountWarning && console.warn("The global style component " + this.state.styledComponentId + " was composed and rendered multiple times in your React component tree. Only the last-rendered copy will have its styles remain in <head> (or your StyleSheetManager target.)");
                    }, GlobalStyleComponent.prototype.componentWillUnmount = function() {
                        window.scCGSHMRCache[this.state.styledComponentId] && (window.scCGSHMRCache[this.state.styledComponentId] -= 1), 
                        /**
	       * Depending on the order "render" is called this can cause the styles to be lost
	       * until the next render pass of the remaining instance, which may
	       * not be immediate.
	       */
                        0 === window.scCGSHMRCache[this.state.styledComponentId] && this.state.globalStyle.removeStyles(this.styleSheet);
                    }, GlobalStyleComponent.prototype.render = function() {
                        var _this2 = this;
                        return "production" !== process.env.NODE_ENV && React__default.Children.count(this.props.children) && console.warn("The global style component " + this.state.styledComponentId + " was given child JSX. createGlobalStyle does not render children."), 
                        React__default.createElement(StyleSheetConsumer, null, function(styleSheet) {
                            _this2.styleSheet = styleSheet || StyleSheet.master;
                            var globalStyle = _this2.state.globalStyle;
                            return globalStyle.isStatic ? (globalStyle.renderStyles(STATIC_EXECUTION_CONTEXT, _this2.styleSheet), 
                            null) : React__default.createElement(ThemeConsumer, null, function(theme) {
                                var defaultProps = _this2.constructor.defaultProps, context = _extends({}, _this2.props);
                                return "undefined" != typeof theme && (context.theme = determineTheme(_this2.props, theme, defaultProps)), 
                                globalStyle.renderStyles(context, _this2.styleSheet), null;
                            });
                        });
                    }, GlobalStyleComponent;
                }(React__default.Component);
                return GlobalStyleComponent.defaultProps = {
                    suppressMultiMountWarning: !1
                }, GlobalStyleComponent.globalStyle = style, GlobalStyleComponent.styledComponentId = id, 
                "production" !== process.env.NODE_ENV ? GlobalStyleComponent.propTypes = {
                    suppressMultiMountWarning: PropTypes.bool
                } : void 0, GlobalStyleComponent;
            }
            function keyframes(strings) {
                /* Warning if you've used keyframes on React Native */
                "production" !== process.env.NODE_ENV && "undefined" != typeof navigator && "ReactNative" === navigator.product && console.warn("`keyframes` cannot be used on ReactNative, only on the web. To do animation in ReactNative please use Animated.");
                for (var _len = arguments.length, interpolations = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) interpolations[_key - 1] = arguments[_key];
                var rules = css.apply(void 0, [ strings ].concat(interpolations)), name = generateAlphabeticName(murmurhash(replaceWhitespace(JSON.stringify(rules))));
                return new Keyframes(name, stringifyRules(rules, name, "@keyframes"));
            }
            Object.defineProperty(exports, "__esModule", {
                value: !0
            });
            var Stylis = _interopDefault(__webpack_require__(130)), _insertRulePlugin = _interopDefault(__webpack_require__(131)), React = __webpack_require__(108), React__default = _interopDefault(React), reactIs = __webpack_require__(132), memoize = _interopDefault(__webpack_require__(135)), PropTypes = _interopDefault(__webpack_require__(109)), ReactDOM = _interopDefault(__webpack_require__(120)), validAttr = _interopDefault(__webpack_require__(136)), interleave = function(strings, interpolations) {
                for (var result = [ strings[0] ], i = 0, len = interpolations.length; i < len; i += 1) result.push(interpolations[i], strings[i + 1]);
                return result;
            }, _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
                return typeof obj;
            } : function(obj) {
                return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            }, classCallCheck = function(instance, Constructor) {
                if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
            }, createClass = function() {
                function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                        "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                return function(Constructor, protoProps, staticProps) {
                    return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                    Constructor;
                };
            }(), _extends = Object.assign || function(target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i];
                    for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
                }
                return target;
            }, inherits = function(subClass, superClass) {
                if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                        value: subClass,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
            }, objectWithoutProperties = function(obj, keys) {
                var target = {};
                for (var i in obj) keys.indexOf(i) >= 0 || Object.prototype.hasOwnProperty.call(obj, i) && (target[i] = obj[i]);
                return target;
            }, possibleConstructorReturn = function(self, call) {
                if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return !call || "object" != typeof call && "function" != typeof call ? self : call;
            }, isPlainObject = function(x) {
                return "object" === ("undefined" == typeof x ? "undefined" : _typeof(x)) && x.constructor === Object;
            }, EMPTY_ARRAY = Object.freeze([]), EMPTY_OBJECT = Object.freeze({}), SC_ATTR = "undefined" != typeof process && process.env.SC_ATTR || "data-styled", SC_VERSION_ATTR = "data-styled-version", SC_STREAM_ATTR = "data-styled-streamed", IS_BROWSER = "undefined" != typeof window && "HTMLElement" in window, DISABLE_SPEEDY = "production" !== process.env.NODE_ENV, STATIC_EXECUTION_CONTEXT = {}, ERRORS = "production" !== process.env.NODE_ENV ? {
                "1": "Cannot create styled-component for component: %s.\n\n",
                "2": "Can't collect styles once you've consumed a `ServerStyleSheet`'s styles! `ServerStyleSheet` is a one off instance for each server-side render cycle.\n\n- Are you trying to reuse it across renders?\n- Are you accidentally calling collectStyles twice?\n\n",
                "3": "Streaming SSR is only supported in a Node.js environment; Please do not try to call this method in the browser.\n\n",
                "4": "The `StyleSheetManager` expects a valid target or sheet prop!\n\n- Does this error occur on the client and is your target falsy?\n- Does this error occur on the server and is the sheet falsy?\n\n",
                "5": "The clone method cannot be used on the client!\n\n- Are you running in a client-like environment on the server?\n- Are you trying to run SSR on the client?\n\n",
                "6": "Trying to insert a new style tag, but the given Node is unmounted!\n\n- Are you using a custom target that isn't mounted?\n- Does your document not have a valid head element?\n- Have you accidentally removed a style tag manually?\n\n",
                "7": 'ThemeProvider: Please return an object from your "theme" prop function, e.g.\n\n```js\ntheme={() => ({})}\n```\n\n',
                "8": 'ThemeProvider: Please make your "theme" prop an object.\n\n',
                "9": "Missing document `<head>`\n\n",
                "10": "Cannot find a StyleSheet instance. Usually this happens if there are multiple copies of styled-components loaded at once. Check out this issue for how to troubleshoot and fix the common cases where this situation can happen: https://github.com/styled-components/styled-components/issues/1941#issuecomment-417862021\n\n",
                "11": "_This error was replaced with a dev-time warning, it will be deleted for v4 final._ [createGlobalStyle] received children which will not be rendered. Please use the component without passing children elements.\n\n",
                "12": "It seems you are interpolating a keyframe declaration (%s) into an untagged string. This was supported in styled-components v3, but is not longer supported in v4 as keyframes are now injected on-demand. Please wrap your string in the css\\`\\` helper (see https://www.styled-components.com/docs/api#css), which ensures the styles are injected correctly.\n"
            } : {}, StyledComponentsError = function(_Error) {
                function StyledComponentsError(code) {
                    classCallCheck(this, StyledComponentsError);
                    for (var _len2 = arguments.length, interpolations = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) interpolations[_key2 - 1] = arguments[_key2];
                    if ("production" === process.env.NODE_ENV) var _this = possibleConstructorReturn(this, _Error.call(this, "An error occurred. See https://github.com/styled-components/styled-components/blob/master/src/utils/errors.md#" + code + " for more information. " + (interpolations ? "Additional arguments: " + interpolations.join(", ") : ""))); else var _this = possibleConstructorReturn(this, _Error.call(this, format.apply(void 0, [ ERRORS[code] ].concat(interpolations)).trim()));
                    return possibleConstructorReturn(_this);
                }
                return inherits(StyledComponentsError, _Error), StyledComponentsError;
            }(Error), SC_COMPONENT_ID = /^[^\S\n]*?\/\* sc-component-id:\s*(\S+)\s+\*\//gm, extractComps = function(maybeCSS) {
                var css = "" + (maybeCSS || ""), existingComponents = [];
                return css.replace(SC_COMPONENT_ID, function(match, componentId, matchIndex) {
                    return existingComponents.push({
                        componentId: componentId,
                        matchIndex: matchIndex
                    }), match;
                }), existingComponents.map(function(_ref, i) {
                    var componentId = _ref.componentId, matchIndex = _ref.matchIndex, nextComp = existingComponents[i + 1], cssFromDOM = nextComp ? css.slice(matchIndex, nextComp.matchIndex) : css.slice(matchIndex);
                    return {
                        componentId: componentId,
                        cssFromDOM: cssFromDOM
                    };
                });
            }, COMMENT_REGEX = /^\s*\/\/.*$/gm, stylisSplitter = new Stylis({
                global: !1,
                cascade: !0,
                keyframe: !1,
                prefix: !1,
                compress: !1,
                semicolon: !0
            }), stylis = new Stylis({
                global: !1,
                cascade: !0,
                keyframe: !1,
                prefix: !0,
                compress: !1,
                semicolon: !1
            }), parsingRules = [], returnRulesPlugin = function(context) {
                if (context === -2) {
                    var parsedRules = parsingRules;
                    return parsingRules = [], parsedRules;
                }
            }, parseRulesPlugin = _insertRulePlugin(function(rule) {
                parsingRules.push(rule);
            }), _componentId = void 0, _selector = void 0, _selectorRegexp = void 0, selfReferenceReplacer = function(match, offset, string) {
                // the first self-ref is always untouched
                // there should be at least two self-refs to do a replacement (.b > .b)
                // no consecutive self refs (.b.b); that is a precedence boost and treated differently
                return offset > 0 && string.slice(0, offset).indexOf(_selector) !== -1 && string.slice(offset - _selector.length, offset) !== _selector ? "." + _componentId : match;
            }, selfReferenceReplacementPlugin = function(context, _, selectors) {
                2 === context && selectors.length && selectors[0].lastIndexOf(_selector) > 0 && (// eslint-disable-next-line no-param-reassign
                selectors[0] = selectors[0].replace(_selectorRegexp, selfReferenceReplacer));
            };
            stylis.use([ selfReferenceReplacementPlugin, parseRulesPlugin, returnRulesPlugin ]), 
            stylisSplitter.use([ parseRulesPlugin, returnRulesPlugin ]);
            var splitByRules = function(css) {
                return stylisSplitter("", css);
            }, getNonce = function() {
                return "undefined" != typeof __webpack_nonce__ ? __webpack_nonce__ : null;
            }, once = function(cb) {
                var called = !1;
                return function() {
                    called || (called = !0, cb());
                };
            }, addNameForId = function(names, id, name) {
                if (name) {
                    // eslint-disable-next-line no-param-reassign
                    var namesForId = names[id] || (names[id] = Object.create(null));
                    namesForId[name] = !0;
                }
            }, resetIdNames = function(names, id) {
                // eslint-disable-next-line no-param-reassign
                names[id] = Object.create(null);
            }, hasNameForId = function(names) {
                return function(id, name) {
                    return void 0 !== names[id] && names[id][name];
                };
            }, stringifyNames = function(names) {
                var str = "";
                // eslint-disable-next-line guard-for-in
                for (var id in names) str += Object.keys(names[id]).join(" ") + " ";
                return str.trim();
            }, cloneNames = function(names) {
                var clone = Object.create(null);
                // eslint-disable-next-line guard-for-in
                for (var id in names) clone[id] = _extends({}, names[id]);
                return clone;
            }, sheetForTag = function(tag) {
                // $FlowFixMe
                if (tag.sheet) return tag.sheet;
                for (var size = document.styleSheets.length, i = 0; i < size; i += 1) {
                    var sheet = document.styleSheets[i];
                    // $FlowFixMe
                    if (sheet.ownerNode === tag) return sheet;
                }
                /* we should always be able to find a tag */
                throw new StyledComponentsError(10);
            }, safeInsertRule = function(sheet, cssRule, index) {
                /* abort early if cssRule string is falsy */
                if (!cssRule) return !1;
                var maxIndex = sheet.cssRules.length;
                try {
                    /* use insertRule and cap passed index with maxIndex (no of cssRules) */
                    sheet.insertRule(cssRule, index <= maxIndex ? index : maxIndex);
                } catch (err) {
                    /* any error indicates an invalid rule */
                    return !1;
                }
                return !0;
            }, deleteRules = function(sheet, removalIndex, size) {
                for (var lowerBound = removalIndex - size, i = removalIndex; i > lowerBound; i -= 1) sheet.deleteRule(i);
            }, makeTextMarker = function(id) {
                return "\n/* sc-component-id: " + id + " */\n";
            }, addUpUntilIndex = function(sizes, index) {
                for (var totalUpToIndex = 0, i = 0; i <= index; i += 1) totalUpToIndex += sizes[i];
                return totalUpToIndex;
            }, makeStyleTag = function(target, tagEl, insertBefore) {
                var el = document.createElement("style");
                el.setAttribute(SC_ATTR, ""), el.setAttribute(SC_VERSION_ATTR, "4.0.3");
                var nonce = getNonce();
                if (nonce && el.setAttribute("nonce", nonce), /* Work around insertRule quirk in EdgeHTML */
                el.appendChild(document.createTextNode("")), target && !tagEl) /* Append to target when no previous element was passed */
                target.appendChild(el); else {
                    if (!tagEl || !target || !tagEl.parentNode) throw new StyledComponentsError(6);
                    /* Insert new style tag after the previous one */
                    tagEl.parentNode.insertBefore(el, insertBefore ? tagEl : tagEl.nextSibling);
                }
                return el;
            }, wrapAsHtmlTag = function(css, names) {
                return function(additionalAttrs) {
                    var nonce = getNonce(), attrs = [ nonce && 'nonce="' + nonce + '"', SC_ATTR + '="' + stringifyNames(names) + '"', SC_VERSION_ATTR + '="4.0.3"', additionalAttrs ], htmlAttr = attrs.filter(Boolean).join(" ");
                    return "<style " + htmlAttr + ">" + css() + "</style>";
                };
            }, wrapAsElement = function(css, names) {
                return function() {
                    var _props, props = (_props = {}, _props[SC_ATTR] = stringifyNames(names), _props[SC_VERSION_ATTR] = "4.0.3", 
                    _props), nonce = getNonce();
                    // eslint-disable-next-line react/no-danger
                    // $FlowFixMe
                    return nonce && (props.nonce = nonce), React__default.createElement("style", _extends({}, props, {
                        dangerouslySetInnerHTML: {
                            __html: css()
                        }
                    }));
                };
            }, getIdsFromMarkersFactory = function(markers) {
                return function() {
                    return Object.keys(markers);
                };
            }, makeSpeedyTag = function(el, getImportRuleTag) {
                var names = Object.create(null), markers = Object.create(null), sizes = [], extractImport = void 0 !== getImportRuleTag, usedImportRuleTag = !1, insertMarker = function(id) {
                    var prev = markers[id];
                    return void 0 !== prev ? prev : (markers[id] = sizes.length, sizes.push(0), resetIdNames(names, id), 
                    markers[id]);
                }, insertRules = function(id, cssRules, name) {
                    for (var marker = insertMarker(id), sheet = sheetForTag(el), insertIndex = addUpUntilIndex(sizes, marker), injectedRules = 0, importRules = [], cssRulesSize = cssRules.length, i = 0; i < cssRulesSize; i += 1) {
                        var cssRule = cssRules[i], mayHaveImport = extractImport;
                        /* @import rules are reordered to appear first */
                        mayHaveImport && cssRule.indexOf("@import") !== -1 ? importRules.push(cssRule) : safeInsertRule(sheet, cssRule, insertIndex + injectedRules) && (mayHaveImport = !1, 
                        injectedRules += 1);
                    }
                    extractImport && importRules.length > 0 && (usedImportRuleTag = !0, // $FlowFixMe
                    getImportRuleTag().insertRules(id + "-import", importRules)), sizes[marker] += injectedRules, 
                    /* add up no of injected rules */
                    addNameForId(names, id, name);
                }, removeRules = function(id) {
                    var marker = markers[id];
                    if (void 0 !== marker) {
                        var size = sizes[marker], sheet = sheetForTag(el), removalIndex = addUpUntilIndex(sizes, marker) - 1;
                        deleteRules(sheet, removalIndex, size), sizes[marker] = 0, resetIdNames(names, id), 
                        extractImport && usedImportRuleTag && // $FlowFixMe
                        getImportRuleTag().removeRules(id + "-import");
                    }
                }, css = function() {
                    var _sheetForTag = sheetForTag(el), cssRules = _sheetForTag.cssRules, str = "";
                    // eslint-disable-next-line guard-for-in
                    for (var id in markers) {
                        str += makeTextMarker(id);
                        for (var marker = markers[id], end = addUpUntilIndex(sizes, marker), size = sizes[marker], i = end - size; i < end; i += 1) {
                            var rule = cssRules[i];
                            void 0 !== rule && (str += rule.cssText);
                        }
                    }
                    return str;
                };
                return {
                    clone: function() {
                        throw new StyledComponentsError(5);
                    },
                    css: css,
                    getIds: getIdsFromMarkersFactory(markers),
                    hasNameForId: hasNameForId(names),
                    insertMarker: insertMarker,
                    insertRules: insertRules,
                    removeRules: removeRules,
                    sealed: !1,
                    styleTag: el,
                    toElement: wrapAsElement(css, names),
                    toHTML: wrapAsHtmlTag(css, names)
                };
            }, makeTextNode = function(id) {
                return document.createTextNode(makeTextMarker(id));
            }, makeBrowserTag = function(el, getImportRuleTag) {
                var names = Object.create(null), markers = Object.create(null), extractImport = void 0 !== getImportRuleTag, usedImportRuleTag = !1, insertMarker = function(id) {
                    var prev = markers[id];
                    return void 0 !== prev ? prev : (markers[id] = makeTextNode(id), el.appendChild(markers[id]), 
                    names[id] = Object.create(null), markers[id]);
                }, insertRules = function(id, cssRules, name) {
                    for (var marker = insertMarker(id), importRules = [], cssRulesSize = cssRules.length, i = 0; i < cssRulesSize; i += 1) {
                        var rule = cssRules[i], mayHaveImport = extractImport;
                        if (mayHaveImport && rule.indexOf("@import") !== -1) importRules.push(rule); else {
                            mayHaveImport = !1;
                            var separator = i === cssRulesSize - 1 ? "" : " ";
                            marker.appendData("" + rule + separator);
                        }
                    }
                    addNameForId(names, id, name), extractImport && importRules.length > 0 && (usedImportRuleTag = !0, 
                    // $FlowFixMe
                    getImportRuleTag().insertRules(id + "-import", importRules));
                }, removeRules = function(id) {
                    var marker = markers[id];
                    if (void 0 !== marker) {
                        /* create new empty text node and replace the current one */
                        var newMarker = makeTextNode(id);
                        el.replaceChild(newMarker, marker), markers[id] = newMarker, resetIdNames(names, id), 
                        extractImport && usedImportRuleTag && // $FlowFixMe
                        getImportRuleTag().removeRules(id + "-import");
                    }
                }, css = function() {
                    var str = "";
                    // eslint-disable-next-line guard-for-in
                    for (var id in markers) str += markers[id].data;
                    return str;
                };
                return {
                    clone: function() {
                        throw new StyledComponentsError(5);
                    },
                    css: css,
                    getIds: getIdsFromMarkersFactory(markers),
                    hasNameForId: hasNameForId(names),
                    insertMarker: insertMarker,
                    insertRules: insertRules,
                    removeRules: removeRules,
                    sealed: !1,
                    styleTag: el,
                    toElement: wrapAsElement(css, names),
                    toHTML: wrapAsHtmlTag(css, names)
                };
            }, makeServerTag = function makeServerTag(namesArg, markersArg) {
                var names = void 0 === namesArg ? Object.create(null) : namesArg, markers = void 0 === markersArg ? Object.create(null) : markersArg, insertMarker = function(id) {
                    var prev = markers[id];
                    return void 0 !== prev ? prev : markers[id] = [ "" ];
                }, insertRules = function(id, cssRules, name) {
                    var marker = insertMarker(id);
                    marker[0] += cssRules.join(" "), addNameForId(names, id, name);
                }, removeRules = function(id) {
                    var marker = markers[id];
                    void 0 !== marker && (marker[0] = "", resetIdNames(names, id));
                }, css = function() {
                    var str = "";
                    // eslint-disable-next-line guard-for-in
                    for (var id in markers) {
                        var cssForId = markers[id][0];
                        cssForId && (str += makeTextMarker(id) + cssForId);
                    }
                    return str;
                }, clone = function() {
                    var namesClone = cloneNames(names), markersClone = Object.create(null);
                    // eslint-disable-next-line guard-for-in
                    for (var id in markers) markersClone[id] = [ markers[id][0] ];
                    return makeServerTag(namesClone, markersClone);
                }, tag = {
                    clone: clone,
                    css: css,
                    getIds: getIdsFromMarkersFactory(markers),
                    hasNameForId: hasNameForId(names),
                    insertMarker: insertMarker,
                    insertRules: insertRules,
                    removeRules: removeRules,
                    sealed: !1,
                    styleTag: null,
                    toElement: wrapAsElement(css, names),
                    toHTML: wrapAsHtmlTag(css, names)
                };
                return tag;
            }, makeTag = function(target, tagEl, forceServer, insertBefore, getImportRuleTag) {
                if (IS_BROWSER && !forceServer) {
                    var el = makeStyleTag(target, tagEl, insertBefore);
                    return DISABLE_SPEEDY ? makeBrowserTag(el, getImportRuleTag) : makeSpeedyTag(el, getImportRuleTag);
                }
                return makeServerTag();
            }, makeRehydrationTag = function(tag, els, extracted, immediateRehydration) {
                /* rehydration function that adds all rules to the new tag */
                var rehydrate = once(function() {
                    /* add all extracted components to the new tag */
                    for (var i = 0, len = extracted.length; i < len; i += 1) {
                        var _extracted$i = extracted[i], componentId = _extracted$i.componentId, cssFromDOM = _extracted$i.cssFromDOM, cssRules = splitByRules(cssFromDOM);
                        tag.insertRules(componentId, cssRules);
                    }
                    /* remove old HTMLStyleElements, since they have been rehydrated */
                    for (var _i = 0, _len = els.length; _i < _len; _i += 1) {
                        var el = els[_i];
                        el.parentNode && el.parentNode.removeChild(el);
                    }
                });
                return immediateRehydration && rehydrate(), _extends({}, tag, {
                    /* add rehydration hook to methods */
                    insertMarker: function(id) {
                        return rehydrate(), tag.insertMarker(id);
                    },
                    insertRules: function(id, cssRules, name) {
                        return rehydrate(), tag.insertRules(id, cssRules, name);
                    },
                    removeRules: function(id) {
                        return rehydrate(), tag.removeRules(id);
                    }
                });
            }, SPLIT_REGEX = /\s+/, MAX_SIZE = void 0;
            /* in speedy mode we can keep a lot more rules in a sheet before a slowdown can be expected */
            MAX_SIZE = IS_BROWSER ? DISABLE_SPEEDY ? 40 : 1e3 : -1;
            var _TYPE_STATICS, sheetRunningId = 0, master = void 0, StyleSheet = function() {
                /* a map from ids to tags */
                /* deferred rules for a given id */
                /* this is used for not reinjecting rules via hasNameForId() */
                /* when rules for an id are removed using remove() we have to ignore rehydratedNames for it */
                /* a list of tags belonging to this StyleSheet */
                /* a tag for import rules */
                /* current capacity until a new tag must be created */
                /* children (aka clones) of this StyleSheet inheriting all and future injections */
                function StyleSheet() {
                    var _this = this, target = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : IS_BROWSER ? document.head : null, forceServer = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                    classCallCheck(this, StyleSheet), this.getImportRuleTag = function() {
                        var importRuleTag = _this.importRuleTag;
                        if (void 0 !== importRuleTag) return importRuleTag;
                        var firstTag = _this.tags[0], insertBefore = !0;
                        return _this.importRuleTag = makeTag(_this.target, firstTag ? firstTag.styleTag : null, _this.forceServer, insertBefore);
                    }, sheetRunningId += 1, this.id = sheetRunningId, this.forceServer = forceServer, 
                    this.target = forceServer ? null : target, this.tagMap = {}, this.deferred = {}, 
                    this.rehydratedNames = {}, this.ignoreRehydratedNames = {}, this.tags = [], this.capacity = 1, 
                    this.clones = [];
                }
                /* rehydrate all SSR'd style tags */
                /* retrieve a "master" instance of StyleSheet which is typically used when no other is available
	   * The master StyleSheet is targeted by createGlobalStyle, keyframes, and components outside of any
	    * StyleSheetManager's context */
                /* reset the internal "master" instance */
                /* adds "children" to the StyleSheet that inherit all of the parents' rules
	   * while their own rules do not affect the parent */
                /* force StyleSheet to create a new tag on the next injection */
                /* get a tag for a given componentId, assign the componentId to one, or shard */
                /* mainly for createGlobalStyle to check for its id */
                /* caching layer checking id+name to already have a corresponding tag and injected rules */
                /* registers a componentId and registers it on its tag */
                /* injects rules for a given id with a name that will need to be cached */
                /* removes all rules for a given id, which doesn't remove its marker but resets it */
                return StyleSheet.prototype.rehydrate = function() {
                    if (!IS_BROWSER || this.forceServer) return this;
                    var els = [], extracted = [], isStreamed = !1, nodes = document.querySelectorAll("style[" + SC_ATTR + "][" + SC_VERSION_ATTR + '="4.0.3"]'), nodesSize = nodes.length;
                    /* abort rehydration if no previous style tags were found */
                    if (0 === nodesSize) return this;
                    for (var i = 0; i < nodesSize; i += 1) {
                        // $FlowFixMe: We can trust that all elements in this query are style elements
                        var el = nodes[i];
                        /* check if style tag is a streamed tag */
                        isStreamed || (isStreamed = !!el.getAttribute(SC_STREAM_ATTR));
                        for (var elNames = (el.getAttribute(SC_ATTR) || "").trim().split(SPLIT_REGEX), elNamesSize = elNames.length, j = 0; j < elNamesSize; j += 1) {
                            var name = elNames[j];
                            /* add rehydrated name to sheet to avoid readding styles */
                            this.rehydratedNames[name] = !0;
                        }
                        /* extract all components and their CSS */
                        extracted.push.apply(extracted, extractComps(el.textContent)), /* store original HTMLStyleElement */
                        els.push(el);
                    }
                    /* abort rehydration if nothing was extracted */
                    var extractedSize = extracted.length;
                    if (0 === extractedSize) return this;
                    /* create a tag to be used for rehydration */
                    var tag = this.makeTag(null), rehydrationTag = makeRehydrationTag(tag, els, extracted, isStreamed);
                    /* reset capacity and adjust MAX_SIZE by the initial size of the rehydration */
                    this.capacity = Math.max(1, MAX_SIZE - extractedSize), this.tags.push(rehydrationTag);
                    /* retrieve all component ids */
                    for (var _j = 0; _j < extractedSize; _j += 1) this.tagMap[extracted[_j].componentId] = rehydrationTag;
                    return this;
                }, StyleSheet.reset = function() {
                    var forceServer = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                    master = new StyleSheet(void 0, forceServer).rehydrate();
                }, StyleSheet.prototype.clone = function() {
                    var sheet = new StyleSheet(this.target, this.forceServer);
                    /* add to clone array */
                    /* clone all tags */
                    /* clone other maps */
                    return this.clones.push(sheet), sheet.tags = this.tags.map(function(tag) {
                        /* reconstruct tagMap */
                        for (var ids = tag.getIds(), newTag = tag.clone(), i = 0; i < ids.length; i += 1) sheet.tagMap[ids[i]] = newTag;
                        return newTag;
                    }), sheet.rehydratedNames = _extends({}, this.rehydratedNames), sheet.deferred = _extends({}, this.deferred), 
                    sheet;
                }, StyleSheet.prototype.sealAllTags = function() {
                    this.capacity = 1, this.tags.forEach(function(tag) {
                        // eslint-disable-next-line no-param-reassign
                        tag.sealed = !0;
                    });
                }, StyleSheet.prototype.makeTag = function(tag) {
                    var lastEl = tag ? tag.styleTag : null, insertBefore = !1;
                    return makeTag(this.target, lastEl, this.forceServer, insertBefore, this.getImportRuleTag);
                }, StyleSheet.prototype.getTagForId = function(id) {
                    /* simply return a tag, when the componentId was already assigned one */
                    var prev = this.tagMap[id];
                    if (void 0 !== prev && !prev.sealed) return prev;
                    var tag = this.tags[this.tags.length - 1];
                    /* shard (create a new tag) if the tag is exhausted (See MAX_SIZE) */
                    return this.capacity -= 1, 0 === this.capacity && (this.capacity = MAX_SIZE, tag = this.makeTag(tag), 
                    this.tags.push(tag)), this.tagMap[id] = tag;
                }, StyleSheet.prototype.hasId = function(id) {
                    return void 0 !== this.tagMap[id];
                }, StyleSheet.prototype.hasNameForId = function(id, name) {
                    /* exception for rehydrated names which are checked separately */
                    if (void 0 === this.ignoreRehydratedNames[id] && this.rehydratedNames[name]) return !0;
                    var tag = this.tagMap[id];
                    return void 0 !== tag && tag.hasNameForId(id, name);
                }, StyleSheet.prototype.deferredInject = function(id, cssRules) {
                    /* don't inject when the id is already registered */
                    if (void 0 === this.tagMap[id]) {
                        for (var clones = this.clones, i = 0; i < clones.length; i += 1) clones[i].deferredInject(id, cssRules);
                        this.getTagForId(id).insertMarker(id), this.deferred[id] = cssRules;
                    }
                }, StyleSheet.prototype.inject = function(id, cssRules, name) {
                    for (var clones = this.clones, i = 0; i < clones.length; i += 1) clones[i].inject(id, cssRules, name);
                    var tag = this.getTagForId(id);
                    /* add deferred rules for component */
                    if (void 0 !== this.deferred[id]) {
                        // Combine passed cssRules with previously deferred CSS rules
                        // NOTE: We cannot mutate the deferred array itself as all clones
                        // do the same (see clones[i].inject)
                        var rules = this.deferred[id].concat(cssRules);
                        tag.insertRules(id, rules, name), this.deferred[id] = void 0;
                    } else tag.insertRules(id, cssRules, name);
                }, StyleSheet.prototype.remove = function(id) {
                    var tag = this.tagMap[id];
                    if (void 0 !== tag) {
                        for (var clones = this.clones, i = 0; i < clones.length; i += 1) clones[i].remove(id);
                        /* remove all rules from the tag */
                        tag.removeRules(id), /* ignore possible rehydrated names */
                        this.ignoreRehydratedNames[id] = !0, /* delete possible deferred rules */
                        this.deferred[id] = void 0;
                    }
                }, StyleSheet.prototype.toHTML = function() {
                    return this.tags.map(function(tag) {
                        return tag.toHTML();
                    }).join("");
                }, StyleSheet.prototype.toReactElements = function() {
                    var id = this.id;
                    return this.tags.map(function(tag, i) {
                        var key = "sc-" + id + "-" + i;
                        return React.cloneElement(tag.toElement(), {
                            key: key
                        });
                    });
                }, createClass(StyleSheet, null, [ {
                    key: "master",
                    get: function() {
                        return master || (master = new StyleSheet().rehydrate());
                    }
                }, {
                    key: "instance",
                    get: function() {
                        return StyleSheet.master;
                    }
                } ]), StyleSheet;
            }(), Keyframes = function() {
                function Keyframes(name, rules) {
                    var _this = this;
                    classCallCheck(this, Keyframes), this.inject = function(styleSheet) {
                        styleSheet.hasNameForId(_this.id, _this.name) || styleSheet.inject(_this.id, _this.rules, _this.name);
                    }, this.toString = function() {
                        throw new StyledComponentsError(12, String(_this.name));
                    }, this.name = name, this.rules = rules, this.id = "sc-keyframes-" + name;
                }
                return Keyframes.prototype.getName = function() {
                    return this.name;
                }, Keyframes;
            }(), uppercasePattern = /([A-Z])/g, msPattern = /^ms-/, objToCss = function objToCss(obj, prevKey) {
                var css = Object.keys(obj).filter(function(key) {
                    var chunk = obj[key];
                    return void 0 !== chunk && null !== chunk && chunk !== !1 && "" !== chunk;
                }).map(function(key) {
                    return isPlainObject(obj[key]) ? objToCss(obj[key], key) : hyphenateStyleName(key) + ": " + obj[key] + ";";
                }).join(" ");
                return prevKey ? prevKey + " {\n  " + css + "\n}" : css;
            }, isFalsish = function(chunk) {
                return void 0 === chunk || null === chunk || chunk === !1 || "" === chunk;
            }, charsLength = 52, getAlphabeticChar = function(code) {
                return String.fromCharCode(code + (code > 25 ? 39 : 97));
            }, isHMREnabled = "production" !== process.env.NODE_ENV && "undefined" != typeof module && module.hot, hasher = function(str) {
                return generateAlphabeticName(murmurhash(str));
            }, ComponentStyle = function() {
                function ComponentStyle(rules, attrs, componentId) {
                    if (classCallCheck(this, ComponentStyle), this.rules = rules, this.isStatic = !isHMREnabled && isStaticRules(rules, attrs), 
                    this.componentId = componentId, !StyleSheet.master.hasId(componentId)) {
                        var placeholder = "production" !== process.env.NODE_ENV ? [ "." + componentId + " {}" ] : [];
                        StyleSheet.master.deferredInject(componentId, placeholder);
                    }
                }
                /*
	     * Flattens a rule set into valid CSS
	     * Hashes it, wraps the whole chunk in a .hash1234 {}
	     * Returns the hash to be injected on render()
	     * */
                return ComponentStyle.prototype.generateAndInjectStyles = function(executionContext, styleSheet) {
                    var isStatic = this.isStatic, componentId = this.componentId, lastClassName = this.lastClassName;
                    if (IS_BROWSER && isStatic && void 0 !== lastClassName && styleSheet.hasNameForId(componentId, lastClassName)) return lastClassName;
                    var flatCSS = flatten(this.rules, executionContext, styleSheet), name = hasher(this.componentId + flatCSS.join(""));
                    return styleSheet.hasNameForId(componentId, name) || styleSheet.inject(this.componentId, stringifyRules(flatCSS, "." + name, void 0, componentId), name), 
                    this.lastClassName = name, name;
                }, ComponentStyle.generateName = function(str) {
                    return hasher(str);
                }, ComponentStyle;
            }(), LIMIT = 200, createWarnTooManyClasses = function(displayName) {
                var generatedClasses = {}, warningSeen = !1;
                return function(className) {
                    warningSeen || (generatedClasses[className] = !0, Object.keys(generatedClasses).length >= LIMIT && (// Unable to find latestRule in test environment.
                    /* eslint-disable no-console, prefer-template */
                    console.warn("Over " + LIMIT + " classes were generated for component " + displayName + ". \nConsider using the attrs method, together with a style object for frequently changed styles.\nExample:\n  const Component = styled.div.attrs({\n    style: ({ background }) => ({\n      background,\n    }),\n  })`width: 100%;`\n\n  <Component />"), 
                    warningSeen = !0, generatedClasses = {}));
                };
            }, determineTheme = function(props, fallbackTheme) {
                var defaultProps = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : EMPTY_OBJECT, isDefaultTheme = !!defaultProps && props.theme === defaultProps.theme, theme = props.theme && !isDefaultTheme ? props.theme : fallbackTheme || defaultProps.theme;
                /* eslint-enable */
                return theme;
            }, escapeRegex = /[[\].#*$><+~=|^:(),"'`-]+/g, dashesAtEnds = /(^-|-$)/g, REACT_STATICS = {
                childContextTypes: !0,
                contextTypes: !0,
                defaultProps: !0,
                displayName: !0,
                getDerivedStateFromProps: !0,
                propTypes: !0,
                type: !0
            }, KNOWN_STATICS = {
                name: !0,
                length: !0,
                prototype: !0,
                caller: !0,
                callee: !0,
                arguments: !0,
                arity: !0
            }, TYPE_STATICS = (_TYPE_STATICS = {}, _TYPE_STATICS[reactIs.ForwardRef] = {
                $$typeof: !0,
                render: !0
            }, _TYPE_STATICS), defineProperty$1 = Object.defineProperty, getOwnPropertyNames = Object.getOwnPropertyNames, _Object$getOwnPropert = Object.getOwnPropertySymbols, getOwnPropertySymbols = void 0 === _Object$getOwnPropert ? function() {
                return [];
            } : _Object$getOwnPropert, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor, getPrototypeOf = Object.getPrototypeOf, objectPrototype = Object.prototype, arrayPrototype = Array.prototype, ThemeContext = React.createContext(), ThemeConsumer = ThemeContext.Consumer, ThemeProvider = function(_Component) {
                function ThemeProvider(props) {
                    classCallCheck(this, ThemeProvider);
                    var _this = possibleConstructorReturn(this, _Component.call(this, props));
                    return _this.getContext = memoize(_this.getContext.bind(_this)), _this.renderInner = _this.renderInner.bind(_this), 
                    _this;
                }
                /**
	   * Get the theme from the props, supporting both (outerTheme) => {}
	   * as well as object notation
	   */
                return inherits(ThemeProvider, _Component), ThemeProvider.prototype.render = function() {
                    return this.props.children ? React__default.createElement(ThemeContext.Consumer, null, this.renderInner) : null;
                }, ThemeProvider.prototype.renderInner = function(outerTheme) {
                    var context = this.getContext(this.props.theme, outerTheme);
                    return React__default.createElement(ThemeContext.Provider, {
                        value: context
                    }, React__default.Children.only(this.props.children));
                }, ThemeProvider.prototype.getTheme = function(theme, outerTheme) {
                    if (isFunction(theme)) {
                        var mergedTheme = theme(outerTheme);
                        if ("production" !== process.env.NODE_ENV && (null === mergedTheme || Array.isArray(mergedTheme) || "object" !== ("undefined" == typeof mergedTheme ? "undefined" : _typeof(mergedTheme)))) throw new StyledComponentsError(7);
                        return mergedTheme;
                    }
                    if (null === theme || Array.isArray(theme) || "object" !== ("undefined" == typeof theme ? "undefined" : _typeof(theme))) throw new StyledComponentsError(8);
                    return _extends({}, outerTheme, theme);
                }, ThemeProvider.prototype.getContext = function(theme, outerTheme) {
                    return this.getTheme(theme, outerTheme);
                }, ThemeProvider;
            }(React.Component), ServerStyleSheet = function() {
                function ServerStyleSheet() {
                    classCallCheck(this, ServerStyleSheet), /* The master sheet might be reset, so keep a reference here */
                    this.masterSheet = StyleSheet.master, this.instance = this.masterSheet.clone(), 
                    this.sealed = !1;
                }
                /**
	   * Mark the ServerStyleSheet as being fully emitted and manually GC it from the
	   * StyleSheet singleton.
	   */
                return ServerStyleSheet.prototype.seal = function() {
                    if (!this.sealed) {
                        /* Remove sealed StyleSheets from the master sheet */
                        var index = this.masterSheet.clones.indexOf(this.instance);
                        this.masterSheet.clones.splice(index, 1), this.sealed = !0;
                    }
                }, ServerStyleSheet.prototype.collectStyles = function(children) {
                    if (this.sealed) throw new StyledComponentsError(2);
                    return React__default.createElement(StyleSheetManager, {
                        sheet: this.instance
                    }, children);
                }, ServerStyleSheet.prototype.getStyleTags = function() {
                    return this.seal(), this.instance.toHTML();
                }, ServerStyleSheet.prototype.getStyleElement = function() {
                    return this.seal(), this.instance.toReactElements();
                }, ServerStyleSheet.prototype.interleaveWithNodeStream = function(readableStream) {
                    throw new StyledComponentsError(3);
                }, ServerStyleSheet;
            }(), StyleSheetContext = React.createContext(), StyleSheetConsumer = StyleSheetContext.Consumer, StyleSheetManager = function(_Component) {
                function StyleSheetManager(props) {
                    classCallCheck(this, StyleSheetManager);
                    var _this = possibleConstructorReturn(this, _Component.call(this, props));
                    return _this.getContext = memoize(_this.getContext), _this;
                }
                return inherits(StyleSheetManager, _Component), StyleSheetManager.prototype.getContext = function(sheet, target) {
                    if (sheet) return sheet;
                    if (target) return new StyleSheet(target);
                    throw new StyledComponentsError(4);
                }, StyleSheetManager.prototype.render = function() {
                    var _props = this.props, children = _props.children, sheet = _props.sheet, target = _props.target, context = this.getContext(sheet, target);
                    return React__default.createElement(StyleSheetContext.Provider, {
                        value: context
                    }, React__default.Children.only(children));
                }, StyleSheetManager;
            }(React.Component);
            "production" !== process.env.NODE_ENV ? StyleSheetManager.propTypes = {
                sheet: PropTypes.oneOfType([ PropTypes.instanceOf(StyleSheet), PropTypes.instanceOf(ServerStyleSheet) ]),
                target: PropTypes.shape({
                    appendChild: PropTypes.func.isRequired
                })
            } : void 0;
            // 
            var didWarnAboutClassNameUsage = new Set(), classNameUsageCheckInjector = function(target) {
                var elementClassName = "", targetCDM = target.componentDidMount;
                // eslint-disable-next-line no-param-reassign
                target.componentDidMount = function() {
                    "function" == typeof targetCDM && targetCDM.call(this);
                    var forwardTarget = this.props.forwardedClass.target;
                    if (!(target.props && target.props.suppressClassNameWarning || target.attrs && target.attrs.suppressClassNameWarning || didWarnAboutClassNameUsage.has(forwardTarget))) {
                        didWarnAboutClassNameUsage.add(forwardTarget);
                        var classNames = elementClassName.replace(/ +/g, " ").trim().split(" "), node = ReactDOM.findDOMNode(this), selector = classNames.map(function(s) {
                            return "." + s;
                        }).join("");
                        !node || 1 !== node.nodeType || classNames.every(function(className) {
                            return node.classList && node.classList.contains(className);
                        }) || node.querySelector(selector) || console.warn("It looks like you've wrapped styled() around your React component (" + getComponentName(forwardTarget) + "), but the className prop is not being passed down to a child. No styles will be rendered unless className is composed within your React component.");
                    }
                };
                var prevRenderInner = target.renderInner;
                // eslint-disable-next-line no-param-reassign
                target.renderInner = function() {
                    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    var element = prevRenderInner.apply(this, args);
                    return elementClassName = element.props.className, element;
                };
            }, identifiers = {}, warnInnerRef = once(function() {
                // eslint-disable-next-line no-console
                return console.warn('The "innerRef" API has been removed in styled-components v4 in favor of React 16 ref forwarding, use "ref" instead like a typical component.');
            }), StyledComponent = function(_Component) {
                function StyledComponent() {
                    classCallCheck(this, StyledComponent);
                    var _this = possibleConstructorReturn(this, _Component.call(this));
                    return _this.attrs = {}, _this.renderOuter = _this.renderOuter.bind(_this), _this.renderInner = _this.renderInner.bind(_this), 
                    "production" !== process.env.NODE_ENV && IS_BROWSER && classNameUsageCheckInjector(_this), 
                    _this;
                }
                return inherits(StyledComponent, _Component), StyledComponent.prototype.render = function() {
                    return React__default.createElement(StyleSheetConsumer, null, this.renderOuter);
                }, StyledComponent.prototype.renderOuter = function(styleSheet) {
                    return this.styleSheet = styleSheet, React__default.createElement(ThemeConsumer, null, this.renderInner);
                }, StyledComponent.prototype.renderInner = function(theme) {
                    var _props$forwardedClass = this.props.forwardedClass, componentStyle = _props$forwardedClass.componentStyle, defaultProps = _props$forwardedClass.defaultProps, styledComponentId = _props$forwardedClass.styledComponentId, target = _props$forwardedClass.target, generatedClassName = void 0;
                    generatedClassName = componentStyle.isStatic ? this.generateAndInjectStyles(EMPTY_OBJECT, this.props, this.styleSheet) : void 0 !== theme ? this.generateAndInjectStyles(determineTheme(this.props, theme, defaultProps), this.props, this.styleSheet) : this.generateAndInjectStyles(this.props.theme || EMPTY_OBJECT, this.props, this.styleSheet);
                    var elementToBeCreated = this.props.as || this.attrs.as || target, isTargetTag = isTag(elementToBeCreated), propsForElement = {}, computedProps = _extends({}, this.attrs, this.props), key = void 0;
                    // eslint-disable-next-line guard-for-in
                    for (key in computedProps) "production" !== process.env.NODE_ENV && "innerRef" === key && warnInnerRef(), 
                    "forwardedClass" !== key && "as" !== key && ("forwardedRef" === key ? propsForElement.ref = computedProps[key] : isTargetTag && !validAttr(key) || (// Don't pass through non HTML tags through to HTML elements
                    propsForElement[key] = computedProps[key]));
                    return this.props.style && this.attrs.style && (propsForElement.style = _extends({}, this.attrs.style, this.props.style)), 
                    propsForElement.className = [ this.props.className, styledComponentId, this.attrs.className, generatedClassName ].filter(Boolean).join(" "), 
                    React.createElement(elementToBeCreated, propsForElement);
                }, StyledComponent.prototype.buildExecutionContext = function(theme, props, attrs) {
                    var context = _extends({}, props, {
                        theme: theme
                    });
                    if (void 0 === attrs) return context;
                    this.attrs = {};
                    var attr = void 0, key = void 0;
                    /* eslint-disable guard-for-in */
                    for (key in attrs) attr = attrs[key], !isFunction(attr) || isDerivedReactComponent(attr) || isStyledComponent(attr) || (attr = attr(context), 
                    "production" !== process.env.NODE_ENV && React__default.isValidElement(attr) && // eslint-disable-next-line no-console
                    console.warn("It looks like you've used a component as value for the " + key + " prop in the attrs constructor.\nYou'll need to wrap it in a function to make it available inside the styled component.\n" + ("For example, { " + key + ": () => InnerComponent } instead of { " + key + ": InnerComponent }"))), 
                    this.attrs[key] = attr;
                    /* eslint-enable */
                    return _extends({}, context, this.attrs);
                }, StyledComponent.prototype.generateAndInjectStyles = function(theme, props) {
                    var styleSheet = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : StyleSheet.master, _props$forwardedClass2 = props.forwardedClass, attrs = _props$forwardedClass2.attrs, componentStyle = _props$forwardedClass2.componentStyle, warnTooManyClasses = _props$forwardedClass2.warnTooManyClasses;
                    // statically styled-components don't need to build an execution context object,
                    // and shouldn't be increasing the number of class names
                    if (componentStyle.isStatic && void 0 === attrs) return componentStyle.generateAndInjectStyles(EMPTY_OBJECT, styleSheet);
                    var className = componentStyle.generateAndInjectStyles(this.buildExecutionContext(theme, props, props.forwardedClass.attrs), styleSheet);
                    return warnTooManyClasses && warnTooManyClasses(className), className;
                }, StyledComponent;
            }(React.Component), domElements = [ "a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "marquee", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", // SVG
            "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan" ], styled = function(tag) {
                return constructWithOptions(createStyledComponent, tag);
            };
            // Shorthands for all valid HTML Elements
            domElements.forEach(function(domElement) {
                styled[domElement] = styled(domElement);
            });
            // 
            var GlobalStyle = function() {
                function GlobalStyle(rules, componentId) {
                    classCallCheck(this, GlobalStyle), this.rules = rules, this.componentId = componentId, 
                    this.isStatic = isStaticRules(rules), StyleSheet.master.hasId(componentId) || StyleSheet.master.deferredInject(componentId, []);
                }
                // TODO: overwrite in-place instead of remove+create?
                return GlobalStyle.prototype.createStyles = function(executionContext, styleSheet) {
                    var flatCSS = flatten(this.rules, executionContext, styleSheet), css = stringifyRules(flatCSS, "");
                    styleSheet.inject(this.componentId, css);
                }, GlobalStyle.prototype.removeStyles = function(styleSheet) {
                    var componentId = this.componentId;
                    styleSheet.hasId(componentId) && styleSheet.remove(componentId);
                }, GlobalStyle.prototype.renderStyles = function(executionContext, styleSheet) {
                    this.removeStyles(styleSheet), this.createStyles(executionContext, styleSheet);
                }, GlobalStyle;
            }();
            // 
            // place our cache into shared context so it'll persist between HMRs
            IS_BROWSER && (window.scCGSHMRCache = {});
            // 
            var replaceWhitespace = function(str) {
                return str.replace(/\s|\\n/g, "");
            }, withTheme = function(Component) {
                var WithTheme = React__default.forwardRef(function(props, ref) {
                    return React__default.createElement(ThemeConsumer, null, function(theme) {
                        // $FlowFixMe
                        var defaultProps = Component.defaultProps, themeProp = determineTheme(props, theme, defaultProps);
                        // eslint-disable-next-line no-console
                        return "production" !== process.env.NODE_ENV && void 0 === themeProp && console.warn("[withTheme] You are not using a ThemeProvider nor passing a theme prop or a theme in defaultProps in component class " + getComponentName(Component)), 
                        React__default.createElement(Component, _extends({}, props, {
                            theme: themeProp,
                            ref: ref
                        }));
                    });
                });
                return hoistNonReactStatics(WithTheme, Component), WithTheme.displayName = "WithTheme(" + getComponentName(Component) + ")", 
                WithTheme;
            }, __DO_NOT_USE_OR_YOU_WILL_BE_HAUNTED_BY_SPOOKY_GHOSTS = {
                StyleSheet: StyleSheet
            };
            // 
            /* Warning if you've imported this file on React Native */
            "production" !== process.env.NODE_ENV && "undefined" != typeof navigator && "ReactNative" === navigator.product && // eslint-disable-next-line no-console
            console.warn("It looks like you've imported 'styled-components' on React Native.\nPerhaps you're looking to import 'styled-components/native'?\nRead more about this at https://www.styled-components.com/docs/basics#react-native"), 
            /* Warning if there are several instances of styled-components */
            "production" !== process.env.NODE_ENV && "test" !== process.env.NODE_ENV && "undefined" != typeof window && "undefined" != typeof navigator && "string" == typeof navigator.userAgent && navigator.userAgent.indexOf("Node.js") === -1 && navigator.userAgent.indexOf("jsdom") === -1 && (window["__styled-components-init__"] = window["__styled-components-init__"] || 0, 
            1 === window["__styled-components-init__"] && // eslint-disable-next-line no-console
            console.warn("It looks like there are several instances of 'styled-components' initialized in this application. This may cause dynamic styles not rendering properly, errors happening during rehydration process and makes your application bigger without a good reason.\n\nSee https://s-c.sh/2BAXzed for more info."), 
            window["__styled-components-init__"] += 1), //
            exports.default = styled, exports.css = css, exports.keyframes = keyframes, exports.createGlobalStyle = createGlobalStyle, 
            exports.isStyledComponent = isStyledComponent, exports.ThemeConsumer = ThemeConsumer, 
            exports.ThemeContext = ThemeContext, exports.ThemeProvider = ThemeProvider, exports.withTheme = withTheme, 
            exports.ServerStyleSheet = ServerStyleSheet, exports.StyleSheetManager = StyleSheetManager, 
            exports.__DO_NOT_USE_OR_YOU_WILL_BE_HAUNTED_BY_SPOOKY_GHOSTS = __DO_NOT_USE_OR_YOU_WILL_BE_HAUNTED_BY_SPOOKY_GHOSTS;
        }).call(exports, __webpack_require__(110), __webpack_require__(124)(module));
    }, /* 130 */
    /***/
    function(module, exports, __webpack_require__) {
        !function(e) {
            module.exports = e(null);
        }(function e(a) {
            "use strict";
            function He(e, a, s, t, i) {
                for (var f, n, o = 0, h = 0, u = 0, d = 0, g = 0, A = 0, C = 0, w = 0, m = 0, $ = 0, y = 0, O = 0, j = 0, z = 0, R = 0, we = 0, $e = 0, Oe = 0, je = 0, ze = s.length, Je = ze - 1, Re = "", Te = "", Ue = "", Ve = "", Xe = "", Ye = ""; R < ze; ) {
                    if (C = s.charCodeAt(R), R === Je && h + d + u + o !== 0 && (0 !== h && (C = h === Z ? I : Z), 
                    d = u = o = 0, ze++, Je++), h + d + u + o === 0) {
                        if (R === Je && (we > 0 && (Te = Te.replace(r, "")), Te.trim().length > 0)) {
                            switch (C) {
                              case M:
                              case K:
                              case B:
                              case J:
                              case I:
                                break;

                              default:
                                Te += s.charAt(R);
                            }
                            C = B;
                        }
                        if (1 === $e) switch (C) {
                          case q:
                          case W:
                          case B:
                          case Y:
                          case X:
                          case D:
                          case E:
                          case U:
                            $e = 0;

                          case K:
                          case J:
                          case I:
                          case M:
                            break;

                          default:
                            for ($e = 0, je = R, g = C, R--, C = B; je < ze; ) switch (s.charCodeAt(je++)) {
                              case I:
                              case J:
                              case B:
                                ++R, C = g, je = ze;
                                break;

                              case V:
                                we > 0 && (++R, C = g);

                              case q:
                                je = ze;
                            }
                        }
                        switch (C) {
                          case q:
                            for (g = (Te = Te.trim()).charCodeAt(0), y = 1, je = ++R; R < ze; ) {
                                switch (C = s.charCodeAt(R)) {
                                  case q:
                                    y++;
                                    break;

                                  case W:
                                    y--;
                                    break;

                                  case Z:
                                    switch (A = s.charCodeAt(R + 1)) {
                                      case T:
                                      case Z:
                                        R = Qe(A, R, Je, s);
                                    }
                                    break;

                                  case G:
                                    C++;

                                  case D:
                                    C++;

                                  case Y:
                                  case X:
                                    for (;R++ < Je && s.charCodeAt(R) !== C; ) ;
                                }
                                if (0 === y) break;
                                R++;
                            }
                            switch (Ue = s.substring(je, R), g === ce && (g = (Te = Te.replace(c, "").trim()).charCodeAt(0)), 
                            g) {
                              case L:
                                switch (we > 0 && (Te = Te.replace(r, "")), A = Te.charCodeAt(1)) {
                                  case ue:
                                  case ie:
                                  case fe:
                                  case Q:
                                    f = a;
                                    break;

                                  default:
                                    f = xe;
                                }
                                if (je = (Ue = He(a, f, Ue, A, i + 1)).length, me > 0 && 0 === je && (je = Te.length), 
                                ye > 0 && (f = Ie(xe, Te, Oe), n = Pe(Be, Ue, f, a, ke, be, je, A, i, t), Te = f.join(""), 
                                void 0 !== n && 0 === (je = (Ue = n.trim()).length) && (A = 0, Ue = "")), je > 0) switch (A) {
                                  case fe:
                                    Te = Te.replace(x, Me);

                                  case ue:
                                  case ie:
                                  case Q:
                                    Ue = Te + "{" + Ue + "}";
                                    break;

                                  case te:
                                    Ue = (Te = Te.replace(b, "$1 $2" + (qe > 0 ? De : ""))) + "{" + Ue + "}", Ue = 1 === Ae || 2 === Ae && Le("@" + Ue, 3) ? "@" + F + Ue + "@" + Ue : "@" + Ue;
                                    break;

                                  default:
                                    Ue = Te + Ue, t === de && (Ve += Ue, Ue = "");
                                } else Ue = "";
                                break;

                              default:
                                Ue = He(a, Ie(a, Te, Oe), Ue, t, i + 1);
                            }
                            Xe += Ue, O = 0, $e = 0, z = 0, we = 0, Oe = 0, j = 0, Te = "", Ue = "", C = s.charCodeAt(++R);
                            break;

                          case W:
                          case B:
                            if ((je = (Te = (we > 0 ? Te.replace(r, "") : Te).trim()).length) > 1) switch (0 === z && ((g = Te.charCodeAt(0)) === Q || g > 96 && g < 123) && (je = (Te = Te.replace(" ", ":")).length), 
                            ye > 0 && void 0 !== (n = Pe(Ne, Te, a, e, ke, be, Ve.length, t, i, t)) && 0 === (je = (Te = n.trim()).length) && (Te = "\0\0"), 
                            g = Te.charCodeAt(0), A = Te.charCodeAt(1), g) {
                              case ce:
                                break;

                              case L:
                                if (A === oe || A === he) {
                                    Ye += Te + s.charAt(R);
                                    break;
                                }

                              default:
                                if (Te.charCodeAt(je - 1) === V) break;
                                Ve += Ke(Te, g, A, Te.charCodeAt(2));
                            }
                            O = 0, $e = 0, z = 0, we = 0, Oe = 0, Te = "", C = s.charCodeAt(++R);
                        }
                    }
                    switch (C) {
                      case J:
                      case I:
                        if (h + d + u + o + ve === 0) switch ($) {
                          case E:
                          case X:
                          case Y:
                          case L:
                          case ae:
                          case _:
                          case T:
                          case ee:
                          case Z:
                          case Q:
                          case V:
                          case U:
                          case B:
                          case q:
                          case W:
                            break;

                          default:
                            z > 0 && ($e = 1);
                        }
                        h === Z ? h = 0 : ge + O === 0 && t !== te && Te.length > 0 && (we = 1, Te += "\0"), 
                        ye * We > 0 && Pe(Fe, Te, a, e, ke, be, Ve.length, t, i, t), be = 1, ke++;
                        break;

                      case B:
                      case W:
                        if (h + d + u + o === 0) {
                            be++;
                            break;
                        }

                      default:
                        switch (be++, Re = s.charAt(R), C) {
                          case K:
                          case M:
                            if (d + o + h === 0) switch (w) {
                              case U:
                              case V:
                              case K:
                              case M:
                                Re = "";
                                break;

                              default:
                                C !== M && (Re = " ");
                            }
                            break;

                          case ce:
                            Re = "\\0";
                            break;

                          case re:
                            Re = "\\f";
                            break;

                          case se:
                            Re = "\\v";
                            break;

                          case P:
                            d + h + o === 0 && ge > 0 && (Oe = 1, we = 1, Re = "\f" + Re);
                            break;

                          case 108:
                            if (d + h + o + pe === 0 && z > 0) switch (R - z) {
                              case 2:
                                w === ne && s.charCodeAt(R - 3) === V && (pe = w);

                              case 8:
                                m === le && (pe = m);
                            }
                            break;

                          case V:
                            d + h + o === 0 && (z = R);
                            break;

                          case U:
                            h + u + d + o === 0 && (we = 1, Re += "\r");
                            break;

                          case Y:
                          case X:
                            0 === h && (d = d === C ? 0 : 0 === d ? C : d);
                            break;

                          case G:
                            d + h + u === 0 && o++;
                            break;

                          case H:
                            d + h + u === 0 && o--;
                            break;

                          case E:
                            d + h + o === 0 && u--;
                            break;

                          case D:
                            if (d + h + o === 0) {
                                if (0 === O) switch (2 * w + 3 * m) {
                                  case 533:
                                    break;

                                  default:
                                    y = 0, O = 1;
                                }
                                u++;
                            }
                            break;

                          case L:
                            h + u + d + o + z + j === 0 && (j = 1);
                            break;

                          case T:
                          case Z:
                            if (d + o + u > 0) break;
                            switch (h) {
                              case 0:
                                switch (2 * C + 3 * s.charCodeAt(R + 1)) {
                                  case 235:
                                    h = Z;
                                    break;

                                  case 220:
                                    je = R, h = T;
                                }
                                break;

                              case T:
                                C === Z && w === T && je + 2 !== R && (33 === s.charCodeAt(je + 2) && (Ve += s.substring(je, R + 1)), 
                                Re = "", h = 0);
                            }
                        }
                        if (0 === h) {
                            if (ge + d + o + j === 0 && t !== te && C !== B) switch (C) {
                              case U:
                              case ae:
                              case _:
                              case ee:
                              case E:
                              case D:
                                if (0 === O) {
                                    switch (w) {
                                      case K:
                                      case M:
                                      case I:
                                      case J:
                                        Re += "\0";
                                        break;

                                      default:
                                        Re = "\0" + Re + (C === U ? "" : "\0");
                                    }
                                    we = 1;
                                } else switch (C) {
                                  case D:
                                    z + 7 === R && 108 === w && (z = 0), O = ++y;
                                    break;

                                  case E:
                                    0 == (O = --y) && (we = 1, Re += "\0");
                                }
                                break;

                              case K:
                              case M:
                                switch (w) {
                                  case ce:
                                  case q:
                                  case W:
                                  case B:
                                  case U:
                                  case re:
                                  case K:
                                  case M:
                                  case I:
                                  case J:
                                    break;

                                  default:
                                    0 === O && (we = 1, Re += "\0");
                                }
                            }
                            Te += Re, C !== M && C !== K && ($ = C);
                        }
                    }
                    m = w, w = C, R++;
                }
                if (je = Ve.length, me > 0 && 0 === je && 0 === Xe.length && 0 === a[0].length == 0 && (t !== ie || 1 === a.length && (ge > 0 ? Ee : Ge) === a[0]) && (je = a.join(",").length + 2), 
                je > 0) {
                    if (f = 0 === ge && t !== te ? function(e) {
                        for (var a, c, s = 0, t = e.length, i = Array(t); s < t; ++s) {
                            for (var f = e[s].split(l), n = "", o = 0, h = 0, u = 0, d = 0, b = f.length; o < b; ++o) if (!(0 === (h = (c = f[o]).length) && b > 1)) {
                                if (u = n.charCodeAt(n.length - 1), d = c.charCodeAt(0), a = "", 0 !== o) switch (u) {
                                  case T:
                                  case ae:
                                  case _:
                                  case ee:
                                  case M:
                                  case D:
                                    break;

                                  default:
                                    a = " ";
                                }
                                switch (d) {
                                  case P:
                                    c = a + Ee;

                                  case ae:
                                  case _:
                                  case ee:
                                  case M:
                                  case E:
                                  case D:
                                    break;

                                  case G:
                                    c = a + c + Ee;
                                    break;

                                  case V:
                                    switch (2 * c.charCodeAt(1) + 3 * c.charCodeAt(2)) {
                                      case 530:
                                        if (Ce > 0) {
                                            c = a + c.substring(8, h - 1);
                                            break;
                                        }

                                      default:
                                        (o < 1 || f[o - 1].length < 1) && (c = a + Ee + c);
                                    }
                                    break;

                                  case U:
                                    a = "";

                                  default:
                                    c = h > 1 && c.indexOf(":") > 0 ? a + c.replace(v, "$1" + Ee + "$2") : a + c + Ee;
                                }
                                n += c;
                            }
                            i[s] = n.replace(r, "").trim();
                        }
                        return i;
                    }(a) : a, ye > 0 && void 0 !== (n = Pe(Se, Ve, f, e, ke, be, je, t, i, t)) && 0 === (Ve = n).length) return Ye + Ve + Xe;
                    if (Ve = f.join(",") + "{" + Ve + "}", Ae * pe != 0) {
                        switch (2 !== Ae || Le(Ve, 2) || (pe = 0), pe) {
                          case le:
                            Ve = Ve.replace(p, ":" + N + "$1") + Ve;
                            break;

                          case ne:
                            Ve = Ve.replace(k, "::" + F + "input-$1") + Ve.replace(k, "::" + N + "$1") + Ve.replace(k, ":" + S + "input-$1") + Ve;
                        }
                        pe = 0;
                    }
                }
                return Ye + Ve + Xe;
            }
            function Ie(e, a, c) {
                var r = a.trim().split(o), s = r, t = r.length, i = e.length;
                switch (i) {
                  case 0:
                  case 1:
                    for (var f = 0, n = 0 === i ? "" : e[0] + " "; f < t; ++f) s[f] = Je(n, s[f], c, i).trim();
                    break;

                  default:
                    f = 0;
                    var l = 0;
                    for (s = []; f < t; ++f) for (var h = 0; h < i; ++h) s[l++] = Je(e[h] + " ", r[f], c, i).trim();
                }
                return s;
            }
            function Je(e, a, c, r) {
                var s = a, t = s.charCodeAt(0);
                switch (t < 33 && (t = (s = s.trim()).charCodeAt(0)), t) {
                  case P:
                    switch (ge + r) {
                      case 0:
                      case 1:
                        if (0 === e.trim().length) break;

                      default:
                        return s.replace(h, "$1" + e.trim());
                    }
                    break;

                  case V:
                    switch (s.charCodeAt(1)) {
                      case 103:
                        if (Ce > 0 && ge > 0) return s.replace(u, "$1").replace(h, "$1" + Ge);
                        break;

                      default:
                        return e.trim() + s.replace(h, "$1" + e.trim());
                    }

                  default:
                    if (c * ge > 0 && s.indexOf("\f") > 0) return s.replace(h, (e.charCodeAt(0) === V ? "" : "$1") + e.trim());
                }
                return e + s;
            }
            function Ke(e, a, c, r) {
                var l, o = 0, h = e + ";", u = 2 * a + 3 * c + 4 * r;
                if (944 === u) return function(e) {
                    var a = e.length, c = e.indexOf(":", 9) + 1, r = e.substring(0, c).trim(), s = e.substring(c, a - 1).trim();
                    switch (e.charCodeAt(9) * qe) {
                      case 0:
                        break;

                      case Q:
                        if (110 !== e.charCodeAt(10)) break;

                      default:
                        for (var t = s.split((s = "", f)), i = 0, c = 0, a = t.length; i < a; c = 0, ++i) {
                            for (var l = t[i], o = l.split(n); l = o[c]; ) {
                                var h = l.charCodeAt(0);
                                if (1 === qe && (h > L && h < 90 || h > 96 && h < 123 || h === R || h === Q && l.charCodeAt(1) !== Q)) switch (isNaN(parseFloat(l)) + (-1 !== l.indexOf("("))) {
                                  case 1:
                                    switch (l) {
                                      case "infinite":
                                      case "alternate":
                                      case "backwards":
                                      case "running":
                                      case "normal":
                                      case "forwards":
                                      case "both":
                                      case "none":
                                      case "linear":
                                      case "ease":
                                      case "ease-in":
                                      case "ease-out":
                                      case "ease-in-out":
                                      case "paused":
                                      case "reverse":
                                      case "alternate-reverse":
                                      case "inherit":
                                      case "initial":
                                      case "unset":
                                      case "step-start":
                                      case "step-end":
                                        break;

                                      default:
                                        l += De;
                                    }
                                }
                                o[c++] = l;
                            }
                            s += (0 === i ? "" : ",") + o.join(" ");
                        }
                    }
                    return s = r + s + ";", 1 === Ae || 2 === Ae && Le(s, 1) ? F + s + s : s;
                }(h);
                if (0 === Ae || 2 === Ae && !Le(h, 1)) return h;
                switch (u) {
                  case 1015:
                    return 97 === h.charCodeAt(10) ? F + h + h : h;

                  case 951:
                    return 116 === h.charCodeAt(3) ? F + h + h : h;

                  case 963:
                    return 110 === h.charCodeAt(5) ? F + h + h : h;

                  case 1009:
                    if (100 !== h.charCodeAt(4)) break;

                  case 969:
                  case 942:
                    return F + h + h;

                  case 978:
                    return F + h + N + h + h;

                  case 1019:
                  case 983:
                    return F + h + N + h + S + h + h;

                  case 883:
                    return h.charCodeAt(8) === Q ? F + h + h : h.indexOf("image-set(", 11) > 0 ? h.replace(z, "$1" + F + "$2") + h : h;

                  case 932:
                    if (h.charCodeAt(4) === Q) switch (h.charCodeAt(5)) {
                      case 103:
                        return F + "box-" + h.replace("-grow", "") + F + h + S + h.replace("grow", "positive") + h;

                      case 115:
                        return F + h + S + h.replace("shrink", "negative") + h;

                      case 98:
                        return F + h + S + h.replace("basis", "preferred-size") + h;
                    }
                    return F + h + S + h + h;

                  case 964:
                    return F + h + S + "flex-" + h + h;

                  case 1023:
                    if (99 !== h.charCodeAt(8)) break;
                    return l = h.substring(h.indexOf(":", 15)).replace("flex-", "").replace("space-between", "justify"), 
                    F + "box-pack" + l + F + h + S + "flex-pack" + l + h;

                  case 1005:
                    return t.test(h) ? h.replace(s, ":" + F) + h.replace(s, ":" + N) + h : h;

                  case 1e3:
                    switch (o = (l = h.substring(13).trim()).indexOf("-") + 1, l.charCodeAt(0) + l.charCodeAt(o)) {
                      case 226:
                        l = h.replace(m, "tb");
                        break;

                      case 232:
                        l = h.replace(m, "tb-rl");
                        break;

                      case 220:
                        l = h.replace(m, "lr");
                        break;

                      default:
                        return h;
                    }
                    return F + h + S + l + h;

                  case 1017:
                    if (-1 === h.indexOf("sticky", 9)) return h;

                  case 975:
                    switch (o = (h = e).length - 10, u = (l = (33 === h.charCodeAt(o) ? h.substring(0, o) : h).substring(e.indexOf(":", 7) + 1).trim()).charCodeAt(0) + (0 | l.charCodeAt(7))) {
                      case 203:
                        if (l.charCodeAt(8) < 111) break;

                      case 115:
                        h = h.replace(l, F + l) + ";" + h;
                        break;

                      case 207:
                      case 102:
                        h = h.replace(l, F + (u > 102 ? "inline-" : "") + "box") + ";" + h.replace(l, F + l) + ";" + h.replace(l, S + l + "box") + ";" + h;
                    }
                    return h + ";";

                  case 938:
                    if (h.charCodeAt(5) === Q) switch (h.charCodeAt(6)) {
                      case 105:
                        return l = h.replace("-items", ""), F + h + F + "box-" + l + S + "flex-" + l + h;

                      case 115:
                        return F + h + S + "flex-item-" + h.replace(y, "") + h;

                      default:
                        return F + h + S + "flex-line-pack" + h.replace("align-content", "").replace(y, "") + h;
                    }
                    break;

                  case 973:
                  case 989:
                    if (h.charCodeAt(3) !== Q || 122 === h.charCodeAt(4)) break;

                  case 931:
                  case 953:
                    if (!0 === j.test(e)) return 115 === (l = e.substring(e.indexOf(":") + 1)).charCodeAt(0) ? Ke(e.replace("stretch", "fill-available"), a, c, r).replace(":fill-available", ":stretch") : h.replace(l, F + l) + h.replace(l, N + l.replace("fill-", "")) + h;
                    break;

                  case 962:
                    if (h = F + h + (102 === h.charCodeAt(5) ? S + h : "") + h, c + r === 211 && 105 === h.charCodeAt(13) && h.indexOf("transform", 10) > 0) return h.substring(0, h.indexOf(";", 27) + 1).replace(i, "$1" + F + "$2") + h;
                }
                return h;
            }
            function Le(e, a) {
                var c = e.indexOf(1 === a ? ":" : "{"), r = e.substring(0, 3 !== a ? c : 10), s = e.substring(c + 1, e.length - 1);
                return Oe(2 !== a ? r : r.replace(O, "$1"), s, a);
            }
            function Me(e, a) {
                var c = Ke(a, a.charCodeAt(0), a.charCodeAt(1), a.charCodeAt(2));
                return c !== a + ";" ? c.replace($, " or ($1)").substring(4) : "(" + a + ")";
            }
            function Pe(e, a, c, r, s, t, i, f, n, l) {
                for (var o, h = 0, u = a; h < ye; ++h) switch (o = $e[h].call(Te, e, u, c, r, s, t, i, f, n, l)) {
                  case void 0:
                  case !1:
                  case !0:
                  case null:
                    break;

                  default:
                    u = o;
                }
                switch (u) {
                  case void 0:
                  case !1:
                  case !0:
                  case null:
                  case a:
                    break;

                  default:
                    return u;
                }
            }
            function Qe(e, a, c, r) {
                for (var s = a + 1; s < c; ++s) switch (r.charCodeAt(s)) {
                  case Z:
                    if (e === T && r.charCodeAt(s - 1) === T && a + 2 !== s) return s + 1;
                    break;

                  case I:
                    if (e === Z) return s + 1;
                }
                return s;
            }
            function Re(e) {
                for (var a in e) {
                    var c = e[a];
                    switch (a) {
                      case "keyframe":
                        qe = 0 | c;
                        break;

                      case "global":
                        Ce = 0 | c;
                        break;

                      case "cascade":
                        ge = 0 | c;
                        break;

                      case "compress":
                        we = 0 | c;
                        break;

                      case "semicolon":
                        ve = 0 | c;
                        break;

                      case "preserve":
                        me = 0 | c;
                        break;

                      case "prefix":
                        Oe = null, c ? "function" != typeof c ? Ae = 1 : (Ae = 2, Oe = c) : Ae = 0;
                    }
                }
                return Re;
            }
            function Te(a, c) {
                if (void 0 !== this && this.constructor === Te) return e(a);
                var s = a, t = s.charCodeAt(0);
                t < 33 && (t = (s = s.trim()).charCodeAt(0)), qe > 0 && (De = s.replace(d, t === G ? "" : "-")), 
                t = 1, 1 === ge ? Ge = s : Ee = s;
                var i, f = [ Ge ];
                ye > 0 && void 0 !== (i = Pe(ze, c, f, f, ke, be, 0, 0, 0, 0)) && "string" == typeof i && (c = i);
                var n = He(xe, f, c, 0, 0);
                return ye > 0 && void 0 !== (i = Pe(je, n, f, f, ke, be, n.length, 0, 0, 0)) && "string" != typeof (n = i) && (t = 0), 
                De = "", Ge = "", Ee = "", pe = 0, ke = 1, be = 1, we * t == 0 ? n : n.replace(r, "").replace(g, "").replace(A, "$1").replace(C, "$1").replace(w, " ");
            }
            var c = /^\0+/g, r = /[\0\r\f]/g, s = /: */g, t = /zoo|gra/, i = /([,: ])(transform)/g, f = /,+\s*(?![^(]*[)])/g, n = / +\s*(?![^(]*[)])/g, l = / *[\0] */g, o = /,\r+?/g, h = /([\t\r\n ])*\f?&/g, u = /:global\(((?:[^\(\)\[\]]*|\[.*\]|\([^\(\)]*\))*)\)/g, d = /\W+/g, b = /@(k\w+)\s*(\S*)\s*/, k = /::(place)/g, p = /:(read-only)/g, g = /\s+(?=[{\];=:>])/g, A = /([[}=:>])\s+/g, C = /(\{[^{]+?);(?=\})/g, w = /\s{2,}/g, v = /([^\(])(:+) */g, m = /[svh]\w+-[tblr]{2}/, x = /\(\s*(.*)\s*\)/g, $ = /([\s\S]*?);/g, y = /-self|flex-/g, O = /[^]*?(:[rp][el]a[\w-]+)[^]*/, j = /stretch|:\s*\w+\-(?:conte|avail)/, z = /([^-])(image-set\()/, F = "-webkit-", N = "-moz-", S = "-ms-", B = 59, W = 125, q = 123, D = 40, E = 41, G = 91, H = 93, I = 10, J = 13, K = 9, L = 64, M = 32, P = 38, Q = 45, R = 95, T = 42, U = 44, V = 58, X = 39, Y = 34, Z = 47, _ = 62, ee = 43, ae = 126, ce = 0, re = 12, se = 11, te = 107, ie = 109, fe = 115, ne = 112, le = 111, oe = 105, he = 99, ue = 100, de = 112, be = 1, ke = 1, pe = 0, ge = 1, Ae = 1, Ce = 1, we = 0, ve = 0, me = 0, xe = [], $e = [], ye = 0, Oe = null, je = -2, ze = -1, Fe = 0, Ne = 1, Se = 2, Be = 3, We = 0, qe = 1, De = "", Ee = "", Ge = "";
            return Te.use = function e(a) {
                switch (a) {
                  case void 0:
                  case null:
                    ye = $e.length = 0;
                    break;

                  default:
                    switch (a.constructor) {
                      case Array:
                        for (var c = 0, r = a.length; c < r; ++c) e(a[c]);
                        break;

                      case Function:
                        $e[ye++] = a;
                        break;

                      case Boolean:
                        We = 0 | !!a;
                    }
                }
                return e;
            }, Te.set = Re, void 0 !== a && Re(a), Te;
        });
    }, /* 131 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(module) {
            !function(factory) {
                module.exports = factory();
            }(function() {
                "use strict";
                return function(insertRule) {
                    function toSheet(block) {
                        if (block) try {
                            insertRule(block + "}");
                        } catch (e) {}
                    }
                    var delimiter = "/*|*/", needle = delimiter + "}";
                    return function(context, content, selectors, parents, line, column, length, ns, depth, at) {
                        switch (context) {
                          // property
                            case 1:
                            // @import
                            if (0 === depth && 64 === content.charCodeAt(0)) return insertRule(content + ";"), 
                            "";
                            break;

                          // selector
                            case 2:
                            if (0 === ns) return content + delimiter;
                            break;

                          // at-rule
                            case 3:
                            switch (ns) {
                              // @font-face, @page
                                case 102:
                              case 112:
                                return insertRule(selectors[0] + content), "";

                              default:
                                return content + (0 === at ? delimiter : "");
                            }

                          case -2:
                            content.split(needle).forEach(toSheet);
                        }
                    };
                };
            });
        }).call(exports, __webpack_require__(124)(module));
    }, /* 132 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(process) {
            "use strict";
            "production" === process.env.NODE_ENV ? module.exports = __webpack_require__(133) : module.exports = __webpack_require__(134);
        }).call(exports, __webpack_require__(110));
    }, /* 133 */
    /***/
    function(module, exports) {
        /** @license React v16.6.0
	 * react-is.production.min.js
	 *
	 * Copyright (c) Facebook, Inc. and its affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
        "use strict";
        function t(a) {
            if ("object" == typeof a && null !== a) {
                var p = a.$$typeof;
                switch (p) {
                  case c:
                    switch (a = a.type) {
                      case l:
                      case e:
                      case g:
                      case f:
                        return a;

                      default:
                        switch (a = a && a.$$typeof) {
                          case k:
                          case m:
                          case h:
                            return a;

                          default:
                            return p;
                        }
                    }

                  case d:
                    return p;
                }
            }
        }
        function u(a) {
            return t(a) === l;
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var b = "function" == typeof Symbol && Symbol.for, c = b ? Symbol.for("react.element") : 60103, d = b ? Symbol.for("react.portal") : 60106, e = b ? Symbol.for("react.fragment") : 60107, f = b ? Symbol.for("react.strict_mode") : 60108, g = b ? Symbol.for("react.profiler") : 60114, h = b ? Symbol.for("react.provider") : 60109, k = b ? Symbol.for("react.context") : 60110, l = b ? Symbol.for("react.concurrent_mode") : 60111, m = b ? Symbol.for("react.forward_ref") : 60112, n = b ? Symbol.for("react.suspense") : 60113, q = b ? Symbol.for("react.memo") : 60115, r = b ? Symbol.for("react.lazy") : 60116;
        exports.typeOf = t, exports.AsyncMode = l, exports.ConcurrentMode = l, exports.ContextConsumer = k, 
        exports.ContextProvider = h, exports.Element = c, exports.ForwardRef = m, exports.Fragment = e, 
        exports.Profiler = g, exports.Portal = d, exports.StrictMode = f, exports.isValidElementType = function(a) {
            return "string" == typeof a || "function" == typeof a || a === e || a === l || a === g || a === f || a === n || "object" == typeof a && null !== a && (a.$$typeof === r || a.$$typeof === q || a.$$typeof === h || a.$$typeof === k || a.$$typeof === m);
        }, exports.isAsyncMode = function(a) {
            return u(a);
        }, exports.isConcurrentMode = u, exports.isContextConsumer = function(a) {
            return t(a) === k;
        }, exports.isContextProvider = function(a) {
            return t(a) === h;
        }, exports.isElement = function(a) {
            return "object" == typeof a && null !== a && a.$$typeof === c;
        }, exports.isForwardRef = function(a) {
            return t(a) === m;
        }, exports.isFragment = function(a) {
            return t(a) === e;
        }, exports.isProfiler = function(a) {
            return t(a) === g;
        }, exports.isPortal = function(a) {
            return t(a) === d;
        }, exports.isStrictMode = function(a) {
            return t(a) === f;
        };
    }, /* 134 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(process) {
            /** @license React v16.6.0
	 * react-is.development.js
	 *
	 * Copyright (c) Facebook, Inc. and its affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
            "use strict";
            "production" !== process.env.NODE_ENV && !function() {
                function isValidElementType(type) {
                    // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
                    return "string" == typeof type || "function" == typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || "object" == typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE);
                }
                function typeOf(object) {
                    if ("object" == typeof object && null !== object) {
                        var $$typeof = object.$$typeof;
                        switch ($$typeof) {
                          case REACT_ELEMENT_TYPE:
                            var type = object.type;
                            switch (type) {
                              case REACT_CONCURRENT_MODE_TYPE:
                              case REACT_FRAGMENT_TYPE:
                              case REACT_PROFILER_TYPE:
                              case REACT_STRICT_MODE_TYPE:
                                return type;

                              default:
                                var $$typeofType = type && type.$$typeof;
                                switch ($$typeofType) {
                                  case REACT_CONTEXT_TYPE:
                                  case REACT_FORWARD_REF_TYPE:
                                  case REACT_PROVIDER_TYPE:
                                    return $$typeofType;

                                  default:
                                    return $$typeof;
                                }
                            }

                          case REACT_PORTAL_TYPE:
                            return $$typeof;
                        }
                    }
                }
                // AsyncMode should be deprecated
                function isAsyncMode(object) {
                    return hasWarnedAboutDeprecatedIsAsyncMode || (hasWarnedAboutDeprecatedIsAsyncMode = !0, 
                    lowPriorityWarning$1(!1, "The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), 
                    isConcurrentMode(object);
                }
                function isConcurrentMode(object) {
                    return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
                }
                function isContextConsumer(object) {
                    return typeOf(object) === REACT_CONTEXT_TYPE;
                }
                function isContextProvider(object) {
                    return typeOf(object) === REACT_PROVIDER_TYPE;
                }
                function isElement(object) {
                    return "object" == typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
                }
                function isForwardRef(object) {
                    return typeOf(object) === REACT_FORWARD_REF_TYPE;
                }
                function isFragment(object) {
                    return typeOf(object) === REACT_FRAGMENT_TYPE;
                }
                function isProfiler(object) {
                    return typeOf(object) === REACT_PROFILER_TYPE;
                }
                function isPortal(object) {
                    return typeOf(object) === REACT_PORTAL_TYPE;
                }
                function isStrictMode(object) {
                    return typeOf(object) === REACT_STRICT_MODE_TYPE;
                }
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                });
                // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
                // nor polyfill, then a plain number is used for performance.
                var hasSymbol = "function" == typeof Symbol && Symbol.for, REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103, REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106, REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107, REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108, REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114, REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109, REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110, REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111, REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112, REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113, REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115, REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116, lowPriorityWarning = function() {}, printWarning = function(format) {
                    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];
                    var argIndex = 0, message = "Warning: " + format.replace(/%s/g, function() {
                        return args[argIndex++];
                    });
                    "undefined" != typeof console && console.warn(message);
                    try {
                        // --- Welcome to debugging React ---
                        // This error was thrown as a convenience so that you can use this stack
                        // to find the callsite that caused this warning to fire.
                        throw new Error(message);
                    } catch (x) {}
                };
                lowPriorityWarning = function(condition, format) {
                    if (void 0 === format) throw new Error("`lowPriorityWarning(condition, format, ...args)` requires a warning message argument");
                    if (!condition) {
                        for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) args[_key2 - 2] = arguments[_key2];
                        printWarning.apply(void 0, [ format ].concat(args));
                    }
                };
                var lowPriorityWarning$1 = lowPriorityWarning, AsyncMode = REACT_CONCURRENT_MODE_TYPE, ConcurrentMode = REACT_CONCURRENT_MODE_TYPE, ContextConsumer = REACT_CONTEXT_TYPE, ContextProvider = REACT_PROVIDER_TYPE, Element = REACT_ELEMENT_TYPE, ForwardRef = REACT_FORWARD_REF_TYPE, Fragment = REACT_FRAGMENT_TYPE, Profiler = REACT_PROFILER_TYPE, Portal = REACT_PORTAL_TYPE, StrictMode = REACT_STRICT_MODE_TYPE, hasWarnedAboutDeprecatedIsAsyncMode = !1;
                exports.typeOf = typeOf, exports.AsyncMode = AsyncMode, exports.ConcurrentMode = ConcurrentMode, 
                exports.ContextConsumer = ContextConsumer, exports.ContextProvider = ContextProvider, 
                exports.Element = Element, exports.ForwardRef = ForwardRef, exports.Fragment = Fragment, 
                exports.Profiler = Profiler, exports.Portal = Portal, exports.StrictMode = StrictMode, 
                exports.isValidElementType = isValidElementType, exports.isAsyncMode = isAsyncMode, 
                exports.isConcurrentMode = isConcurrentMode, exports.isContextConsumer = isContextConsumer, 
                exports.isContextProvider = isContextProvider, exports.isElement = isElement, exports.isForwardRef = isForwardRef, 
                exports.isFragment = isFragment, exports.isProfiler = isProfiler, exports.isPortal = isPortal, 
                exports.isStrictMode = isStrictMode;
            }();
        }).call(exports, __webpack_require__(110));
    }, /* 135 */
    /***/
    function(module, exports) {
        "use strict";
        function index(resultFn, isEqual) {
            void 0 === isEqual && (isEqual = simpleIsEqual);
            var lastThis, lastResult, lastArgs = [], calledOnce = !1, isNewArgEqualToLast = function(newArg, index) {
                return isEqual(newArg, lastArgs[index]);
            }, result = function() {
                for (var _len = arguments.length, newArgs = new Array(_len), _key = 0; _key < _len; _key++) newArgs[_key] = arguments[_key];
                return calledOnce && lastThis === this && newArgs.length === lastArgs.length && newArgs.every(isNewArgEqualToLast) ? lastResult : (lastResult = resultFn.apply(this, newArgs), 
                calledOnce = !0, lastThis = this, lastArgs = newArgs, lastResult);
            };
            return result;
        }
        var simpleIsEqual = function(a, b) {
            return a === b;
        };
        module.exports = index;
    }, /* 136 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopDefault(ex) {
            return ex && "object" == typeof ex && "default" in ex ? ex.default : ex;
        }
        var memoize = _interopDefault(__webpack_require__(137)), reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|default|defer|dir|disabled|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|itemProp|itemScope|itemType|itemID|itemRef|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class)|(on[A-Z].*)|((data|aria|x)-.*))$/i, index = memoize(reactPropsRegex.test.bind(reactPropsRegex));
        module.exports = index;
    }, /* 137 */
    /***/
    function(module, exports) {
        "use strict";
        function memoize(fn) {
            var cache = {};
            return function(arg) {
                return void 0 === cache[arg] && (cache[arg] = fn(arg)), cache[arg];
            };
        }
        module.exports = memoize;
    }, /* 138 */
    /***/
    function(module, exports, __webpack_require__) {
        // CodeMirror, copyright (c) by Marijn Haverbeke and others
        // Distributed under an MIT license: http://codemirror.net/LICENSE
        !function(mod) {
            // CommonJS
            mod(__webpack_require__(128), __webpack_require__(139), __webpack_require__(140));
        }(function(CodeMirror) {
            "use strict";
            // Depth means the amount of open braces in JS context, in XML
            // context 0 means not in tag, 1 means in tag, and 2 means in tag
            // and js block comment.
            function Context(state, mode, depth, prev) {
                this.state = state, this.mode = mode, this.depth = depth, this.prev = prev;
            }
            function copyContext(context) {
                return new Context(CodeMirror.copyState(context.mode, context.state), context.mode, context.depth, context.prev && copyContext(context.prev));
            }
            CodeMirror.defineMode("jsx", function(config, modeConfig) {
                function flatXMLIndent(state) {
                    var tagName = state.tagName;
                    state.tagName = null;
                    var result = xmlMode.indent(state, "");
                    return state.tagName = tagName, result;
                }
                function token(stream, state) {
                    return state.context.mode == xmlMode ? xmlToken(stream, state, state.context) : jsToken(stream, state, state.context);
                }
                function xmlToken(stream, state, cx) {
                    if (2 == cx.depth) // Inside a JS /* */ comment
                    return stream.match(/^.*?\*\//) ? cx.depth = 1 : stream.skipToEnd(), "comment";
                    if ("{" == stream.peek()) {
                        xmlMode.skipAttribute(cx.state);
                        var indent = flatXMLIndent(cx.state), xmlContext = cx.state.context;
                        // If JS starts on same line as tag
                        if (xmlContext && stream.match(/^[^>]*>\s*$/, !1)) {
                            for (;xmlContext.prev && !xmlContext.startOfLine; ) xmlContext = xmlContext.prev;
                            // If tag starts the line, use XML indentation level
                            xmlContext.startOfLine ? indent -= config.indentUnit : cx.prev.state.lexical && (indent = cx.prev.state.lexical.indented);
                        } else 1 == cx.depth && (indent += config.indentUnit);
                        return state.context = new Context(CodeMirror.startState(jsMode, indent), jsMode, 0, state.context), 
                        null;
                    }
                    if (1 == cx.depth) {
                        // Inside of tag
                        if ("<" == stream.peek()) // Tag inside of tag
                        return xmlMode.skipAttribute(cx.state), state.context = new Context(CodeMirror.startState(xmlMode, flatXMLIndent(cx.state)), xmlMode, 0, state.context), 
                        null;
                        if (stream.match("//")) return stream.skipToEnd(), "comment";
                        if (stream.match("/*")) return cx.depth = 2, token(stream, state);
                    }
                    var stop, style = xmlMode.token(stream, cx.state), cur = stream.current();
                    return /\btag\b/.test(style) ? />$/.test(cur) ? cx.state.context ? cx.depth = 0 : state.context = state.context.prev : /^</.test(cur) && (cx.depth = 1) : !style && (stop = cur.indexOf("{")) > -1 && stream.backUp(cur.length - stop), 
                    style;
                }
                function jsToken(stream, state, cx) {
                    if ("<" == stream.peek() && jsMode.expressionAllowed(stream, cx.state)) return jsMode.skipExpression(cx.state), 
                    state.context = new Context(CodeMirror.startState(xmlMode, jsMode.indent(cx.state, "")), xmlMode, 0, state.context), 
                    null;
                    var style = jsMode.token(stream, cx.state);
                    if (!style && null != cx.depth) {
                        var cur = stream.current();
                        "{" == cur ? cx.depth++ : "}" == cur && 0 == --cx.depth && (state.context = state.context.prev);
                    }
                    return style;
                }
                var xmlMode = CodeMirror.getMode(config, {
                    name: "xml",
                    allowMissing: !0,
                    multilineTagIndentPastTag: !1
                }), jsMode = CodeMirror.getMode(config, modeConfig && modeConfig.base || "javascript");
                return {
                    startState: function() {
                        return {
                            context: new Context(CodeMirror.startState(jsMode), jsMode)
                        };
                    },
                    copyState: function(state) {
                        return {
                            context: copyContext(state.context)
                        };
                    },
                    token: token,
                    indent: function(state, textAfter, fullLine) {
                        return state.context.mode.indent(state.context.state, textAfter, fullLine);
                    },
                    innerMode: function(state) {
                        return state.context;
                    }
                };
            }, "xml", "javascript"), CodeMirror.defineMIME("text/jsx", "jsx"), CodeMirror.defineMIME("text/typescript-jsx", {
                name: "jsx",
                base: {
                    name: "javascript",
                    typescript: !0
                }
            });
        });
    }, /* 139 */
    /***/
    function(module, exports, __webpack_require__) {
        // CodeMirror, copyright (c) by Marijn Haverbeke and others
        // Distributed under an MIT license: http://codemirror.net/LICENSE
        !function(mod) {
            // CommonJS
            mod(__webpack_require__(128));
        }(function(CodeMirror) {
            "use strict";
            var htmlConfig = {
                autoSelfClosers: {
                    area: !0,
                    base: !0,
                    br: !0,
                    col: !0,
                    command: !0,
                    embed: !0,
                    frame: !0,
                    hr: !0,
                    img: !0,
                    input: !0,
                    keygen: !0,
                    link: !0,
                    meta: !0,
                    param: !0,
                    source: !0,
                    track: !0,
                    wbr: !0,
                    menuitem: !0
                },
                implicitlyClosed: {
                    dd: !0,
                    li: !0,
                    optgroup: !0,
                    option: !0,
                    p: !0,
                    rp: !0,
                    rt: !0,
                    tbody: !0,
                    td: !0,
                    tfoot: !0,
                    th: !0,
                    tr: !0
                },
                contextGrabbers: {
                    dd: {
                        dd: !0,
                        dt: !0
                    },
                    dt: {
                        dd: !0,
                        dt: !0
                    },
                    li: {
                        li: !0
                    },
                    option: {
                        option: !0,
                        optgroup: !0
                    },
                    optgroup: {
                        optgroup: !0
                    },
                    p: {
                        address: !0,
                        article: !0,
                        aside: !0,
                        blockquote: !0,
                        dir: !0,
                        div: !0,
                        dl: !0,
                        fieldset: !0,
                        footer: !0,
                        form: !0,
                        h1: !0,
                        h2: !0,
                        h3: !0,
                        h4: !0,
                        h5: !0,
                        h6: !0,
                        header: !0,
                        hgroup: !0,
                        hr: !0,
                        menu: !0,
                        nav: !0,
                        ol: !0,
                        p: !0,
                        pre: !0,
                        section: !0,
                        table: !0,
                        ul: !0
                    },
                    rp: {
                        rp: !0,
                        rt: !0
                    },
                    rt: {
                        rp: !0,
                        rt: !0
                    },
                    tbody: {
                        tbody: !0,
                        tfoot: !0
                    },
                    td: {
                        td: !0,
                        th: !0
                    },
                    tfoot: {
                        tbody: !0
                    },
                    th: {
                        td: !0,
                        th: !0
                    },
                    thead: {
                        tbody: !0,
                        tfoot: !0
                    },
                    tr: {
                        tr: !0
                    }
                },
                doNotIndent: {
                    pre: !0
                },
                allowUnquoted: !0,
                allowMissing: !0,
                caseFold: !0
            }, xmlConfig = {
                autoSelfClosers: {},
                implicitlyClosed: {},
                contextGrabbers: {},
                doNotIndent: {},
                allowUnquoted: !1,
                allowMissing: !1,
                caseFold: !1
            };
            CodeMirror.defineMode("xml", function(editorConf, config_) {
                function inText(stream, state) {
                    function chain(parser) {
                        return state.tokenize = parser, parser(stream, state);
                    }
                    var ch = stream.next();
                    if ("<" == ch) return stream.eat("!") ? stream.eat("[") ? stream.match("CDATA[") ? chain(inBlock("atom", "]]>")) : null : stream.match("--") ? chain(inBlock("comment", "-->")) : stream.match("DOCTYPE", !0, !0) ? (stream.eatWhile(/[\w\._\-]/), 
                    chain(doctype(1))) : null : stream.eat("?") ? (stream.eatWhile(/[\w\._\-]/), state.tokenize = inBlock("meta", "?>"), 
                    "meta") : (type = stream.eat("/") ? "closeTag" : "openTag", state.tokenize = inTag, 
                    "tag bracket");
                    if ("&" == ch) {
                        var ok;
                        return ok = stream.eat("#") ? stream.eat("x") ? stream.eatWhile(/[a-fA-F\d]/) && stream.eat(";") : stream.eatWhile(/[\d]/) && stream.eat(";") : stream.eatWhile(/[\w\.\-:]/) && stream.eat(";"), 
                        ok ? "atom" : "error";
                    }
                    return stream.eatWhile(/[^&<]/), null;
                }
                function inTag(stream, state) {
                    var ch = stream.next();
                    if (">" == ch || "/" == ch && stream.eat(">")) return state.tokenize = inText, type = ">" == ch ? "endTag" : "selfcloseTag", 
                    "tag bracket";
                    if ("=" == ch) return type = "equals", null;
                    if ("<" == ch) {
                        state.tokenize = inText, state.state = baseState, state.tagName = state.tagStart = null;
                        var next = state.tokenize(stream, state);
                        return next ? next + " tag error" : "tag error";
                    }
                    return /[\'\"]/.test(ch) ? (state.tokenize = inAttribute(ch), state.stringStartCol = stream.column(), 
                    state.tokenize(stream, state)) : (stream.match(/^[^\s\u00a0=<>\"\']*[^\s\u00a0=<>\"\'\/]/), 
                    "word");
                }
                function inAttribute(quote) {
                    var closure = function(stream, state) {
                        for (;!stream.eol(); ) if (stream.next() == quote) {
                            state.tokenize = inTag;
                            break;
                        }
                        return "string";
                    };
                    return closure.isInAttribute = !0, closure;
                }
                function inBlock(style, terminator) {
                    return function(stream, state) {
                        for (;!stream.eol(); ) {
                            if (stream.match(terminator)) {
                                state.tokenize = inText;
                                break;
                            }
                            stream.next();
                        }
                        return style;
                    };
                }
                function doctype(depth) {
                    return function(stream, state) {
                        for (var ch; null != (ch = stream.next()); ) {
                            if ("<" == ch) return state.tokenize = doctype(depth + 1), state.tokenize(stream, state);
                            if (">" == ch) {
                                if (1 == depth) {
                                    state.tokenize = inText;
                                    break;
                                }
                                return state.tokenize = doctype(depth - 1), state.tokenize(stream, state);
                            }
                        }
                        return "meta";
                    };
                }
                function Context(state, tagName, startOfLine) {
                    this.prev = state.context, this.tagName = tagName, this.indent = state.indented, 
                    this.startOfLine = startOfLine, (config.doNotIndent.hasOwnProperty(tagName) || state.context && state.context.noIndent) && (this.noIndent = !0);
                }
                function popContext(state) {
                    state.context && (state.context = state.context.prev);
                }
                function maybePopContext(state, nextTagName) {
                    for (var parentTagName; ;) {
                        if (!state.context) return;
                        if (parentTagName = state.context.tagName, !config.contextGrabbers.hasOwnProperty(parentTagName) || !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) return;
                        popContext(state);
                    }
                }
                function baseState(type, stream, state) {
                    return "openTag" == type ? (state.tagStart = stream.column(), tagNameState) : "closeTag" == type ? closeTagNameState : baseState;
                }
                function tagNameState(type, stream, state) {
                    return "word" == type ? (state.tagName = stream.current(), setStyle = "tag", attrState) : (setStyle = "error", 
                    tagNameState);
                }
                function closeTagNameState(type, stream, state) {
                    if ("word" == type) {
                        var tagName = stream.current();
                        return state.context && state.context.tagName != tagName && config.implicitlyClosed.hasOwnProperty(state.context.tagName) && popContext(state), 
                        state.context && state.context.tagName == tagName || config.matchClosing === !1 ? (setStyle = "tag", 
                        closeState) : (setStyle = "tag error", closeStateErr);
                    }
                    return setStyle = "error", closeStateErr;
                }
                function closeState(type, _stream, state) {
                    return "endTag" != type ? (setStyle = "error", closeState) : (popContext(state), 
                    baseState);
                }
                function closeStateErr(type, stream, state) {
                    return setStyle = "error", closeState(type, stream, state);
                }
                function attrState(type, _stream, state) {
                    if ("word" == type) return setStyle = "attribute", attrEqState;
                    if ("endTag" == type || "selfcloseTag" == type) {
                        var tagName = state.tagName, tagStart = state.tagStart;
                        return state.tagName = state.tagStart = null, "selfcloseTag" == type || config.autoSelfClosers.hasOwnProperty(tagName) ? maybePopContext(state, tagName) : (maybePopContext(state, tagName), 
                        state.context = new Context(state, tagName, tagStart == state.indented)), baseState;
                    }
                    return setStyle = "error", attrState;
                }
                function attrEqState(type, stream, state) {
                    return "equals" == type ? attrValueState : (config.allowMissing || (setStyle = "error"), 
                    attrState(type, stream, state));
                }
                function attrValueState(type, stream, state) {
                    return "string" == type ? attrContinuedState : "word" == type && config.allowUnquoted ? (setStyle = "string", 
                    attrState) : (setStyle = "error", attrState(type, stream, state));
                }
                function attrContinuedState(type, stream, state) {
                    return "string" == type ? attrContinuedState : attrState(type, stream, state);
                }
                var indentUnit = editorConf.indentUnit, config = {}, defaults = config_.htmlMode ? htmlConfig : xmlConfig;
                for (var prop in defaults) config[prop] = defaults[prop];
                for (var prop in config_) config[prop] = config_[prop];
                // Return variables for tokenizers
                var type, setStyle;
                return inText.isInText = !0, {
                    startState: function(baseIndent) {
                        var state = {
                            tokenize: inText,
                            state: baseState,
                            indented: baseIndent || 0,
                            tagName: null,
                            tagStart: null,
                            context: null
                        };
                        return null != baseIndent && (state.baseIndent = baseIndent), state;
                    },
                    token: function(stream, state) {
                        if (!state.tagName && stream.sol() && (state.indented = stream.indentation()), stream.eatSpace()) return null;
                        type = null;
                        var style = state.tokenize(stream, state);
                        return (style || type) && "comment" != style && (setStyle = null, state.state = state.state(type || style, stream, state), 
                        setStyle && (style = "error" == setStyle ? style + " error" : setStyle)), style;
                    },
                    indent: function(state, textAfter, fullLine) {
                        var context = state.context;
                        // Indent multi-line strings (e.g. css).
                        if (state.tokenize.isInAttribute) return state.tagStart == state.indented ? state.stringStartCol + 1 : state.indented + indentUnit;
                        if (context && context.noIndent) return CodeMirror.Pass;
                        if (state.tokenize != inTag && state.tokenize != inText) return fullLine ? fullLine.match(/^(\s*)/)[0].length : 0;
                        // Indent the starts of attribute names.
                        if (state.tagName) return config.multilineTagIndentPastTag !== !1 ? state.tagStart + state.tagName.length + 2 : state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);
                        if (config.alignCDATA && /<!\[CDATA\[/.test(textAfter)) return 0;
                        var tagAfter = textAfter && /^<(\/)?([\w_:\.-]*)/.exec(textAfter);
                        if (tagAfter && tagAfter[1]) // Closing tag spotted
                        for (;context; ) {
                            if (context.tagName == tagAfter[2]) {
                                context = context.prev;
                                break;
                            }
                            if (!config.implicitlyClosed.hasOwnProperty(context.tagName)) break;
                            context = context.prev;
                        } else if (tagAfter) // Opening tag spotted
                        for (;context; ) {
                            var grabbers = config.contextGrabbers[context.tagName];
                            if (!grabbers || !grabbers.hasOwnProperty(tagAfter[2])) break;
                            context = context.prev;
                        }
                        for (;context && context.prev && !context.startOfLine; ) context = context.prev;
                        return context ? context.indent + indentUnit : state.baseIndent || 0;
                    },
                    electricInput: /<\/[\s\w:]+>$/,
                    blockCommentStart: "<!--",
                    blockCommentEnd: "-->",
                    configuration: config.htmlMode ? "html" : "xml",
                    helperType: config.htmlMode ? "html" : "xml",
                    skipAttribute: function(state) {
                        state.state == attrValueState && (state.state = attrState);
                    }
                };
            }), CodeMirror.defineMIME("text/xml", "xml"), CodeMirror.defineMIME("application/xml", "xml"), 
            CodeMirror.mimeModes.hasOwnProperty("text/html") || CodeMirror.defineMIME("text/html", {
                name: "xml",
                htmlMode: !0
            });
        });
    }, /* 140 */
    /***/
    function(module, exports, __webpack_require__) {
        // CodeMirror, copyright (c) by Marijn Haverbeke and others
        // Distributed under an MIT license: http://codemirror.net/LICENSE
        !function(mod) {
            // CommonJS
            mod(__webpack_require__(128));
        }(function(CodeMirror) {
            "use strict";
            CodeMirror.defineMode("javascript", function(config, parserConfig) {
                function readRegexp(stream) {
                    for (var next, escaped = !1, inSet = !1; null != (next = stream.next()); ) {
                        if (!escaped) {
                            if ("/" == next && !inSet) return;
                            "[" == next ? inSet = !0 : inSet && "]" == next && (inSet = !1);
                        }
                        escaped = !escaped && "\\" == next;
                    }
                }
                function ret(tp, style, cont) {
                    return type = tp, content = cont, style;
                }
                function tokenBase(stream, state) {
                    var ch = stream.next();
                    if ('"' == ch || "'" == ch) return state.tokenize = tokenString(ch), state.tokenize(stream, state);
                    if ("." == ch && stream.match(/^\d+(?:[eE][+\-]?\d+)?/)) return ret("number", "number");
                    if ("." == ch && stream.match("..")) return ret("spread", "meta");
                    if (/[\[\]{}\(\),;\:\.]/.test(ch)) return ret(ch);
                    if ("=" == ch && stream.eat(">")) return ret("=>", "operator");
                    if ("0" == ch && stream.eat(/x/i)) return stream.eatWhile(/[\da-f]/i), ret("number", "number");
                    if ("0" == ch && stream.eat(/o/i)) return stream.eatWhile(/[0-7]/i), ret("number", "number");
                    if ("0" == ch && stream.eat(/b/i)) return stream.eatWhile(/[01]/i), ret("number", "number");
                    if (/\d/.test(ch)) return stream.match(/^\d*(?:\.\d*)?(?:[eE][+\-]?\d+)?/), ret("number", "number");
                    if ("/" == ch) return stream.eat("*") ? (state.tokenize = tokenComment, tokenComment(stream, state)) : stream.eat("/") ? (stream.skipToEnd(), 
                    ret("comment", "comment")) : expressionAllowed(stream, state, 1) ? (readRegexp(stream), 
                    stream.match(/^\b(([gimyu])(?![gimyu]*\2))+\b/), ret("regexp", "string-2")) : (stream.eat("="), 
                    ret("operator", "operator", stream.current()));
                    if ("`" == ch) return state.tokenize = tokenQuasi, tokenQuasi(stream, state);
                    if ("#" == ch) return stream.skipToEnd(), ret("error", "error");
                    if (isOperatorChar.test(ch)) return ">" == ch && state.lexical && ">" == state.lexical.type || (stream.eat("=") ? "!" != ch && "=" != ch || stream.eat("=") : /[<>*+\-]/.test(ch) && (stream.eat(ch), 
                    ">" == ch && stream.eat(ch))), ret("operator", "operator", stream.current());
                    if (wordRE.test(ch)) {
                        stream.eatWhile(wordRE);
                        var word = stream.current();
                        if ("." != state.lastType) {
                            if (keywords.propertyIsEnumerable(word)) {
                                var kw = keywords[word];
                                return ret(kw.type, kw.style, word);
                            }
                            if ("async" == word && stream.match(/^\s*[\(\w]/, !1)) return ret("async", "keyword", word);
                        }
                        return ret("variable", "variable", word);
                    }
                }
                function tokenString(quote) {
                    return function(stream, state) {
                        var next, escaped = !1;
                        if (jsonldMode && "@" == stream.peek() && stream.match(isJsonldKeyword)) return state.tokenize = tokenBase, 
                        ret("jsonld-keyword", "meta");
                        for (;null != (next = stream.next()) && (next != quote || escaped); ) escaped = !escaped && "\\" == next;
                        return escaped || (state.tokenize = tokenBase), ret("string", "string");
                    };
                }
                function tokenComment(stream, state) {
                    for (var ch, maybeEnd = !1; ch = stream.next(); ) {
                        if ("/" == ch && maybeEnd) {
                            state.tokenize = tokenBase;
                            break;
                        }
                        maybeEnd = "*" == ch;
                    }
                    return ret("comment", "comment");
                }
                function tokenQuasi(stream, state) {
                    for (var next, escaped = !1; null != (next = stream.next()); ) {
                        if (!escaped && ("`" == next || "$" == next && stream.eat("{"))) {
                            state.tokenize = tokenBase;
                            break;
                        }
                        escaped = !escaped && "\\" == next;
                    }
                    return ret("quasi", "string-2", stream.current());
                }
                // This is a crude lookahead trick to try and notice that we're
                // parsing the argument patterns for a fat-arrow function before we
                // actually hit the arrow token. It only works if the arrow is on
                // the same line as the arguments and there's no strange noise
                // (comments) in between. Fallback is to only notice when we hit the
                // arrow, and not declare the arguments as locals for the arrow
                // body.
                function findFatArrow(stream, state) {
                    state.fatArrowAt && (state.fatArrowAt = null);
                    var arrow = stream.string.indexOf("=>", stream.start);
                    if (!(arrow < 0)) {
                        if (isTS) {
                            // Try to skip TypeScript return type declarations after the arguments
                            var m = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(stream.string.slice(stream.start, arrow));
                            m && (arrow = m.index);
                        }
                        for (var depth = 0, sawSomething = !1, pos = arrow - 1; pos >= 0; --pos) {
                            var ch = stream.string.charAt(pos), bracket = brackets.indexOf(ch);
                            if (bracket >= 0 && bracket < 3) {
                                if (!depth) {
                                    ++pos;
                                    break;
                                }
                                if (0 == --depth) {
                                    "(" == ch && (sawSomething = !0);
                                    break;
                                }
                            } else if (bracket >= 3 && bracket < 6) ++depth; else if (wordRE.test(ch)) sawSomething = !0; else {
                                if (/["'\/]/.test(ch)) return;
                                if (sawSomething && !depth) {
                                    ++pos;
                                    break;
                                }
                            }
                        }
                        sawSomething && !depth && (state.fatArrowAt = pos);
                    }
                }
                function JSLexical(indented, column, type, align, prev, info) {
                    this.indented = indented, this.column = column, this.type = type, this.prev = prev, 
                    this.info = info, null != align && (this.align = align);
                }
                function inScope(state, varname) {
                    for (var v = state.localVars; v; v = v.next) if (v.name == varname) return !0;
                    for (var cx = state.context; cx; cx = cx.prev) for (var v = cx.vars; v; v = v.next) if (v.name == varname) return !0;
                }
                function parseJS(state, style, type, content, stream) {
                    var cc = state.cc;
                    for (// Communicate our context to the combinators.
                    // (Less wasteful than consing up a hundred closures on every call.)
                    cx.state = state, cx.stream = stream, cx.marked = null, cx.cc = cc, cx.style = style, 
                    state.lexical.hasOwnProperty("align") || (state.lexical.align = !0); ;) {
                        var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
                        if (combinator(type, content)) {
                            for (;cc.length && cc[cc.length - 1].lex; ) cc.pop()();
                            return cx.marked ? cx.marked : "variable" == type && inScope(state, content) ? "variable-2" : style;
                        }
                    }
                }
                function pass() {
                    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);
                }
                function cont() {
                    return pass.apply(null, arguments), !0;
                }
                function register(varname) {
                    function inList(list) {
                        for (var v = list; v; v = v.next) if (v.name == varname) return !0;
                        return !1;
                    }
                    var state = cx.state;
                    if (cx.marked = "def", state.context) {
                        if (inList(state.localVars)) return;
                        state.localVars = {
                            name: varname,
                            next: state.localVars
                        };
                    } else {
                        if (inList(state.globalVars)) return;
                        parserConfig.globalVars && (state.globalVars = {
                            name: varname,
                            next: state.globalVars
                        });
                    }
                }
                function pushcontext() {
                    cx.state.context = {
                        prev: cx.state.context,
                        vars: cx.state.localVars
                    }, cx.state.localVars = defaultVars;
                }
                function popcontext() {
                    cx.state.localVars = cx.state.context.vars, cx.state.context = cx.state.context.prev;
                }
                function pushlex(type, info) {
                    var result = function() {
                        var state = cx.state, indent = state.indented;
                        if ("stat" == state.lexical.type) indent = state.lexical.indented; else for (var outer = state.lexical; outer && ")" == outer.type && outer.align; outer = outer.prev) indent = outer.indented;
                        state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);
                    };
                    return result.lex = !0, result;
                }
                function poplex() {
                    var state = cx.state;
                    state.lexical.prev && (")" == state.lexical.type && (state.indented = state.lexical.indented), 
                    state.lexical = state.lexical.prev);
                }
                function expect(wanted) {
                    function exp(type) {
                        return type == wanted ? cont() : ";" == wanted ? pass() : cont(exp);
                    }
                    return exp;
                }
                function statement(type, value) {
                    return "var" == type ? cont(pushlex("vardef", value.length), vardef, expect(";"), poplex) : "keyword a" == type ? cont(pushlex("form"), parenExpr, statement, poplex) : "keyword b" == type ? cont(pushlex("form"), statement, poplex) : "keyword d" == type ? cx.stream.match(/^\s*$/, !1) ? cont() : cont(pushlex("stat"), maybeexpression, expect(";"), poplex) : "debugger" == type ? cont(expect(";")) : "{" == type ? cont(pushlex("}"), block, poplex) : ";" == type ? cont() : "if" == type ? ("else" == cx.state.lexical.info && cx.state.cc[cx.state.cc.length - 1] == poplex && cx.state.cc.pop()(), 
                    cont(pushlex("form"), parenExpr, statement, poplex, maybeelse)) : "function" == type ? cont(functiondef) : "for" == type ? cont(pushlex("form"), forspec, statement, poplex) : "variable" == type ? isTS && "type" == value ? (cx.marked = "keyword", 
                    cont(typeexpr, expect("operator"), typeexpr, expect(";"))) : isTS && "declare" == value ? (cx.marked = "keyword", 
                    cont(statement)) : cont(pushlex("stat"), maybelabel) : "switch" == type ? cont(pushlex("form"), parenExpr, expect("{"), pushlex("}", "switch"), block, poplex, poplex) : "case" == type ? cont(expression, expect(":")) : "default" == type ? cont(expect(":")) : "catch" == type ? cont(pushlex("form"), pushcontext, expect("("), funarg, expect(")"), statement, poplex, popcontext) : "class" == type ? cont(pushlex("form"), className, poplex) : "export" == type ? cont(pushlex("stat"), afterExport, poplex) : "import" == type ? cont(pushlex("stat"), afterImport, poplex) : "module" == type ? cont(pushlex("form"), pattern, expect("{"), pushlex("}"), block, poplex, poplex) : "async" == type ? cont(statement) : "@" == value ? cont(expression, statement) : pass(pushlex("stat"), expression, expect(";"), poplex);
                }
                function expression(type) {
                    return expressionInner(type, !1);
                }
                function expressionNoComma(type) {
                    return expressionInner(type, !0);
                }
                function parenExpr(type) {
                    return "(" != type ? pass() : cont(pushlex(")"), expression, expect(")"), poplex);
                }
                function expressionInner(type, noComma) {
                    if (cx.state.fatArrowAt == cx.stream.start) {
                        var body = noComma ? arrowBodyNoComma : arrowBody;
                        if ("(" == type) return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, expect("=>"), body, popcontext);
                        if ("variable" == type) return pass(pushcontext, pattern, expect("=>"), body, popcontext);
                    }
                    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
                    return atomicTypes.hasOwnProperty(type) ? cont(maybeop) : "function" == type ? cont(functiondef, maybeop) : "class" == type ? cont(pushlex("form"), classExpression, poplex) : "keyword c" == type || "async" == type ? cont(noComma ? expressionNoComma : expression) : "(" == type ? cont(pushlex(")"), maybeexpression, expect(")"), poplex, maybeop) : "operator" == type || "spread" == type ? cont(noComma ? expressionNoComma : expression) : "[" == type ? cont(pushlex("]"), arrayLiteral, poplex, maybeop) : "{" == type ? contCommasep(objprop, "}", null, maybeop) : "quasi" == type ? pass(quasi, maybeop) : "new" == type ? cont(maybeTarget(noComma)) : cont();
                }
                function maybeexpression(type) {
                    return type.match(/[;\}\)\],]/) ? pass() : pass(expression);
                }
                function maybeoperatorComma(type, value) {
                    return "," == type ? cont(expression) : maybeoperatorNoComma(type, value, !1);
                }
                function maybeoperatorNoComma(type, value, noComma) {
                    var me = 0 == noComma ? maybeoperatorComma : maybeoperatorNoComma, expr = 0 == noComma ? expression : expressionNoComma;
                    return "=>" == type ? cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext) : "operator" == type ? /\+\+|--/.test(value) || isTS && "!" == value ? cont(me) : "?" == value ? cont(expression, expect(":"), expr) : cont(expr) : "quasi" == type ? pass(quasi, me) : ";" != type ? "(" == type ? contCommasep(expressionNoComma, ")", "call", me) : "." == type ? cont(property, me) : "[" == type ? cont(pushlex("]"), maybeexpression, expect("]"), poplex, me) : isTS && "as" == value ? (cx.marked = "keyword", 
                    cont(typeexpr, me)) : "regexp" == type ? (cx.state.lastType = cx.marked = "operator", 
                    cx.stream.backUp(cx.stream.pos - cx.stream.start - 1), cont(expr)) : void 0 : void 0;
                }
                function quasi(type, value) {
                    return "quasi" != type ? pass() : "${" != value.slice(value.length - 2) ? cont(quasi) : cont(expression, continueQuasi);
                }
                function continueQuasi(type) {
                    if ("}" == type) return cx.marked = "string-2", cx.state.tokenize = tokenQuasi, 
                    cont(quasi);
                }
                function arrowBody(type) {
                    return findFatArrow(cx.stream, cx.state), pass("{" == type ? statement : expression);
                }
                function arrowBodyNoComma(type) {
                    return findFatArrow(cx.stream, cx.state), pass("{" == type ? statement : expressionNoComma);
                }
                function maybeTarget(noComma) {
                    return function(type) {
                        return "." == type ? cont(noComma ? targetNoComma : target) : "variable" == type && isTS ? cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma) : pass(noComma ? expressionNoComma : expression);
                    };
                }
                function target(_, value) {
                    if ("target" == value) return cx.marked = "keyword", cont(maybeoperatorComma);
                }
                function targetNoComma(_, value) {
                    if ("target" == value) return cx.marked = "keyword", cont(maybeoperatorNoComma);
                }
                function maybelabel(type) {
                    return ":" == type ? cont(poplex, statement) : pass(maybeoperatorComma, expect(";"), poplex);
                }
                function property(type) {
                    if ("variable" == type) return cx.marked = "property", cont();
                }
                function objprop(type, value) {
                    if ("async" == type) return cx.marked = "property", cont(objprop);
                    if ("variable" == type || "keyword" == cx.style) {
                        if (cx.marked = "property", "get" == value || "set" == value) return cont(getterSetter);
                        var m;
                        // Work around fat-arrow-detection complication for detecting typescript typed arrow params
                        return isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\s*:\s*/, !1)) && (cx.state.fatArrowAt = cx.stream.pos + m[0].length), 
                        cont(afterprop);
                    }
                    return "number" == type || "string" == type ? (cx.marked = jsonldMode ? "property" : cx.style + " property", 
                    cont(afterprop)) : "jsonld-keyword" == type ? cont(afterprop) : "modifier" == type ? cont(objprop) : "[" == type ? cont(expression, expect("]"), afterprop) : "spread" == type ? cont(expressionNoComma, afterprop) : "*" == value ? (cx.marked = "keyword", 
                    cont(objprop)) : ":" == type ? pass(afterprop) : void 0;
                }
                function getterSetter(type) {
                    return "variable" != type ? pass(afterprop) : (cx.marked = "property", cont(functiondef));
                }
                function afterprop(type) {
                    return ":" == type ? cont(expressionNoComma) : "(" == type ? pass(functiondef) : void 0;
                }
                function commasep(what, end, sep) {
                    function proceed(type, value) {
                        if (sep ? sep.indexOf(type) > -1 : "," == type) {
                            var lex = cx.state.lexical;
                            return "call" == lex.info && (lex.pos = (lex.pos || 0) + 1), cont(function(type, value) {
                                return type == end || value == end ? pass() : pass(what);
                            }, proceed);
                        }
                        return type == end || value == end ? cont() : cont(expect(end));
                    }
                    return function(type, value) {
                        return type == end || value == end ? cont() : pass(what, proceed);
                    };
                }
                function contCommasep(what, end, info) {
                    for (var i = 3; i < arguments.length; i++) cx.cc.push(arguments[i]);
                    return cont(pushlex(end, info), commasep(what, end), poplex);
                }
                function block(type) {
                    return "}" == type ? cont() : pass(statement, block);
                }
                function maybetype(type, value) {
                    if (isTS) {
                        if (":" == type) return cont(typeexpr);
                        if ("?" == value) return cont(maybetype);
                    }
                }
                function typeexpr(type, value) {
                    return "variable" == type || "void" == value ? "keyof" == value ? (cx.marked = "keyword", 
                    cont(typeexpr)) : (cx.marked = "type", cont(afterType)) : "string" == type || "number" == type || "atom" == type ? cont(afterType) : "[" == type ? cont(pushlex("]"), commasep(typeexpr, "]", ","), poplex, afterType) : "{" == type ? cont(pushlex("}"), commasep(typeprop, "}", ",;"), poplex, afterType) : "(" == type ? cont(commasep(typearg, ")"), maybeReturnType) : void 0;
                }
                function maybeReturnType(type) {
                    if ("=>" == type) return cont(typeexpr);
                }
                function typeprop(type, value) {
                    return "variable" == type || "keyword" == cx.style ? (cx.marked = "property", cont(typeprop)) : "?" == value ? cont(typeprop) : ":" == type ? cont(typeexpr) : "[" == type ? cont(expression, maybetype, expect("]"), typeprop) : void 0;
                }
                function typearg(type) {
                    return "variable" == type ? cont(typearg) : ":" == type ? cont(typeexpr) : void 0;
                }
                function afterType(type, value) {
                    return "<" == value ? cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType) : "|" == value || "." == type ? cont(typeexpr) : "[" == type ? cont(expect("]"), afterType) : "extends" == value ? cont(typeexpr) : void 0;
                }
                function maybeTypeArgs(_, value) {
                    if ("<" == value) return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType);
                }
                function vardef() {
                    return pass(pattern, maybetype, maybeAssign, vardefCont);
                }
                function pattern(type, value) {
                    return "modifier" == type ? cont(pattern) : "variable" == type ? (register(value), 
                    cont()) : "spread" == type ? cont(pattern) : "[" == type ? contCommasep(pattern, "]") : "{" == type ? contCommasep(proppattern, "}") : void 0;
                }
                function proppattern(type, value) {
                    return "variable" != type || cx.stream.match(/^\s*:/, !1) ? ("variable" == type && (cx.marked = "property"), 
                    "spread" == type ? cont(pattern) : "}" == type ? pass() : cont(expect(":"), pattern, maybeAssign)) : (register(value), 
                    cont(maybeAssign));
                }
                function maybeAssign(_type, value) {
                    if ("=" == value) return cont(expressionNoComma);
                }
                function vardefCont(type) {
                    if ("," == type) return cont(vardef);
                }
                function maybeelse(type, value) {
                    if ("keyword b" == type && "else" == value) return cont(pushlex("form", "else"), statement, poplex);
                }
                function forspec(type) {
                    if ("(" == type) return cont(pushlex(")"), forspec1, expect(")"), poplex);
                }
                function forspec1(type) {
                    return "var" == type ? cont(vardef, expect(";"), forspec2) : ";" == type ? cont(forspec2) : "variable" == type ? cont(formaybeinof) : pass(expression, expect(";"), forspec2);
                }
                function formaybeinof(_type, value) {
                    return "in" == value || "of" == value ? (cx.marked = "keyword", cont(expression)) : cont(maybeoperatorComma, forspec2);
                }
                function forspec2(type, value) {
                    return ";" == type ? cont(forspec3) : "in" == value || "of" == value ? (cx.marked = "keyword", 
                    cont(expression)) : pass(expression, expect(";"), forspec3);
                }
                function forspec3(type) {
                    ")" != type && cont(expression);
                }
                function functiondef(type, value) {
                    return "*" == value ? (cx.marked = "keyword", cont(functiondef)) : "variable" == type ? (register(value), 
                    cont(functiondef)) : "(" == type ? cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, maybetype, statement, popcontext) : isTS && "<" == value ? cont(pushlex(">"), commasep(typeexpr, ">"), poplex, functiondef) : void 0;
                }
                function funarg(type, value) {
                    return "@" == value && cont(expression, funarg), "spread" == type || "modifier" == type ? cont(funarg) : pass(pattern, maybetype, maybeAssign);
                }
                function classExpression(type, value) {
                    // Class expressions may have an optional name.
                    // Class expressions may have an optional name.
                    return "variable" == type ? className(type, value) : classNameAfter(type, value);
                }
                function className(type, value) {
                    if ("variable" == type) return register(value), cont(classNameAfter);
                }
                function classNameAfter(type, value) {
                    return "<" == value ? cont(pushlex(">"), commasep(typeexpr, ">"), poplex, classNameAfter) : "extends" == value || "implements" == value || isTS && "," == type ? cont(isTS ? typeexpr : expression, classNameAfter) : "{" == type ? cont(pushlex("}"), classBody, poplex) : void 0;
                }
                function classBody(type, value) {
                    return "modifier" == type || "async" == type || "variable" == type && ("static" == value || "get" == value || "set" == value) && cx.stream.match(/^\s+[\w$\xa1-\uffff]/, !1) ? (cx.marked = "keyword", 
                    cont(classBody)) : "variable" == type || "keyword" == cx.style ? (cx.marked = "property", 
                    cont(isTS ? classfield : functiondef, classBody)) : "[" == type ? cont(expression, expect("]"), isTS ? classfield : functiondef, classBody) : "*" == value ? (cx.marked = "keyword", 
                    cont(classBody)) : ";" == type ? cont(classBody) : "}" == type ? cont() : "@" == value ? cont(expression, classBody) : void 0;
                }
                function classfield(type, value) {
                    return "?" == value ? cont(classfield) : ":" == type ? cont(typeexpr, maybeAssign) : "=" == value ? cont(expressionNoComma) : pass(functiondef);
                }
                function afterExport(type, value) {
                    return "*" == value ? (cx.marked = "keyword", cont(maybeFrom, expect(";"))) : "default" == value ? (cx.marked = "keyword", 
                    cont(expression, expect(";"))) : "{" == type ? cont(commasep(exportField, "}"), maybeFrom, expect(";")) : pass(statement);
                }
                function exportField(type, value) {
                    return "as" == value ? (cx.marked = "keyword", cont(expect("variable"))) : "variable" == type ? pass(expressionNoComma, exportField) : void 0;
                }
                function afterImport(type) {
                    return "string" == type ? cont() : pass(importSpec, maybeMoreImports, maybeFrom);
                }
                function importSpec(type, value) {
                    return "{" == type ? contCommasep(importSpec, "}") : ("variable" == type && register(value), 
                    "*" == value && (cx.marked = "keyword"), cont(maybeAs));
                }
                function maybeMoreImports(type) {
                    if ("," == type) return cont(importSpec, maybeMoreImports);
                }
                function maybeAs(_type, value) {
                    if ("as" == value) return cx.marked = "keyword", cont(importSpec);
                }
                function maybeFrom(_type, value) {
                    if ("from" == value) return cx.marked = "keyword", cont(expression);
                }
                function arrayLiteral(type) {
                    return "]" == type ? cont() : pass(commasep(expressionNoComma, "]"));
                }
                function isContinuedStatement(state, textAfter) {
                    return "operator" == state.lastType || "," == state.lastType || isOperatorChar.test(textAfter.charAt(0)) || /[,.]/.test(textAfter.charAt(0));
                }
                function expressionAllowed(stream, state, backUp) {
                    return state.tokenize == tokenBase && /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\[{}\(,;:]|=>)$/.test(state.lastType) || "quasi" == state.lastType && /\{\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0)));
                }
                var type, content, indentUnit = config.indentUnit, statementIndent = parserConfig.statementIndent, jsonldMode = parserConfig.jsonld, jsonMode = parserConfig.json || jsonldMode, isTS = parserConfig.typescript, wordRE = parserConfig.wordCharacters || /[\w$\xa1-\uffff]/, keywords = function() {
                    function kw(type) {
                        return {
                            type: type,
                            style: "keyword"
                        };
                    }
                    var A = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c"), D = kw("keyword d"), operator = kw("operator"), atom = {
                        type: "atom",
                        style: "atom"
                    }, jsKeywords = {
                        if: kw("if"),
                        while: A,
                        with: A,
                        else: B,
                        do: B,
                        try: B,
                        finally: B,
                        return: D,
                        break: D,
                        continue: D,
                        new: kw("new"),
                        delete: C,
                        void: C,
                        throw: C,
                        debugger: kw("debugger"),
                        var: kw("var"),
                        const: kw("var"),
                        let: kw("var"),
                        function: kw("function"),
                        catch: kw("catch"),
                        for: kw("for"),
                        switch: kw("switch"),
                        case: kw("case"),
                        default: kw("default"),
                        in: operator,
                        typeof: operator,
                        instanceof: operator,
                        true: atom,
                        false: atom,
                        null: atom,
                        undefined: atom,
                        NaN: atom,
                        Infinity: atom,
                        this: kw("this"),
                        class: kw("class"),
                        super: kw("atom"),
                        yield: C,
                        export: kw("export"),
                        import: kw("import"),
                        extends: C,
                        await: C
                    };
                    // Extend the 'normal' keywords with the TypeScript language extensions
                    if (isTS) {
                        var type = {
                            type: "variable",
                            style: "type"
                        }, tsKeywords = {
                            // object-like things
                            interface: kw("class"),
                            implements: C,
                            namespace: C,
                            module: kw("module"),
                            enum: kw("module"),
                            // scope modifiers
                            public: kw("modifier"),
                            private: kw("modifier"),
                            protected: kw("modifier"),
                            abstract: kw("modifier"),
                            readonly: kw("modifier"),
                            // types
                            string: type,
                            number: type,
                            boolean: type,
                            any: type
                        };
                        for (var attr in tsKeywords) jsKeywords[attr] = tsKeywords[attr];
                    }
                    return jsKeywords;
                }(), isOperatorChar = /[+\-*&%=<>!?|~^@]/, isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/, brackets = "([{}])", atomicTypes = {
                    atom: !0,
                    number: !0,
                    variable: !0,
                    string: !0,
                    regexp: !0,
                    this: !0,
                    "jsonld-keyword": !0
                }, cx = {
                    state: null,
                    column: null,
                    marked: null,
                    cc: null
                }, defaultVars = {
                    name: "this",
                    next: {
                        name: "arguments"
                    }
                };
                // Interface
                return poplex.lex = !0, {
                    startState: function(basecolumn) {
                        var state = {
                            tokenize: tokenBase,
                            lastType: "sof",
                            cc: [],
                            lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", !1),
                            localVars: parserConfig.localVars,
                            context: parserConfig.localVars && {
                                vars: parserConfig.localVars
                            },
                            indented: basecolumn || 0
                        };
                        return parserConfig.globalVars && "object" == typeof parserConfig.globalVars && (state.globalVars = parserConfig.globalVars), 
                        state;
                    },
                    token: function(stream, state) {
                        if (stream.sol() && (state.lexical.hasOwnProperty("align") || (state.lexical.align = !1), 
                        state.indented = stream.indentation(), findFatArrow(stream, state)), state.tokenize != tokenComment && stream.eatSpace()) return null;
                        var style = state.tokenize(stream, state);
                        return "comment" == type ? style : (state.lastType = "operator" != type || "++" != content && "--" != content ? type : "incdec", 
                        parseJS(state, style, type, content, stream));
                    },
                    indent: function(state, textAfter) {
                        if (state.tokenize == tokenComment) return CodeMirror.Pass;
                        if (state.tokenize != tokenBase) return 0;
                        var top, firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;
                        // Kludge to prevent 'maybelse' from blocking lexical scope pops
                        if (!/^\s*else\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {
                            var c = state.cc[i];
                            if (c == poplex) lexical = lexical.prev; else if (c != maybeelse) break;
                        }
                        for (;("stat" == lexical.type || "form" == lexical.type) && ("}" == firstChar || (top = state.cc[state.cc.length - 1]) && (top == maybeoperatorComma || top == maybeoperatorNoComma) && !/^[,\.=+\-*:?[\(]/.test(textAfter)); ) lexical = lexical.prev;
                        statementIndent && ")" == lexical.type && "stat" == lexical.prev.type && (lexical = lexical.prev);
                        var type = lexical.type, closing = firstChar == type;
                        return "vardef" == type ? lexical.indented + ("operator" == state.lastType || "," == state.lastType ? lexical.info + 1 : 0) : "form" == type && "{" == firstChar ? lexical.indented : "form" == type ? lexical.indented + indentUnit : "stat" == type ? lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0) : "switch" != lexical.info || closing || 0 == parserConfig.doubleIndentSwitch ? lexical.align ? lexical.column + (closing ? 0 : 1) : lexical.indented + (closing ? 0 : indentUnit) : lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
                    },
                    electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
                    blockCommentStart: jsonMode ? null : "/*",
                    blockCommentEnd: jsonMode ? null : "*/",
                    blockCommentContinue: jsonMode ? null : " * ",
                    lineComment: jsonMode ? null : "//",
                    fold: "brace",
                    closeBrackets: "()[]{}''\"\"``",
                    helperType: jsonMode ? "json" : "javascript",
                    jsonldMode: jsonldMode,
                    jsonMode: jsonMode,
                    expressionAllowed: expressionAllowed,
                    skipExpression: function(state) {
                        var top = state.cc[state.cc.length - 1];
                        top != expression && top != expressionNoComma || state.cc.pop();
                    }
                };
            }), CodeMirror.registerHelper("wordChars", "javascript", /[\w$]/), CodeMirror.defineMIME("text/javascript", "javascript"), 
            CodeMirror.defineMIME("text/ecmascript", "javascript"), CodeMirror.defineMIME("application/javascript", "javascript"), 
            CodeMirror.defineMIME("application/x-javascript", "javascript"), CodeMirror.defineMIME("application/ecmascript", "javascript"), 
            CodeMirror.defineMIME("application/json", {
                name: "javascript",
                json: !0
            }), CodeMirror.defineMIME("application/x-json", {
                name: "javascript",
                json: !0
            }), CodeMirror.defineMIME("application/ld+json", {
                name: "javascript",
                jsonld: !0
            }), CodeMirror.defineMIME("text/typescript", {
                name: "javascript",
                typescript: !0
            }), CodeMirror.defineMIME("application/typescript", {
                name: "javascript",
                typescript: !0
            });
        });
    }, /* 141 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _taggedTemplateLiteral2 = __webpack_require__(2), _taggedTemplateLiteral3 = _interopRequireDefault(_taggedTemplateLiteral2), _templateObject = (0, 
        _taggedTemplateLiteral3.default)([ "\n  height: 100%;\n  padding: 1rem;\n\n  ", "\n\n  @media (max-width: 600px) {\n    padding: 0.5rem;\n  }\n\n  h1 {\n    paddingRight: 9rem;\n  }\n" ], [ "\n  height: 100%;\n  padding: 1rem;\n\n  ", "\n\n  @media (max-width: 600px) {\n    padding: 0.5rem;\n  }\n\n  h1 {\n    paddingRight: 9rem;\n  }\n" ]), _styledComponents = __webpack_require__(129), _styledComponents2 = _interopRequireDefault(_styledComponents), _presenterSlideStyle = __webpack_require__(142), _presenterSlideStyle2 = _interopRequireDefault(_presenterSlideStyle);
        exports.default = _styledComponents2.default.div(_templateObject, _presenterSlideStyle2.default);
    }, /* 142 */
    /***/
    function(module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = function(props) {
            return props.theme.isPresenterMode && "\n  outline: 0.25rem solid #37F;\n  outline-offset: -0.25rem;\n\n  &::before {\n    content: 'presenter';\n    position: fixed;\n    top: 0;\n    left: 0;\n    background-color: #36F;\n    padding: 0.25rem;\n    color: #fff;\n    font-size: 0.65rem;\n  }\n";
        };
    }, /* 143 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _extends2 = __webpack_require__(68), _extends3 = _interopRequireDefault(_extends2), _getPrototypeOf = __webpack_require__(75), _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf), _classCallCheck2 = __webpack_require__(78), _classCallCheck3 = _interopRequireDefault(_classCallCheck2), _createClass2 = __webpack_require__(79), _createClass3 = _interopRequireDefault(_createClass2), _possibleConstructorReturn2 = __webpack_require__(83), _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2), _inherits2 = __webpack_require__(100), _inherits3 = _interopRequireDefault(_inherits2), _taggedTemplateLiteral2 = __webpack_require__(2), _taggedTemplateLiteral3 = _interopRequireDefault(_taggedTemplateLiteral2), _templateObject = (0, 
        _taggedTemplateLiteral3.default)([ "\n  position: absolute;\n  top: 1rem;\n  right: 7rem;\n\n  @media (max-width: 600px) {\n    top: 0.5rem;\n    right: 6.5rem;\n  }\n" ], [ "\n  position: absolute;\n  top: 1rem;\n  right: 7rem;\n\n  @media (max-width: 600px) {\n    top: 0.5rem;\n    right: 6.5rem;\n  }\n" ]), _templateObject2 = (0, 
        _taggedTemplateLiteral3.default)([ "\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  background-color: rgba(0, 0, 0, .5);\n" ], [ "\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  background-color: rgba(0, 0, 0, .5);\n" ]), _templateObject3 = (0, 
        _taggedTemplateLiteral3.default)([ "\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  background-color: rgba(255, 255, 255, .1);\n  padding: 1rem;\n  border-radius: 0.5rem;\n  z-index: 2;\n\n  .VirtualizedSelect {\n    width: 250px;\n    max-width: 100%;\n  }\n" ], [ "\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  background-color: rgba(255, 255, 255, .1);\n  padding: 1rem;\n  border-radius: 0.5rem;\n  z-index: 2;\n\n  .VirtualizedSelect {\n    width: 250px;\n    max-width: 100%;\n  }\n" ]), _templateObject4 = (0, 
        _taggedTemplateLiteral3.default)([ "\n  white-space: pre;\n  overflow: hidden;\n  text-overflow: ellipsis;\n" ], [ "\n  white-space: pre;\n  overflow: hidden;\n  text-overflow: ellipsis;\n" ]), _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _propTypes = __webpack_require__(109), _reactVirtualizedSelect = (_interopRequireDefault(_propTypes), 
        __webpack_require__(144)), _reactVirtualizedSelect2 = _interopRequireDefault(_reactVirtualizedSelect), _reactDom = __webpack_require__(120), _styledComponents = __webpack_require__(129), _styledComponents2 = _interopRequireDefault(_styledComponents), _IconButton = __webpack_require__(182), _IconButton2 = _interopRequireDefault(_IconButton), _Icons = __webpack_require__(183), _PropTypes = __webpack_require__(185), _reactSelectStyles = __webpack_require__(186), _reactSelectStyles2 = _interopRequireDefault(_reactSelectStyles), ButtonGroup = _styledComponents2.default.div(_templateObject), Overlay = _styledComponents2.default.div(_templateObject2), SelectWrapper = _styledComponents2.default.div(_templateObject3), Row = _styledComponents2.default.div(_templateObject4), NavigateToSlide = function(_Component) {
            function NavigateToSlide(props, context) {
                (0, _classCallCheck3.default)(this, NavigateToSlide);
                var _this = (0, _possibleConstructorReturn3.default)(this, (NavigateToSlide.__proto__ || (0, 
                _getPrototypeOf2.default)(NavigateToSlide)).call(this, props, context));
                return _this.state = {
                    active: !1
                }, _this._onChange = _this._onChange.bind(_this), _this._onClick = _this._onClick.bind(_this), 
                _this._onKeyDown = _this._onKeyDown.bind(_this), _this._optionRenderer = _this._optionRenderer.bind(_this), 
                _this;
            }
            return (0, _inherits3.default)(NavigateToSlide, _Component), (0, _createClass3.default)(NavigateToSlide, [ {
                key: "componentDidMount",
                value: function() {
                    document.body.addEventListener("click", this._onClick);
                }
            }, {
                key: "componentWillUnmount",
                value: function() {
                    document.body.removeEventListener("click", this._onClick);
                }
            }, {
                key: "render",
                value: function() {
                    var _this2 = this, slideIndex = this.context.slideIndex, options = this.props.options, active = this.state.active;
                    return active ? _react2.default.createElement(_react.Fragment, null, _react2.default.createElement(_reactSelectStyles2.default, null), _react2.default.createElement(Overlay, null, _react2.default.createElement(SelectWrapper, null, _react2.default.createElement(_reactVirtualizedSelect2.default, {
                        autofocus: !0,
                        className: "VirtualizedSelect",
                        clearable: !1,
                        options: options,
                        onChange: this._onChange,
                        onInputKeyDown: this._onKeyDown,
                        optionHeight: 35,
                        optionRenderer: this._optionRenderer,
                        ref: function(_ref) {
                            _this2._select = _ref;
                        },
                        value: slideIndex
                    })))) : options.length ? _react2.default.createElement(ButtonGroup, null, _react2.default.createElement(_IconButton2.default, {
                        onClick: function() {
                            return _this2.setState({
                                active: !0
                            });
                        }
                    }, _react2.default.createElement(_Icons.IconMore, null))) : null;
                }
            }, {
                key: "_onChange",
                value: function(option) {
                    var slideIndex = option.value, presentation = this.context.presentation;
                    this.setState({
                        active: !1
                    }), presentation.goToSlide({
                        slideIndex: slideIndex
                    });
                }
            }, {
                key: "_onClick",
                value: function(event) {
                    var active = this.state.active;
                    if (active) {
                        var select = (0, _reactDom.findDOMNode)(this._select);
                        select === event.target || select.contains(event.target) || this.setState({
                            active: !1
                        });
                    }
                }
            }, {
                key: "_onKeyDown",
                value: function(event) {
                    switch (event.key) {
                      case "Escape":
                        this.setState({
                            active: !1
                        });
                    }
                }
            }, {
                key: "_optionRenderer",
                value: function(_ref2) {
                    var focusedOption = _ref2.focusedOption, focusOption = _ref2.focusOption, key = _ref2.key, labelKey = _ref2.labelKey, option = _ref2.option, selectValue = _ref2.selectValue, style = _ref2.style, classNames = [ "VirtualizedSelectOption" ];
                    option === focusedOption && classNames.push("VirtualizedSelectFocusedOption"), option.disabled && classNames.push("VirtualizedSelectOptionHeader");
                    var text = option[labelKey], events = option.disabled ? {} : {
                        onClick: function() {
                            return selectValue(option);
                        },
                        onMouseOver: function() {
                            return focusOption(option);
                        }
                    };
                    return _react2.default.createElement("div", (0, _extends3.default)({
                        className: classNames.join(" "),
                        key: key,
                        style: style,
                        title: text
                    }, events), _react2.default.createElement(Row, null, text));
                }
            } ]), NavigateToSlide;
        }(_react.Component);
        NavigateToSlide.contextTypes = {
            presentation: _PropTypes.presentationContext.isRequired
        }, exports.default = NavigateToSlide;
    }, /* 144 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = void 0;
        var _VirtualizedSelect = __webpack_require__(145), _VirtualizedSelect2 = _interopRequireDefault(_VirtualizedSelect);
        exports.default = _VirtualizedSelect2.default;
    }, /* 145 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = void 0;
        var _VirtualizedSelect = __webpack_require__(146), _VirtualizedSelect2 = _interopRequireDefault(_VirtualizedSelect);
        exports.default = _VirtualizedSelect2.default;
    }, /* 146 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        }, _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }(), _propTypes = __webpack_require__(109), _propTypes2 = _interopRequireDefault(_propTypes), _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _reactSelect = __webpack_require__(147), _reactSelect2 = _interopRequireDefault(_reactSelect), _AutoSizer = __webpack_require__(160), _AutoSizer2 = _interopRequireDefault(_AutoSizer), _List = __webpack_require__(164), _List2 = _interopRequireDefault(_List), VirtualizedSelect = function(_Component) {
            function VirtualizedSelect(props, context) {
                _classCallCheck(this, VirtualizedSelect);
                var _this = _possibleConstructorReturn(this, (VirtualizedSelect.__proto__ || Object.getPrototypeOf(VirtualizedSelect)).call(this, props, context));
                return _this._renderMenu = _this._renderMenu.bind(_this), _this._optionRenderer = _this._optionRenderer.bind(_this), 
                _this._setListRef = _this._setListRef.bind(_this), _this._setSelectRef = _this._setSelectRef.bind(_this), 
                _this;
            }
            /** See List#recomputeRowHeights */
            return _inherits(VirtualizedSelect, _Component), _createClass(VirtualizedSelect, [ {
                key: "recomputeOptionHeights",
                value: function() {
                    var index = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                    this._listRef && this._listRef.recomputeRowHeights(index);
                }
            }, {
                key: "focus",
                value: function() {
                    if (this._selectRef) return this._selectRef.focus();
                }
            }, {
                key: "render",
                value: function() {
                    var SelectComponent = this._getSelectComponent();
                    return _react2.default.createElement(SelectComponent, _extends({}, this.props, {
                        ref: this._setSelectRef,
                        menuRenderer: this._renderMenu,
                        menuStyle: {
                            overflow: "hidden"
                        }
                    }));
                }
            }, {
                key: "_renderMenu",
                value: function(_ref) {
                    // react-select 1.0.0-rc2 passes duplicate `onSelect` and `selectValue` props to `menuRenderer`
                    // The `Creatable` HOC only overrides `onSelect` which breaks an edge-case
                    // In order to support creating items via clicking on the placeholder option,
                    // We need to ensure that the specified `onSelect` handle is the one we use.
                    // See issue #33
                    function wrappedRowRenderer(_ref2) {
                        var index = _ref2.index, key = _ref2.key, style = _ref2.style, option = options[index];
                        return innerRowRenderer({
                            focusedOption: focusedOption,
                            focusedOptionIndex: focusedOptionIndex,
                            focusOption: focusOption,
                            key: key,
                            labelKey: labelKey,
                            onSelect: onSelect,
                            option: option,
                            optionIndex: index,
                            options: options,
                            selectValue: onSelect,
                            style: style,
                            valueArray: valueArray
                        });
                    }
                    var _this2 = this, focusedOption = _ref.focusedOption, focusOption = _ref.focusOption, labelKey = _ref.labelKey, onSelect = _ref.onSelect, options = _ref.options, valueArray = (_ref.selectValue, 
                    _ref.valueArray), _props = this.props, listProps = _props.listProps, optionRenderer = _props.optionRenderer, focusedOptionIndex = options.indexOf(focusedOption), height = this._calculateListHeight({
                        options: options
                    }), innerRowRenderer = optionRenderer || this._optionRenderer;
                    return _react2.default.createElement(_AutoSizer2.default, {
                        disableHeight: !0
                    }, function(_ref3) {
                        var width = _ref3.width;
                        return _react2.default.createElement(_List2.default, _extends({
                            className: "VirtualSelectGrid",
                            height: height,
                            ref: _this2._setListRef,
                            rowCount: options.length,
                            rowHeight: function(_ref4) {
                                var index = _ref4.index;
                                return _this2._getOptionHeight({
                                    option: options[index]
                                });
                            },
                            rowRenderer: wrappedRowRenderer,
                            scrollToIndex: focusedOptionIndex,
                            width: width
                        }, listProps));
                    });
                }
            }, {
                key: "_calculateListHeight",
                value: function(_ref5) {
                    for (var options = _ref5.options, maxHeight = this.props.maxHeight, height = 0, optionIndex = 0; optionIndex < options.length; optionIndex++) {
                        var option = options[optionIndex];
                        if (height += this._getOptionHeight({
                            option: option
                        }), height > maxHeight) return maxHeight;
                    }
                    return height;
                }
            }, {
                key: "_getOptionHeight",
                value: function(_ref6) {
                    var option = _ref6.option, optionHeight = this.props.optionHeight;
                    return optionHeight instanceof Function ? optionHeight({
                        option: option
                    }) : optionHeight;
                }
            }, {
                key: "_getSelectComponent",
                value: function() {
                    var _props2 = this.props, async = _props2.async, selectComponent = _props2.selectComponent;
                    return selectComponent ? selectComponent : async ? _reactSelect2.default.Async : _reactSelect2.default;
                }
            }, {
                key: "_optionRenderer",
                value: function(_ref7) {
                    var focusedOption = _ref7.focusedOption, focusOption = _ref7.focusOption, key = _ref7.key, labelKey = _ref7.labelKey, option = _ref7.option, selectValue = _ref7.selectValue, style = _ref7.style, valueArray = _ref7.valueArray, className = [ "VirtualizedSelectOption" ];
                    option === focusedOption && className.push("VirtualizedSelectFocusedOption"), option.disabled && className.push("VirtualizedSelectDisabledOption"), 
                    valueArray && valueArray.indexOf(option) >= 0 && className.push("VirtualizedSelectSelectedOption"), 
                    option.className && className.push(option.className);
                    var events = option.disabled ? {} : {
                        onClick: function() {
                            return selectValue(option);
                        },
                        onMouseOver: function() {
                            return focusOption(option);
                        }
                    };
                    return _react2.default.createElement("div", _extends({
                        className: className.join(" "),
                        key: key,
                        style: style,
                        title: option.title
                    }, events), option[labelKey]);
                }
            }, {
                key: "_setListRef",
                value: function(ref) {
                    this._listRef = ref;
                }
            }, {
                key: "_setSelectRef",
                value: function(ref) {
                    this._selectRef = ref;
                }
            } ]), VirtualizedSelect;
        }(_react.Component);
        VirtualizedSelect.propTypes = {
            async: _propTypes2.default.bool,
            listProps: _propTypes2.default.object,
            maxHeight: _propTypes2.default.number.isRequired,
            optionHeight: _propTypes2.default.oneOfType([ _propTypes2.default.number, _propTypes2.default.func ]).isRequired,
            optionRenderer: _propTypes2.default.func,
            selectComponent: _propTypes2.default.func
        }, VirtualizedSelect.defaultProps = {
            async: !1,
            maxHeight: 200,
            optionHeight: 35
        }, exports.default = VirtualizedSelect;
    }, /* 147 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.Value = exports.Creatable = exports.AsyncCreatable = exports.Async = void 0;
        var _Select = __webpack_require__(148), _Select2 = _interopRequireDefault(_Select), _Async = __webpack_require__(157), _Async2 = _interopRequireDefault(_Async), _AsyncCreatable = __webpack_require__(158), _AsyncCreatable2 = _interopRequireDefault(_AsyncCreatable), _Creatable = __webpack_require__(159), _Creatable2 = _interopRequireDefault(_Creatable), _Value = __webpack_require__(156), _Value2 = _interopRequireDefault(_Value);
        _Select2.default.Async = _Async2.default, _Select2.default.AsyncCreatable = _AsyncCreatable2.default, 
        _Select2.default.Creatable = _Creatable2.default, _Select2.default.Value = _Value2.default, 
        exports.default = _Select2.default, exports.Async = _Async2.default, exports.AsyncCreatable = _AsyncCreatable2.default, 
        exports.Creatable = _Creatable2.default, exports.Value = _Value2.default;
    }, /* 148 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _objectWithoutProperties(obj, keys) {
            var target = {};
            for (var i in obj) keys.indexOf(i) >= 0 || Object.prototype.hasOwnProperty.call(obj, i) && (target[i] = obj[i]);
            return target;
        }
        function _defineProperty(obj, key, value) {
            return key in obj ? Object.defineProperty(obj, key, {
                value: value,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : obj[key] = value, obj;
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        }, _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
            return typeof obj;
        } : function(obj) {
            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        }, _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }(), _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _propTypes = __webpack_require__(109), _propTypes2 = _interopRequireDefault(_propTypes), _reactDom = __webpack_require__(120), _reactDom2 = _interopRequireDefault(_reactDom), _reactInputAutosize = __webpack_require__(149), _reactInputAutosize2 = _interopRequireDefault(_reactInputAutosize), _classnames = __webpack_require__(121), _classnames2 = _interopRequireDefault(_classnames), _defaultArrowRenderer = __webpack_require__(150), _defaultArrowRenderer2 = _interopRequireDefault(_defaultArrowRenderer), _defaultFilterOptions = __webpack_require__(151), _defaultFilterOptions2 = _interopRequireDefault(_defaultFilterOptions), _defaultMenuRenderer = __webpack_require__(153), _defaultMenuRenderer2 = _interopRequireDefault(_defaultMenuRenderer), _defaultClearRenderer = __webpack_require__(154), _defaultClearRenderer2 = _interopRequireDefault(_defaultClearRenderer), _Option = __webpack_require__(155), _Option2 = _interopRequireDefault(_Option), _Value = __webpack_require__(156), _Value2 = _interopRequireDefault(_Value), stringifyValue = function(value) {
            return "string" == typeof value ? value : null !== value && JSON.stringify(value) || "";
        }, stringOrNode = _propTypes2.default.oneOfType([ _propTypes2.default.string, _propTypes2.default.node ]), instanceId = 1, Select = function(_React$Component) {
            function Select(props) {
                _classCallCheck(this, Select);
                var _this = _possibleConstructorReturn(this, (Select.__proto__ || Object.getPrototypeOf(Select)).call(this, props));
                return [ "clearValue", "focusOption", "handleInputBlur", "handleInputChange", "handleInputFocus", "handleInputValueChange", "handleKeyDown", "handleMenuScroll", "handleMouseDown", "handleMouseDownOnArrow", "handleMouseDownOnMenu", "handleRequired", "handleTouchOutside", "handleTouchMove", "handleTouchStart", "handleTouchEnd", "handleTouchEndClearValue", "handleValueClick", "getOptionLabel", "onOptionRef", "removeValue", "selectValue" ].forEach(function(fn) {
                    return _this[fn] = _this[fn].bind(_this);
                }), _this.state = {
                    inputValue: "",
                    isFocused: !1,
                    isOpen: !1,
                    isPseudoFocused: !1,
                    required: !1
                }, _this;
            }
            return _inherits(Select, _React$Component), _createClass(Select, [ {
                key: "componentWillMount",
                value: function() {
                    this._instancePrefix = "react-select-" + (this.props.instanceId || ++instanceId) + "-";
                    var valueArray = this.getValueArray(this.props.value);
                    this.props.required && this.setState({
                        required: this.handleRequired(valueArray[0], this.props.multi)
                    });
                }
            }, {
                key: "componentDidMount",
                value: function() {
                    this.props.autofocus && this.focus();
                }
            }, {
                key: "componentWillReceiveProps",
                value: function(nextProps) {
                    var valueArray = this.getValueArray(nextProps.value, nextProps);
                    nextProps.required ? this.setState({
                        required: this.handleRequired(valueArray[0], nextProps.multi)
                    }) : this.props.required && // Used to be required but it's not any more
                    this.setState({
                        required: !1
                    });
                }
            }, {
                key: "componentWillUpdate",
                value: function(nextProps, nextState) {
                    if (nextState.isOpen !== this.state.isOpen) {
                        this.toggleTouchOutsideEvent(nextState.isOpen);
                        var handler = nextState.isOpen ? nextProps.onOpen : nextProps.onClose;
                        handler && handler();
                    }
                }
            }, {
                key: "componentDidUpdate",
                value: function(prevProps, prevState) {
                    // focus to the selected option
                    if (this.menu && this.focused && this.state.isOpen && !this.hasScrolledToOption) {
                        var focusedOptionNode = _reactDom2.default.findDOMNode(this.focused), menuNode = _reactDom2.default.findDOMNode(this.menu);
                        menuNode.scrollTop = focusedOptionNode.offsetTop, this.hasScrolledToOption = !0;
                    } else this.state.isOpen || (this.hasScrolledToOption = !1);
                    if (this._scrollToFocusedOptionOnUpdate && this.focused && this.menu) {
                        this._scrollToFocusedOptionOnUpdate = !1;
                        var focusedDOM = _reactDom2.default.findDOMNode(this.focused), menuDOM = _reactDom2.default.findDOMNode(this.menu), focusedRect = focusedDOM.getBoundingClientRect(), menuRect = menuDOM.getBoundingClientRect();
                        focusedRect.bottom > menuRect.bottom ? menuDOM.scrollTop = focusedDOM.offsetTop + focusedDOM.clientHeight - menuDOM.offsetHeight : focusedRect.top < menuRect.top && (menuDOM.scrollTop = focusedDOM.offsetTop);
                    }
                    if (this.props.scrollMenuIntoView && this.menuContainer) {
                        var menuContainerRect = this.menuContainer.getBoundingClientRect();
                        window.innerHeight < menuContainerRect.bottom + this.props.menuBuffer && window.scrollBy(0, menuContainerRect.bottom + this.props.menuBuffer - window.innerHeight);
                    }
                    prevProps.disabled !== this.props.disabled && (this.setState({
                        isFocused: !1
                    }), // eslint-disable-line react/no-did-update-set-state
                    this.closeMenu());
                }
            }, {
                key: "componentWillUnmount",
                value: function() {
                    !document.removeEventListener && document.detachEvent ? document.detachEvent("ontouchstart", this.handleTouchOutside) : document.removeEventListener("touchstart", this.handleTouchOutside);
                }
            }, {
                key: "toggleTouchOutsideEvent",
                value: function(enabled) {
                    enabled ? !document.addEventListener && document.attachEvent ? document.attachEvent("ontouchstart", this.handleTouchOutside) : document.addEventListener("touchstart", this.handleTouchOutside) : !document.removeEventListener && document.detachEvent ? document.detachEvent("ontouchstart", this.handleTouchOutside) : document.removeEventListener("touchstart", this.handleTouchOutside);
                }
            }, {
                key: "handleTouchOutside",
                value: function(event) {
                    // handle touch outside on ios to dismiss menu
                    this.wrapper && !this.wrapper.contains(event.target) && this.closeMenu();
                }
            }, {
                key: "focus",
                value: function() {
                    this.input && this.input.focus();
                }
            }, {
                key: "blurInput",
                value: function() {
                    this.input && this.input.blur();
                }
            }, {
                key: "handleTouchMove",
                value: function(event) {
                    // Set a flag that the view is being dragged
                    this.dragging = !0;
                }
            }, {
                key: "handleTouchStart",
                value: function(event) {
                    // Set a flag that the view is not being dragged
                    this.dragging = !1;
                }
            }, {
                key: "handleTouchEnd",
                value: function(event) {
                    // Check if the view is being dragged, In this case
                    // we don't want to fire the click event (because the user only wants to scroll)
                    this.dragging || // Fire the mouse events
                    this.handleMouseDown(event);
                }
            }, {
                key: "handleTouchEndClearValue",
                value: function(event) {
                    // Check if the view is being dragged, In this case
                    // we don't want to fire the click event (because the user only wants to scroll)
                    this.dragging || // Clear the value
                    this.clearValue(event);
                }
            }, {
                key: "handleMouseDown",
                value: function(event) {
                    // if the event was triggered by a mousedown and not the primary
                    // button, or if the component is disabled, ignore it.
                    if (!(this.props.disabled || "mousedown" === event.type && 0 !== event.button) && "INPUT" !== event.target.tagName) {
                        // for the non-searchable select, toggle the menu
                        if (// prevent default event handlers
                        event.stopPropagation(), event.preventDefault(), !this.props.searchable) // TODO: This code means that if a select is searchable, onClick the options menu will not appear, only on subsequent click will it open.
                        return this.focus(), this.setState({
                            isOpen: !this.state.isOpen
                        });
                        if (this.state.isFocused) {
                            // On iOS, we can get into a state where we think the input is focused but it isn't really,
                            // since iOS ignores programmatic calls to input.focus() that weren't triggered by a click event.
                            // Call focus() again here to be safe.
                            this.focus();
                            var input = this.input;
                            "function" == typeof input.getInput && (// Get the actual DOM input if the ref is an <AutosizeInput /> component
                            input = input.getInput()), // clears the value so that the cursor will be at the end of input when the component re-renders
                            input.value = "", // if the input is focused, ensure the menu is open
                            this.setState({
                                isOpen: !0,
                                isPseudoFocused: !1
                            });
                        } else // otherwise, focus the input and open the menu
                        this._openAfterFocus = this.props.openOnClick, this.focus();
                    }
                }
            }, {
                key: "handleMouseDownOnArrow",
                value: function(event) {
                    // if the event was triggered by a mousedown and not the primary
                    // button, or if the component is disabled, ignore it.
                    this.props.disabled || "mousedown" === event.type && 0 !== event.button || // If the menu isn't open, let the event bubble to the main handleMouseDown
                    this.state.isOpen && (// prevent default event handlers
                    event.stopPropagation(), event.preventDefault(), // close the menu
                    this.closeMenu());
                }
            }, {
                key: "handleMouseDownOnMenu",
                value: function(event) {
                    // if the event was triggered by a mousedown and not the primary
                    // button, or if the component is disabled, ignore it.
                    this.props.disabled || "mousedown" === event.type && 0 !== event.button || (event.stopPropagation(), 
                    event.preventDefault(), this._openAfterFocus = !0, this.focus());
                }
            }, {
                key: "closeMenu",
                value: function() {
                    this.props.onCloseResetsInput ? this.setState({
                        isOpen: !1,
                        isPseudoFocused: this.state.isFocused && !this.props.multi,
                        inputValue: this.handleInputValueChange("")
                    }) : this.setState({
                        isOpen: !1,
                        isPseudoFocused: this.state.isFocused && !this.props.multi
                    }), this.hasScrolledToOption = !1;
                }
            }, {
                key: "handleInputFocus",
                value: function(event) {
                    if (!this.props.disabled) {
                        var isOpen = this.state.isOpen || this._openAfterFocus || this.props.openOnFocus;
                        this.props.onFocus && this.props.onFocus(event), this.setState({
                            isFocused: !0,
                            isOpen: isOpen
                        }), this._openAfterFocus = !1;
                    }
                }
            }, {
                key: "handleInputBlur",
                value: function(event) {
                    // The check for menu.contains(activeElement) is necessary to prevent IE11's scrollbar from closing the menu in certain contexts.
                    if (this.menu && (this.menu === document.activeElement || this.menu.contains(document.activeElement))) return void this.focus();
                    this.props.onBlur && this.props.onBlur(event);
                    var onBlurredState = {
                        isFocused: !1,
                        isOpen: !1,
                        isPseudoFocused: !1
                    };
                    this.props.onBlurResetsInput && (onBlurredState.inputValue = this.handleInputValueChange("")), 
                    this.setState(onBlurredState);
                }
            }, {
                key: "handleInputChange",
                value: function(event) {
                    var newInputValue = event.target.value;
                    this.state.inputValue !== event.target.value && (newInputValue = this.handleInputValueChange(newInputValue)), 
                    this.setState({
                        isOpen: !0,
                        isPseudoFocused: !1,
                        inputValue: newInputValue
                    });
                }
            }, {
                key: "handleInputValueChange",
                value: function(newValue) {
                    if (this.props.onInputChange) {
                        var nextState = this.props.onInputChange(newValue);
                        // Note: != used deliberately here to catch undefined and null
                        null != nextState && "object" !== ("undefined" == typeof nextState ? "undefined" : _typeof(nextState)) && (newValue = "" + nextState);
                    }
                    return newValue;
                }
            }, {
                key: "handleKeyDown",
                value: function(event) {
                    if (!(this.props.disabled || "function" == typeof this.props.onInputKeyDown && (this.props.onInputKeyDown(event), 
                    event.defaultPrevented))) {
                        switch (event.keyCode) {
                          case 8:
                            // backspace
                            return void (!this.state.inputValue && this.props.backspaceRemoves && (event.preventDefault(), 
                            this.popValue()));

                          case 9:
                            // tab
                            if (event.shiftKey || !this.state.isOpen || !this.props.tabSelectsValue) return;
                            return void this.selectFocusedOption();

                          case 13:
                            // enter
                            if (!this.state.isOpen) return;
                            event.stopPropagation(), this.selectFocusedOption();
                            break;

                          case 27:
                            // escape
                            this.state.isOpen ? (this.closeMenu(), event.stopPropagation()) : this.props.clearable && this.props.escapeClearsValue && (this.clearValue(event), 
                            event.stopPropagation());
                            break;

                          case 38:
                            // up
                            this.focusPreviousOption();
                            break;

                          case 40:
                            // down
                            this.focusNextOption();
                            break;

                          case 33:
                            // page up
                            this.focusPageUpOption();
                            break;

                          case 34:
                            // page down
                            this.focusPageDownOption();
                            break;

                          case 35:
                            // end key
                            if (event.shiftKey) return;
                            this.focusEndOption();
                            break;

                          case 36:
                            // home key
                            if (event.shiftKey) return;
                            this.focusStartOption();
                            break;

                          case 46:
                            // backspace
                            return void (!this.state.inputValue && this.props.deleteRemoves && (event.preventDefault(), 
                            this.popValue()));

                          default:
                            return;
                        }
                        event.preventDefault();
                    }
                }
            }, {
                key: "handleValueClick",
                value: function(option, event) {
                    this.props.onValueClick && this.props.onValueClick(option, event);
                }
            }, {
                key: "handleMenuScroll",
                value: function(event) {
                    if (this.props.onMenuScrollToBottom) {
                        var target = event.target;
                        target.scrollHeight > target.offsetHeight && target.scrollHeight - target.offsetHeight - target.scrollTop <= 0 && this.props.onMenuScrollToBottom();
                    }
                }
            }, {
                key: "handleRequired",
                value: function(value, multi) {
                    return !value || (multi ? 0 === value.length : 0 === Object.keys(value).length);
                }
            }, {
                key: "getOptionLabel",
                value: function(op) {
                    return op[this.props.labelKey];
                }
            }, {
                key: "getValueArray",
                value: function(value, nextProps) {
                    var _this2 = this, props = "object" === ("undefined" == typeof nextProps ? "undefined" : _typeof(nextProps)) ? nextProps : this.props;
                    if (props.multi) {
                        if ("string" == typeof value && (value = value.split(props.delimiter)), !Array.isArray(value)) {
                            if (null === value || void 0 === value) return [];
                            value = [ value ];
                        }
                        return value.map(function(value) {
                            return _this2.expandValue(value, props);
                        }).filter(function(i) {
                            return i;
                        });
                    }
                    var expandedValue = this.expandValue(value, props);
                    return expandedValue ? [ expandedValue ] : [];
                }
            }, {
                key: "expandValue",
                value: function(value, props) {
                    var valueType = "undefined" == typeof value ? "undefined" : _typeof(value);
                    if ("string" !== valueType && "number" !== valueType && "boolean" !== valueType) return value;
                    var options = props.options, valueKey = props.valueKey;
                    if (options) for (var i = 0; i < options.length; i++) if (options[i][valueKey] === value) return options[i];
                }
            }, {
                key: "setValue",
                value: function(value) {
                    var _this3 = this;
                    if (this.props.autoBlur && this.blurInput(), this.props.required) {
                        var required = this.handleRequired(value, this.props.multi);
                        this.setState({
                            required: required
                        });
                    }
                    this.props.onChange && (this.props.simpleValue && value && (value = this.props.multi ? value.map(function(i) {
                        return i[_this3.props.valueKey];
                    }).join(this.props.delimiter) : value[this.props.valueKey]), this.props.onChange(value));
                }
            }, {
                key: "selectValue",
                value: function(value) {
                    var _this4 = this;
                    if (// NOTE: we actually add/set the value in a callback to make sure the
                    // input value is empty to avoid styling issues in Chrome
                    this.props.closeOnSelect && (this.hasScrolledToOption = !1), this.props.multi) {
                        var updatedValue = this.props.onSelectResetsInput ? "" : this.state.inputValue;
                        this.setState({
                            focusedIndex: null,
                            inputValue: this.handleInputValueChange(updatedValue),
                            isOpen: !this.props.closeOnSelect
                        }, function() {
                            _this4.addValue(value);
                        });
                    } else this.setState({
                        inputValue: this.handleInputValueChange(""),
                        isOpen: !this.props.closeOnSelect,
                        isPseudoFocused: this.state.isFocused
                    }, function() {
                        _this4.setValue(value);
                    });
                }
            }, {
                key: "addValue",
                value: function(value) {
                    var valueArray = this.getValueArray(this.props.value), visibleOptions = this._visibleOptions.filter(function(val) {
                        return !val.disabled;
                    }), lastValueIndex = visibleOptions.indexOf(value);
                    this.setValue(valueArray.concat(value)), visibleOptions.length - 1 === lastValueIndex ? // the last option was selected; focus the second-last one
                    this.focusOption(visibleOptions[lastValueIndex - 1]) : visibleOptions.length > lastValueIndex && // focus the option below the selected one
                    this.focusOption(visibleOptions[lastValueIndex + 1]);
                }
            }, {
                key: "popValue",
                value: function() {
                    var valueArray = this.getValueArray(this.props.value);
                    valueArray.length && valueArray[valueArray.length - 1].clearableValue !== !1 && this.setValue(this.props.multi ? valueArray.slice(0, valueArray.length - 1) : null);
                }
            }, {
                key: "removeValue",
                value: function(value) {
                    var valueArray = this.getValueArray(this.props.value);
                    this.setValue(valueArray.filter(function(i) {
                        return i !== value;
                    })), this.focus();
                }
            }, {
                key: "clearValue",
                value: function(event) {
                    // if the event was triggered by a mousedown and not the primary
                    // button, ignore it.
                    event && "mousedown" === event.type && 0 !== event.button || (event.stopPropagation(), 
                    event.preventDefault(), this.setValue(this.getResetValue()), this.setState({
                        isOpen: !1,
                        inputValue: this.handleInputValueChange("")
                    }, this.focus));
                }
            }, {
                key: "getResetValue",
                value: function() {
                    return void 0 !== this.props.resetValue ? this.props.resetValue : this.props.multi ? [] : null;
                }
            }, {
                key: "focusOption",
                value: function(option) {
                    this.setState({
                        focusedOption: option
                    });
                }
            }, {
                key: "focusNextOption",
                value: function() {
                    this.focusAdjacentOption("next");
                }
            }, {
                key: "focusPreviousOption",
                value: function() {
                    this.focusAdjacentOption("previous");
                }
            }, {
                key: "focusPageUpOption",
                value: function() {
                    this.focusAdjacentOption("page_up");
                }
            }, {
                key: "focusPageDownOption",
                value: function() {
                    this.focusAdjacentOption("page_down");
                }
            }, {
                key: "focusStartOption",
                value: function() {
                    this.focusAdjacentOption("start");
                }
            }, {
                key: "focusEndOption",
                value: function() {
                    this.focusAdjacentOption("end");
                }
            }, {
                key: "focusAdjacentOption",
                value: function(dir) {
                    var options = this._visibleOptions.map(function(option, index) {
                        return {
                            option: option,
                            index: index
                        };
                    }).filter(function(option) {
                        return !option.option.disabled;
                    });
                    if (this._scrollToFocusedOptionOnUpdate = !0, !this.state.isOpen) return void this.setState({
                        isOpen: !0,
                        inputValue: "",
                        focusedOption: this._focusedOption || (options.length ? options["next" === dir ? 0 : options.length - 1].option : null)
                    });
                    if (options.length) {
                        for (var focusedIndex = -1, i = 0; i < options.length; i++) if (this._focusedOption === options[i].option) {
                            focusedIndex = i;
                            break;
                        }
                        if ("next" === dir && focusedIndex !== -1) focusedIndex = (focusedIndex + 1) % options.length; else if ("previous" === dir) focusedIndex > 0 ? focusedIndex -= 1 : focusedIndex = options.length - 1; else if ("start" === dir) focusedIndex = 0; else if ("end" === dir) focusedIndex = options.length - 1; else if ("page_up" === dir) {
                            var potentialIndex = focusedIndex - this.props.pageSize;
                            focusedIndex = potentialIndex < 0 ? 0 : potentialIndex;
                        } else if ("page_down" === dir) {
                            var potentialIndex = focusedIndex + this.props.pageSize;
                            focusedIndex = potentialIndex > options.length - 1 ? options.length - 1 : potentialIndex;
                        }
                        focusedIndex === -1 && (focusedIndex = 0), this.setState({
                            focusedIndex: options[focusedIndex].index,
                            focusedOption: options[focusedIndex].option
                        });
                    }
                }
            }, {
                key: "getFocusedOption",
                value: function() {
                    return this._focusedOption;
                }
            }, {
                key: "getInputValue",
                value: function() {
                    return this.state.inputValue;
                }
            }, {
                key: "selectFocusedOption",
                value: function() {
                    if (this._focusedOption) return this.selectValue(this._focusedOption);
                }
            }, {
                key: "renderLoading",
                value: function() {
                    if (this.props.isLoading) return _react2.default.createElement("span", {
                        className: "Select-loading-zone",
                        "aria-hidden": "true"
                    }, _react2.default.createElement("span", {
                        className: "Select-loading"
                    }));
                }
            }, {
                key: "renderValue",
                value: function(valueArray, isOpen) {
                    var _this5 = this, renderLabel = this.props.valueRenderer || this.getOptionLabel, ValueComponent = this.props.valueComponent;
                    if (!valueArray.length) return this.state.inputValue ? null : _react2.default.createElement("div", {
                        className: "Select-placeholder"
                    }, this.props.placeholder);
                    var onClick = this.props.onValueClick ? this.handleValueClick : null;
                    return this.props.multi ? valueArray.map(function(value, i) {
                        return _react2.default.createElement(ValueComponent, {
                            id: _this5._instancePrefix + "-value-" + i,
                            instancePrefix: _this5._instancePrefix,
                            disabled: _this5.props.disabled || value.clearableValue === !1,
                            key: "value-" + i + "-" + value[_this5.props.valueKey],
                            onClick: onClick,
                            onRemove: _this5.removeValue,
                            value: value
                        }, renderLabel(value, i), _react2.default.createElement("span", {
                            className: "Select-aria-only"
                        }, " "));
                    }) : this.state.inputValue ? void 0 : (isOpen && (onClick = null), _react2.default.createElement(ValueComponent, {
                        id: this._instancePrefix + "-value-item",
                        disabled: this.props.disabled,
                        instancePrefix: this._instancePrefix,
                        onClick: onClick,
                        value: valueArray[0]
                    }, renderLabel(valueArray[0])));
                }
            }, {
                key: "renderInput",
                value: function(valueArray, focusedOptionIndex) {
                    var _classNames, _this6 = this, className = (0, _classnames2.default)("Select-input", this.props.inputProps.className), isOpen = !!this.state.isOpen, ariaOwns = (0, 
                    _classnames2.default)((_classNames = {}, _defineProperty(_classNames, this._instancePrefix + "-list", isOpen), 
                    _defineProperty(_classNames, this._instancePrefix + "-backspace-remove-message", this.props.multi && !this.props.disabled && this.state.isFocused && !this.state.inputValue), 
                    _classNames)), inputProps = _extends({}, this.props.inputProps, {
                        role: "combobox",
                        "aria-expanded": "" + isOpen,
                        "aria-owns": ariaOwns,
                        "aria-haspopup": "" + isOpen,
                        "aria-activedescendant": isOpen ? this._instancePrefix + "-option-" + focusedOptionIndex : this._instancePrefix + "-value",
                        "aria-describedby": this.props["aria-describedby"],
                        "aria-labelledby": this.props["aria-labelledby"],
                        "aria-label": this.props["aria-label"],
                        className: className,
                        tabIndex: this.props.tabIndex,
                        onBlur: this.handleInputBlur,
                        onChange: this.handleInputChange,
                        onFocus: this.handleInputFocus,
                        ref: function(_ref) {
                            return _this6.input = _ref;
                        },
                        required: this.state.required,
                        value: this.state.inputValue
                    });
                    if (this.props.inputRenderer) return this.props.inputRenderer(inputProps);
                    if (this.props.disabled || !this.props.searchable) {
                        var _props$inputProps = this.props.inputProps, divProps = (_props$inputProps.inputClassName, 
                        _objectWithoutProperties(_props$inputProps, [ "inputClassName" ])), _ariaOwns = (0, 
                        _classnames2.default)(_defineProperty({}, this._instancePrefix + "-list", isOpen));
                        return _react2.default.createElement("div", _extends({}, divProps, {
                            role: "combobox",
                            "aria-expanded": isOpen,
                            "aria-owns": _ariaOwns,
                            "aria-activedescendant": isOpen ? this._instancePrefix + "-option-" + focusedOptionIndex : this._instancePrefix + "-value",
                            className: className,
                            tabIndex: this.props.tabIndex || 0,
                            onBlur: this.handleInputBlur,
                            onFocus: this.handleInputFocus,
                            ref: function(_ref2) {
                                return _this6.input = _ref2;
                            },
                            "aria-readonly": "" + !!this.props.disabled,
                            style: {
                                border: 0,
                                width: 1,
                                display: "inline-block"
                            }
                        }));
                    }
                    return this.props.autosize ? _react2.default.createElement(_reactInputAutosize2.default, _extends({}, inputProps, {
                        minWidth: "5"
                    })) : _react2.default.createElement("div", {
                        className: className
                    }, _react2.default.createElement("input", inputProps));
                }
            }, {
                key: "renderClear",
                value: function() {
                    if (!(!this.props.clearable || void 0 === this.props.value || null === this.props.value || this.props.multi && !this.props.value.length || this.props.disabled || this.props.isLoading)) {
                        var clear = this.props.clearRenderer();
                        return _react2.default.createElement("span", {
                            className: "Select-clear-zone",
                            title: this.props.multi ? this.props.clearAllText : this.props.clearValueText,
                            "aria-label": this.props.multi ? this.props.clearAllText : this.props.clearValueText,
                            onMouseDown: this.clearValue,
                            onTouchStart: this.handleTouchStart,
                            onTouchMove: this.handleTouchMove,
                            onTouchEnd: this.handleTouchEndClearValue
                        }, clear);
                    }
                }
            }, {
                key: "renderArrow",
                value: function() {
                    var onMouseDown = this.handleMouseDownOnArrow, isOpen = this.state.isOpen, arrow = this.props.arrowRenderer({
                        onMouseDown: onMouseDown,
                        isOpen: isOpen
                    });
                    return _react2.default.createElement("span", {
                        className: "Select-arrow-zone",
                        onMouseDown: onMouseDown
                    }, arrow);
                }
            }, {
                key: "filterOptions",
                value: function filterOptions(excludeOptions) {
                    var filterValue = this.state.inputValue, options = this.props.options || [];
                    if (this.props.filterOptions) {
                        // Maintain backwards compatibility with boolean attribute
                        var filterOptions = "function" == typeof this.props.filterOptions ? this.props.filterOptions : _defaultFilterOptions2.default;
                        return filterOptions(options, filterValue, excludeOptions, {
                            filterOption: this.props.filterOption,
                            ignoreAccents: this.props.ignoreAccents,
                            ignoreCase: this.props.ignoreCase,
                            labelKey: this.props.labelKey,
                            matchPos: this.props.matchPos,
                            matchProp: this.props.matchProp,
                            valueKey: this.props.valueKey
                        });
                    }
                    return options;
                }
            }, {
                key: "onOptionRef",
                value: function(ref, isFocused) {
                    isFocused && (this.focused = ref);
                }
            }, {
                key: "renderMenu",
                value: function(options, valueArray, focusedOption) {
                    return options && options.length ? this.props.menuRenderer({
                        focusedOption: focusedOption,
                        focusOption: this.focusOption,
                        instancePrefix: this._instancePrefix,
                        labelKey: this.props.labelKey,
                        onFocus: this.focusOption,
                        onSelect: this.selectValue,
                        optionClassName: this.props.optionClassName,
                        optionComponent: this.props.optionComponent,
                        optionRenderer: this.props.optionRenderer || this.getOptionLabel,
                        options: options,
                        selectValue: this.selectValue,
                        valueArray: valueArray,
                        valueKey: this.props.valueKey,
                        onOptionRef: this.onOptionRef
                    }) : this.props.noResultsText ? _react2.default.createElement("div", {
                        className: "Select-noresults"
                    }, this.props.noResultsText) : null;
                }
            }, {
                key: "renderHiddenField",
                value: function(valueArray) {
                    var _this7 = this;
                    if (this.props.name) {
                        if (this.props.joinValues) {
                            var value = valueArray.map(function(i) {
                                return stringifyValue(i[_this7.props.valueKey]);
                            }).join(this.props.delimiter);
                            return _react2.default.createElement("input", {
                                type: "hidden",
                                ref: function(_ref3) {
                                    return _this7.value = _ref3;
                                },
                                name: this.props.name,
                                value: value,
                                disabled: this.props.disabled
                            });
                        }
                        return valueArray.map(function(item, index) {
                            return _react2.default.createElement("input", {
                                key: "hidden." + index,
                                type: "hidden",
                                ref: "value" + index,
                                name: _this7.props.name,
                                value: stringifyValue(item[_this7.props.valueKey]),
                                disabled: _this7.props.disabled
                            });
                        });
                    }
                }
            }, {
                key: "getFocusableOptionIndex",
                value: function(selectedOption) {
                    var options = this._visibleOptions;
                    if (!options.length) return null;
                    var valueKey = this.props.valueKey, focusedOption = this.state.focusedOption || selectedOption;
                    if (focusedOption && !focusedOption.disabled) {
                        var focusedOptionIndex = -1;
                        if (options.some(function(option, index) {
                            var isOptionEqual = option[valueKey] === focusedOption[valueKey];
                            return isOptionEqual && (focusedOptionIndex = index), isOptionEqual;
                        }), focusedOptionIndex !== -1) return focusedOptionIndex;
                    }
                    for (var i = 0; i < options.length; i++) if (!options[i].disabled) return i;
                    return null;
                }
            }, {
                key: "renderOuter",
                value: function(options, valueArray, focusedOption) {
                    var _this8 = this, menu = this.renderMenu(options, valueArray, focusedOption);
                    return menu ? _react2.default.createElement("div", {
                        ref: function(_ref5) {
                            return _this8.menuContainer = _ref5;
                        },
                        className: "Select-menu-outer",
                        style: this.props.menuContainerStyle
                    }, _react2.default.createElement("div", {
                        ref: function(_ref4) {
                            return _this8.menu = _ref4;
                        },
                        role: "listbox",
                        tabIndex: -1,
                        className: "Select-menu",
                        id: this._instancePrefix + "-list",
                        style: this.props.menuStyle,
                        onScroll: this.handleMenuScroll,
                        onMouseDown: this.handleMouseDownOnMenu
                    }, menu)) : null;
                }
            }, {
                key: "render",
                value: function() {
                    var _this9 = this, valueArray = this.getValueArray(this.props.value), options = this._visibleOptions = this.filterOptions(this.props.multi ? this.getValueArray(this.props.value) : null), isOpen = this.state.isOpen;
                    this.props.multi && !options.length && valueArray.length && !this.state.inputValue && (isOpen = !1);
                    var focusedOptionIndex = this.getFocusableOptionIndex(valueArray[0]), focusedOption = null;
                    focusedOption = null !== focusedOptionIndex ? this._focusedOption = options[focusedOptionIndex] : this._focusedOption = null;
                    var className = (0, _classnames2.default)("Select", this.props.className, {
                        "Select--multi": this.props.multi,
                        "Select--single": !this.props.multi,
                        "is-clearable": this.props.clearable,
                        "is-disabled": this.props.disabled,
                        "is-focused": this.state.isFocused,
                        "is-loading": this.props.isLoading,
                        "is-open": isOpen,
                        "is-pseudo-focused": this.state.isPseudoFocused,
                        "is-searchable": this.props.searchable,
                        "has-value": valueArray.length
                    }), removeMessage = null;
                    return this.props.multi && !this.props.disabled && valueArray.length && !this.state.inputValue && this.state.isFocused && this.props.backspaceRemoves && (removeMessage = _react2.default.createElement("span", {
                        id: this._instancePrefix + "-backspace-remove-message",
                        className: "Select-aria-only",
                        "aria-live": "assertive"
                    }, this.props.backspaceToRemoveMessage.replace("{label}", valueArray[valueArray.length - 1][this.props.labelKey]))), 
                    _react2.default.createElement("div", {
                        ref: function(_ref7) {
                            return _this9.wrapper = _ref7;
                        },
                        className: className,
                        style: this.props.wrapperStyle
                    }, this.renderHiddenField(valueArray), _react2.default.createElement("div", {
                        ref: function(_ref6) {
                            return _this9.control = _ref6;
                        },
                        className: "Select-control",
                        style: this.props.style,
                        onKeyDown: this.handleKeyDown,
                        onMouseDown: this.handleMouseDown,
                        onTouchEnd: this.handleTouchEnd,
                        onTouchStart: this.handleTouchStart,
                        onTouchMove: this.handleTouchMove
                    }, _react2.default.createElement("span", {
                        className: "Select-multi-value-wrapper",
                        id: this._instancePrefix + "-value"
                    }, this.renderValue(valueArray, isOpen), this.renderInput(valueArray, focusedOptionIndex)), removeMessage, this.renderLoading(), this.renderClear(), this.renderArrow()), isOpen ? this.renderOuter(options, this.props.multi ? null : valueArray, focusedOption) : null);
                }
            } ]), Select;
        }(_react2.default.Component);
        Select.propTypes = {
            "aria-describedby": _propTypes2.default.string,
            // HTML ID(s) of element(s) that should be used to describe this input (for assistive tech)
            "aria-label": _propTypes2.default.string,
            // Aria label (for assistive tech)
            "aria-labelledby": _propTypes2.default.string,
            // HTML ID of an element that should be used as the label (for assistive tech)
            addLabelText: _propTypes2.default.string,
            // placeholder displayed when you want to add a label on a multi-value input
            arrowRenderer: _propTypes2.default.func,
            // Create drop-down caret element
            autoBlur: _propTypes2.default.bool,
            // automatically blur the component when an option is selected
            autofocus: _propTypes2.default.bool,
            // autofocus the component on mount
            autosize: _propTypes2.default.bool,
            // whether to enable autosizing or not
            backspaceRemoves: _propTypes2.default.bool,
            // whether backspace removes an item if there is no text input
            backspaceToRemoveMessage: _propTypes2.default.string,
            // Message to use for screenreaders to press backspace to remove the current item - {label} is replaced with the item label
            className: _propTypes2.default.string,
            // className for the outer element
            clearAllText: stringOrNode,
            // title for the "clear" control when multi: true
            clearRenderer: _propTypes2.default.func,
            // create clearable x element
            clearValueText: stringOrNode,
            // title for the "clear" control
            clearable: _propTypes2.default.bool,
            // should it be possible to reset value
            closeOnSelect: _propTypes2.default.bool,
            // whether to close the menu when a value is selected
            deleteRemoves: _propTypes2.default.bool,
            // whether backspace removes an item if there is no text input
            delimiter: _propTypes2.default.string,
            // delimiter to use to join multiple values for the hidden field value
            disabled: _propTypes2.default.bool,
            // whether the Select is disabled or not
            escapeClearsValue: _propTypes2.default.bool,
            // whether escape clears the value when the menu is closed
            filterOption: _propTypes2.default.func,
            // method to filter a single option (option, filterString)
            filterOptions: _propTypes2.default.any,
            // boolean to enable default filtering or function to filter the options array ([options], filterString, [values])
            ignoreAccents: _propTypes2.default.bool,
            // whether to strip diacritics when filtering
            ignoreCase: _propTypes2.default.bool,
            // whether to perform case-insensitive filtering
            inputProps: _propTypes2.default.object,
            // custom attributes for the Input
            inputRenderer: _propTypes2.default.func,
            // returns a custom input component
            instanceId: _propTypes2.default.string,
            // set the components instanceId
            isLoading: _propTypes2.default.bool,
            // whether the Select is loading externally or not (such as options being loaded)
            joinValues: _propTypes2.default.bool,
            // joins multiple values into a single form field with the delimiter (legacy mode)
            labelKey: _propTypes2.default.string,
            // path of the label value in option objects
            matchPos: _propTypes2.default.string,
            // (any|start) match the start or entire string when filtering
            matchProp: _propTypes2.default.string,
            // (any|label|value) which option property to filter on
            menuBuffer: _propTypes2.default.number,
            // optional buffer (in px) between the bottom of the viewport and the bottom of the menu
            menuContainerStyle: _propTypes2.default.object,
            // optional style to apply to the menu container
            menuRenderer: _propTypes2.default.func,
            // renders a custom menu with options
            menuStyle: _propTypes2.default.object,
            // optional style to apply to the menu
            multi: _propTypes2.default.bool,
            // multi-value input
            name: _propTypes2.default.string,
            // generates a hidden <input /> tag with this field name for html forms
            noResultsText: stringOrNode,
            // placeholder displayed when there are no matching search results
            onBlur: _propTypes2.default.func,
            // onBlur handler: function (event) {}
            onBlurResetsInput: _propTypes2.default.bool,
            // whether input is cleared on blur
            onChange: _propTypes2.default.func,
            // onChange handler: function (newValue) {}
            onClose: _propTypes2.default.func,
            // fires when the menu is closed
            onCloseResetsInput: _propTypes2.default.bool,
            // whether input is cleared when menu is closed through the arrow
            onFocus: _propTypes2.default.func,
            // onFocus handler: function (event) {}
            onInputChange: _propTypes2.default.func,
            // onInputChange handler: function (inputValue) {}
            onInputKeyDown: _propTypes2.default.func,
            // input keyDown handler: function (event) {}
            onMenuScrollToBottom: _propTypes2.default.func,
            // fires when the menu is scrolled to the bottom; can be used to paginate options
            onOpen: _propTypes2.default.func,
            // fires when the menu is opened
            onSelectResetsInput: _propTypes2.default.bool,
            // whether input is cleared on select (works only for multiselect)
            onValueClick: _propTypes2.default.func,
            // onClick handler for value labels: function (value, event) {}
            openOnClick: _propTypes2.default.bool,
            // boolean to control opening the menu when the control is clicked
            openOnFocus: _propTypes2.default.bool,
            // always open options menu on focus
            optionClassName: _propTypes2.default.string,
            // additional class(es) to apply to the <Option /> elements
            optionComponent: _propTypes2.default.func,
            // option component to render in dropdown
            optionRenderer: _propTypes2.default.func,
            // optionRenderer: function (option) {}
            options: _propTypes2.default.array,
            // array of options
            pageSize: _propTypes2.default.number,
            // number of entries to page when using page up/down keys
            placeholder: stringOrNode,
            // field placeholder, displayed when there's no value
            required: _propTypes2.default.bool,
            // applies HTML5 required attribute when needed
            resetValue: _propTypes2.default.any,
            // value to use when you clear the control
            scrollMenuIntoView: _propTypes2.default.bool,
            // boolean to enable the viewport to shift so that the full menu fully visible when engaged
            searchable: _propTypes2.default.bool,
            // whether to enable searching feature or not
            simpleValue: _propTypes2.default.bool,
            // pass the value to onChange as a simple value (legacy pre 1.0 mode), defaults to false
            style: _propTypes2.default.object,
            // optional style to apply to the control
            tabIndex: _propTypes2.default.string,
            // optional tab index of the control
            tabSelectsValue: _propTypes2.default.bool,
            // whether to treat tabbing out while focused to be value selection
            value: _propTypes2.default.any,
            // initial field value
            valueComponent: _propTypes2.default.func,
            // value component to render
            valueKey: _propTypes2.default.string,
            // path of the label value in option objects
            valueRenderer: _propTypes2.default.func,
            // valueRenderer: function (option) {}
            wrapperStyle: _propTypes2.default.object
        }, Select.defaultProps = {
            addLabelText: 'Add "{label}"?',
            arrowRenderer: _defaultArrowRenderer2.default,
            autosize: !0,
            backspaceRemoves: !0,
            backspaceToRemoveMessage: "Press backspace to remove {label}",
            clearable: !0,
            clearAllText: "Clear all",
            clearRenderer: _defaultClearRenderer2.default,
            clearValueText: "Clear value",
            closeOnSelect: !0,
            deleteRemoves: !0,
            delimiter: ",",
            disabled: !1,
            escapeClearsValue: !0,
            filterOptions: _defaultFilterOptions2.default,
            ignoreAccents: !0,
            ignoreCase: !0,
            inputProps: {},
            isLoading: !1,
            joinValues: !1,
            labelKey: "label",
            matchPos: "any",
            matchProp: "any",
            menuBuffer: 0,
            menuRenderer: _defaultMenuRenderer2.default,
            multi: !1,
            noResultsText: "No results found",
            onBlurResetsInput: !0,
            onSelectResetsInput: !0,
            onCloseResetsInput: !0,
            openOnClick: !0,
            optionComponent: _Option2.default,
            pageSize: 5,
            placeholder: "Select...",
            required: !1,
            scrollMenuIntoView: !0,
            searchable: !0,
            simpleValue: !1,
            tabSelectsValue: !0,
            valueComponent: _Value2.default,
            valueKey: "value"
        }, exports.default = Select;
    }, /* 149 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _objectWithoutProperties(obj, keys) {
            var target = {};
            for (var i in obj) keys.indexOf(i) >= 0 || Object.prototype.hasOwnProperty.call(obj, i) && (target[i] = obj[i]);
            return target;
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        }, _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }(), _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _propTypes = __webpack_require__(109), _propTypes2 = _interopRequireDefault(_propTypes), sizerStyle = {
            position: "absolute",
            top: 0,
            left: 0,
            visibility: "hidden",
            height: 0,
            overflow: "scroll",
            whiteSpace: "pre"
        }, AutosizeInput = function(_Component) {
            function AutosizeInput(props) {
                _classCallCheck(this, AutosizeInput);
                var _this = _possibleConstructorReturn(this, (AutosizeInput.__proto__ || Object.getPrototypeOf(AutosizeInput)).call(this, props));
                return _this.inputRef = function(el) {
                    _this.input = el, "function" == typeof _this.props.inputRef && _this.props.inputRef(el);
                }, _this.placeHolderSizerRef = function(el) {
                    _this.placeHolderSizer = el;
                }, _this.sizerRef = function(el) {
                    _this.sizer = el;
                }, _this.state = {
                    inputWidth: props.minWidth,
                    inputId: "_" + Math.random().toString(36).substr(2, 12)
                }, _this;
            }
            return _inherits(AutosizeInput, _Component), _createClass(AutosizeInput, [ {
                key: "componentDidMount",
                value: function() {
                    this.mounted = !0, this.copyInputStyles(), this.updateInputWidth();
                }
            }, {
                key: "componentDidUpdate",
                value: function(prevProps, prevState) {
                    prevState.inputWidth !== this.state.inputWidth && "function" == typeof this.props.onAutosize && this.props.onAutosize(this.state.inputWidth), 
                    this.updateInputWidth();
                }
            }, {
                key: "componentWillUnmount",
                value: function() {
                    this.mounted = !1;
                }
            }, {
                key: "copyInputStyles",
                value: function() {
                    if (this.mounted && window.getComputedStyle) {
                        var inputStyle = this.input && window.getComputedStyle(this.input);
                        if (inputStyle) {
                            var widthNode = this.sizer;
                            if (widthNode.style.fontSize = inputStyle.fontSize, widthNode.style.fontFamily = inputStyle.fontFamily, 
                            widthNode.style.fontWeight = inputStyle.fontWeight, widthNode.style.fontStyle = inputStyle.fontStyle, 
                            widthNode.style.letterSpacing = inputStyle.letterSpacing, widthNode.style.textTransform = inputStyle.textTransform, 
                            this.props.placeholder) {
                                var placeholderNode = this.placeHolderSizer;
                                placeholderNode.style.fontSize = inputStyle.fontSize, placeholderNode.style.fontFamily = inputStyle.fontFamily, 
                                placeholderNode.style.fontWeight = inputStyle.fontWeight, placeholderNode.style.fontStyle = inputStyle.fontStyle, 
                                placeholderNode.style.letterSpacing = inputStyle.letterSpacing, placeholderNode.style.textTransform = inputStyle.textTransform;
                            }
                        }
                    }
                }
            }, {
                key: "updateInputWidth",
                value: function() {
                    if (this.mounted && this.sizer && "undefined" != typeof this.sizer.scrollWidth) {
                        var newInputWidth = void 0;
                        newInputWidth = this.props.placeholder && (!this.props.value || this.props.value && this.props.placeholderIsMinWidth) ? Math.max(this.sizer.scrollWidth, this.placeHolderSizer.scrollWidth) + 2 : this.sizer.scrollWidth + 2, 
                        newInputWidth < this.props.minWidth && (newInputWidth = this.props.minWidth), newInputWidth !== this.state.inputWidth && this.setState({
                            inputWidth: newInputWidth
                        });
                    }
                }
            }, {
                key: "getInput",
                value: function() {
                    return this.input;
                }
            }, {
                key: "focus",
                value: function() {
                    this.input.focus();
                }
            }, {
                key: "blur",
                value: function() {
                    this.input.blur();
                }
            }, {
                key: "select",
                value: function() {
                    this.input.select();
                }
            }, {
                key: "render",
                value: function() {
                    var sizerValue = [ this.props.defaultValue, this.props.value, "" ].reduce(function(previousValue, currentValue) {
                        return null !== previousValue && void 0 !== previousValue ? previousValue : currentValue;
                    }), wrapperStyle = _extends({}, this.props.style);
                    wrapperStyle.display || (wrapperStyle.display = "inline-block");
                    var inputStyle = _extends({}, this.props.inputStyle);
                    inputStyle.width = this.state.inputWidth + "px", inputStyle.boxSizing = "content-box";
                    var inputProps = _objectWithoutProperties(this.props, []);
                    // ensure props meant for `AutosizeInput` don't end up on the `input`
                    return inputProps.className = this.props.inputClassName, inputProps.style = inputStyle, 
                    delete inputProps.inputClassName, delete inputProps.inputStyle, delete inputProps.minWidth, 
                    delete inputProps.onAutosize, delete inputProps.placeholderIsMinWidth, delete inputProps.inputRef, 
                    _react2.default.createElement("div", {
                        className: this.props.className,
                        style: wrapperStyle
                    }, _react2.default.createElement("style", {
                        dangerouslySetInnerHTML: {
                            __html: [ "input#" + this.state.id + "::-ms-clear {display: none;}" ].join("\n")
                        }
                    }), _react2.default.createElement("input", _extends({
                        id: this.state.id
                    }, inputProps, {
                        ref: this.inputRef
                    })), _react2.default.createElement("div", {
                        ref: this.sizerRef,
                        style: sizerStyle
                    }, sizerValue), this.props.placeholder ? _react2.default.createElement("div", {
                        ref: this.placeHolderSizerRef,
                        style: sizerStyle
                    }, this.props.placeholder) : null);
                }
            } ]), AutosizeInput;
        }(_react.Component);
        AutosizeInput.propTypes = {
            className: _propTypes2.default.string,
            // className for the outer element
            defaultValue: _propTypes2.default.any,
            // default field value
            inputClassName: _propTypes2.default.string,
            // className for the input element
            inputRef: _propTypes2.default.func,
            // ref callback for the input element
            inputStyle: _propTypes2.default.object,
            // css styles for the input element
            minWidth: _propTypes2.default.oneOfType([ // minimum width for input element
            _propTypes2.default.number, _propTypes2.default.string ]),
            onAutosize: _propTypes2.default.func,
            // onAutosize handler: function(newWidth) {}
            onChange: _propTypes2.default.func,
            // onChange handler: function(newValue) {}
            placeholder: _propTypes2.default.string,
            // placeholder text
            placeholderIsMinWidth: _propTypes2.default.bool,
            // don't collapse size to less than the placeholder
            style: _propTypes2.default.object,
            // css styles for the outer element
            value: _propTypes2.default.any
        }, AutosizeInput.defaultProps = {
            minWidth: 1
        }, exports.default = AutosizeInput;
    }, /* 150 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function arrowRenderer(_ref) {
            var onMouseDown = _ref.onMouseDown;
            return _react2.default.createElement("span", {
                className: "Select-arrow",
                onMouseDown: onMouseDown
            });
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = arrowRenderer;
        var _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _propTypes = __webpack_require__(109), _propTypes2 = _interopRequireDefault(_propTypes);
        arrowRenderer.propTypes = {
            onMouseDown: _propTypes2.default.func
        };
    }, /* 151 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function filterOptions(options, filterValue, excludeOptions, props) {
            var _this = this;
            return props.ignoreAccents && (filterValue = (0, _stripDiacritics2.default)(filterValue)), 
            props.ignoreCase && (filterValue = filterValue.toLowerCase()), excludeOptions && (excludeOptions = excludeOptions.map(function(i) {
                return i[props.valueKey];
            })), options.filter(function(option) {
                if (excludeOptions && excludeOptions.indexOf(option[props.valueKey]) > -1) return !1;
                if (props.filterOption) return props.filterOption.call(_this, option, filterValue);
                if (!filterValue) return !0;
                var valueTest = String(option[props.valueKey]), labelTest = String(option[props.labelKey]);
                return props.ignoreAccents && ("label" !== props.matchProp && (valueTest = (0, _stripDiacritics2.default)(valueTest)), 
                "value" !== props.matchProp && (labelTest = (0, _stripDiacritics2.default)(labelTest))), 
                props.ignoreCase && ("label" !== props.matchProp && (valueTest = valueTest.toLowerCase()), 
                "value" !== props.matchProp && (labelTest = labelTest.toLowerCase())), "start" === props.matchPos ? "label" !== props.matchProp && valueTest.substr(0, filterValue.length) === filterValue || "value" !== props.matchProp && labelTest.substr(0, filterValue.length) === filterValue : "label" !== props.matchProp && valueTest.indexOf(filterValue) >= 0 || "value" !== props.matchProp && labelTest.indexOf(filterValue) >= 0;
            });
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _stripDiacritics = __webpack_require__(152), _stripDiacritics2 = _interopRequireDefault(_stripDiacritics);
        exports.default = filterOptions;
    }, /* 152 */
    /***/
    function(module, exports) {
        "use strict";
        function stripDiacritics(str) {
            for (var i = 0; i < map.length; i++) str = str.replace(map[i].letters, map[i].base);
            return str;
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = stripDiacritics;
        var map = [ {
            base: "A",
            letters: /[\u0041\u24B6\uFF21\u00C0\u00C1\u00C2\u1EA6\u1EA4\u1EAA\u1EA8\u00C3\u0100\u0102\u1EB0\u1EAE\u1EB4\u1EB2\u0226\u01E0\u00C4\u01DE\u1EA2\u00C5\u01FA\u01CD\u0200\u0202\u1EA0\u1EAC\u1EB6\u1E00\u0104\u023A\u2C6F]/g
        }, {
            base: "AA",
            letters: /[\uA732]/g
        }, {
            base: "AE",
            letters: /[\u00C6\u01FC\u01E2]/g
        }, {
            base: "AO",
            letters: /[\uA734]/g
        }, {
            base: "AU",
            letters: /[\uA736]/g
        }, {
            base: "AV",
            letters: /[\uA738\uA73A]/g
        }, {
            base: "AY",
            letters: /[\uA73C]/g
        }, {
            base: "B",
            letters: /[\u0042\u24B7\uFF22\u1E02\u1E04\u1E06\u0243\u0182\u0181]/g
        }, {
            base: "C",
            letters: /[\u0043\u24B8\uFF23\u0106\u0108\u010A\u010C\u00C7\u1E08\u0187\u023B\uA73E]/g
        }, {
            base: "D",
            letters: /[\u0044\u24B9\uFF24\u1E0A\u010E\u1E0C\u1E10\u1E12\u1E0E\u0110\u018B\u018A\u0189\uA779]/g
        }, {
            base: "DZ",
            letters: /[\u01F1\u01C4]/g
        }, {
            base: "Dz",
            letters: /[\u01F2\u01C5]/g
        }, {
            base: "E",
            letters: /[\u0045\u24BA\uFF25\u00C8\u00C9\u00CA\u1EC0\u1EBE\u1EC4\u1EC2\u1EBC\u0112\u1E14\u1E16\u0114\u0116\u00CB\u1EBA\u011A\u0204\u0206\u1EB8\u1EC6\u0228\u1E1C\u0118\u1E18\u1E1A\u0190\u018E]/g
        }, {
            base: "F",
            letters: /[\u0046\u24BB\uFF26\u1E1E\u0191\uA77B]/g
        }, {
            base: "G",
            letters: /[\u0047\u24BC\uFF27\u01F4\u011C\u1E20\u011E\u0120\u01E6\u0122\u01E4\u0193\uA7A0\uA77D\uA77E]/g
        }, {
            base: "H",
            letters: /[\u0048\u24BD\uFF28\u0124\u1E22\u1E26\u021E\u1E24\u1E28\u1E2A\u0126\u2C67\u2C75\uA78D]/g
        }, {
            base: "I",
            letters: /[\u0049\u24BE\uFF29\u00CC\u00CD\u00CE\u0128\u012A\u012C\u0130\u00CF\u1E2E\u1EC8\u01CF\u0208\u020A\u1ECA\u012E\u1E2C\u0197]/g
        }, {
            base: "J",
            letters: /[\u004A\u24BF\uFF2A\u0134\u0248]/g
        }, {
            base: "K",
            letters: /[\u004B\u24C0\uFF2B\u1E30\u01E8\u1E32\u0136\u1E34\u0198\u2C69\uA740\uA742\uA744\uA7A2]/g
        }, {
            base: "L",
            letters: /[\u004C\u24C1\uFF2C\u013F\u0139\u013D\u1E36\u1E38\u013B\u1E3C\u1E3A\u0141\u023D\u2C62\u2C60\uA748\uA746\uA780]/g
        }, {
            base: "LJ",
            letters: /[\u01C7]/g
        }, {
            base: "Lj",
            letters: /[\u01C8]/g
        }, {
            base: "M",
            letters: /[\u004D\u24C2\uFF2D\u1E3E\u1E40\u1E42\u2C6E\u019C]/g
        }, {
            base: "N",
            letters: /[\u004E\u24C3\uFF2E\u01F8\u0143\u00D1\u1E44\u0147\u1E46\u0145\u1E4A\u1E48\u0220\u019D\uA790\uA7A4]/g
        }, {
            base: "NJ",
            letters: /[\u01CA]/g
        }, {
            base: "Nj",
            letters: /[\u01CB]/g
        }, {
            base: "O",
            letters: /[\u004F\u24C4\uFF2F\u00D2\u00D3\u00D4\u1ED2\u1ED0\u1ED6\u1ED4\u00D5\u1E4C\u022C\u1E4E\u014C\u1E50\u1E52\u014E\u022E\u0230\u00D6\u022A\u1ECE\u0150\u01D1\u020C\u020E\u01A0\u1EDC\u1EDA\u1EE0\u1EDE\u1EE2\u1ECC\u1ED8\u01EA\u01EC\u00D8\u01FE\u0186\u019F\uA74A\uA74C]/g
        }, {
            base: "OI",
            letters: /[\u01A2]/g
        }, {
            base: "OO",
            letters: /[\uA74E]/g
        }, {
            base: "OU",
            letters: /[\u0222]/g
        }, {
            base: "P",
            letters: /[\u0050\u24C5\uFF30\u1E54\u1E56\u01A4\u2C63\uA750\uA752\uA754]/g
        }, {
            base: "Q",
            letters: /[\u0051\u24C6\uFF31\uA756\uA758\u024A]/g
        }, {
            base: "R",
            letters: /[\u0052\u24C7\uFF32\u0154\u1E58\u0158\u0210\u0212\u1E5A\u1E5C\u0156\u1E5E\u024C\u2C64\uA75A\uA7A6\uA782]/g
        }, {
            base: "S",
            letters: /[\u0053\u24C8\uFF33\u1E9E\u015A\u1E64\u015C\u1E60\u0160\u1E66\u1E62\u1E68\u0218\u015E\u2C7E\uA7A8\uA784]/g
        }, {
            base: "T",
            letters: /[\u0054\u24C9\uFF34\u1E6A\u0164\u1E6C\u021A\u0162\u1E70\u1E6E\u0166\u01AC\u01AE\u023E\uA786]/g
        }, {
            base: "TZ",
            letters: /[\uA728]/g
        }, {
            base: "U",
            letters: /[\u0055\u24CA\uFF35\u00D9\u00DA\u00DB\u0168\u1E78\u016A\u1E7A\u016C\u00DC\u01DB\u01D7\u01D5\u01D9\u1EE6\u016E\u0170\u01D3\u0214\u0216\u01AF\u1EEA\u1EE8\u1EEE\u1EEC\u1EF0\u1EE4\u1E72\u0172\u1E76\u1E74\u0244]/g
        }, {
            base: "V",
            letters: /[\u0056\u24CB\uFF36\u1E7C\u1E7E\u01B2\uA75E\u0245]/g
        }, {
            base: "VY",
            letters: /[\uA760]/g
        }, {
            base: "W",
            letters: /[\u0057\u24CC\uFF37\u1E80\u1E82\u0174\u1E86\u1E84\u1E88\u2C72]/g
        }, {
            base: "X",
            letters: /[\u0058\u24CD\uFF38\u1E8A\u1E8C]/g
        }, {
            base: "Y",
            letters: /[\u0059\u24CE\uFF39\u1EF2\u00DD\u0176\u1EF8\u0232\u1E8E\u0178\u1EF6\u1EF4\u01B3\u024E\u1EFE]/g
        }, {
            base: "Z",
            letters: /[\u005A\u24CF\uFF3A\u0179\u1E90\u017B\u017D\u1E92\u1E94\u01B5\u0224\u2C7F\u2C6B\uA762]/g
        }, {
            base: "a",
            letters: /[\u0061\u24D0\uFF41\u1E9A\u00E0\u00E1\u00E2\u1EA7\u1EA5\u1EAB\u1EA9\u00E3\u0101\u0103\u1EB1\u1EAF\u1EB5\u1EB3\u0227\u01E1\u00E4\u01DF\u1EA3\u00E5\u01FB\u01CE\u0201\u0203\u1EA1\u1EAD\u1EB7\u1E01\u0105\u2C65\u0250]/g
        }, {
            base: "aa",
            letters: /[\uA733]/g
        }, {
            base: "ae",
            letters: /[\u00E6\u01FD\u01E3]/g
        }, {
            base: "ao",
            letters: /[\uA735]/g
        }, {
            base: "au",
            letters: /[\uA737]/g
        }, {
            base: "av",
            letters: /[\uA739\uA73B]/g
        }, {
            base: "ay",
            letters: /[\uA73D]/g
        }, {
            base: "b",
            letters: /[\u0062\u24D1\uFF42\u1E03\u1E05\u1E07\u0180\u0183\u0253]/g
        }, {
            base: "c",
            letters: /[\u0063\u24D2\uFF43\u0107\u0109\u010B\u010D\u00E7\u1E09\u0188\u023C\uA73F\u2184]/g
        }, {
            base: "d",
            letters: /[\u0064\u24D3\uFF44\u1E0B\u010F\u1E0D\u1E11\u1E13\u1E0F\u0111\u018C\u0256\u0257\uA77A]/g
        }, {
            base: "dz",
            letters: /[\u01F3\u01C6]/g
        }, {
            base: "e",
            letters: /[\u0065\u24D4\uFF45\u00E8\u00E9\u00EA\u1EC1\u1EBF\u1EC5\u1EC3\u1EBD\u0113\u1E15\u1E17\u0115\u0117\u00EB\u1EBB\u011B\u0205\u0207\u1EB9\u1EC7\u0229\u1E1D\u0119\u1E19\u1E1B\u0247\u025B\u01DD]/g
        }, {
            base: "f",
            letters: /[\u0066\u24D5\uFF46\u1E1F\u0192\uA77C]/g
        }, {
            base: "g",
            letters: /[\u0067\u24D6\uFF47\u01F5\u011D\u1E21\u011F\u0121\u01E7\u0123\u01E5\u0260\uA7A1\u1D79\uA77F]/g
        }, {
            base: "h",
            letters: /[\u0068\u24D7\uFF48\u0125\u1E23\u1E27\u021F\u1E25\u1E29\u1E2B\u1E96\u0127\u2C68\u2C76\u0265]/g
        }, {
            base: "hv",
            letters: /[\u0195]/g
        }, {
            base: "i",
            letters: /[\u0069\u24D8\uFF49\u00EC\u00ED\u00EE\u0129\u012B\u012D\u00EF\u1E2F\u1EC9\u01D0\u0209\u020B\u1ECB\u012F\u1E2D\u0268\u0131]/g
        }, {
            base: "j",
            letters: /[\u006A\u24D9\uFF4A\u0135\u01F0\u0249]/g
        }, {
            base: "k",
            letters: /[\u006B\u24DA\uFF4B\u1E31\u01E9\u1E33\u0137\u1E35\u0199\u2C6A\uA741\uA743\uA745\uA7A3]/g
        }, {
            base: "l",
            letters: /[\u006C\u24DB\uFF4C\u0140\u013A\u013E\u1E37\u1E39\u013C\u1E3D\u1E3B\u017F\u0142\u019A\u026B\u2C61\uA749\uA781\uA747]/g
        }, {
            base: "lj",
            letters: /[\u01C9]/g
        }, {
            base: "m",
            letters: /[\u006D\u24DC\uFF4D\u1E3F\u1E41\u1E43\u0271\u026F]/g
        }, {
            base: "n",
            letters: /[\u006E\u24DD\uFF4E\u01F9\u0144\u00F1\u1E45\u0148\u1E47\u0146\u1E4B\u1E49\u019E\u0272\u0149\uA791\uA7A5]/g
        }, {
            base: "nj",
            letters: /[\u01CC]/g
        }, {
            base: "o",
            letters: /[\u006F\u24DE\uFF4F\u00F2\u00F3\u00F4\u1ED3\u1ED1\u1ED7\u1ED5\u00F5\u1E4D\u022D\u1E4F\u014D\u1E51\u1E53\u014F\u022F\u0231\u00F6\u022B\u1ECF\u0151\u01D2\u020D\u020F\u01A1\u1EDD\u1EDB\u1EE1\u1EDF\u1EE3\u1ECD\u1ED9\u01EB\u01ED\u00F8\u01FF\u0254\uA74B\uA74D\u0275]/g
        }, {
            base: "oi",
            letters: /[\u01A3]/g
        }, {
            base: "ou",
            letters: /[\u0223]/g
        }, {
            base: "oo",
            letters: /[\uA74F]/g
        }, {
            base: "p",
            letters: /[\u0070\u24DF\uFF50\u1E55\u1E57\u01A5\u1D7D\uA751\uA753\uA755]/g
        }, {
            base: "q",
            letters: /[\u0071\u24E0\uFF51\u024B\uA757\uA759]/g
        }, {
            base: "r",
            letters: /[\u0072\u24E1\uFF52\u0155\u1E59\u0159\u0211\u0213\u1E5B\u1E5D\u0157\u1E5F\u024D\u027D\uA75B\uA7A7\uA783]/g
        }, {
            base: "s",
            letters: /[\u0073\u24E2\uFF53\u00DF\u015B\u1E65\u015D\u1E61\u0161\u1E67\u1E63\u1E69\u0219\u015F\u023F\uA7A9\uA785\u1E9B]/g
        }, {
            base: "t",
            letters: /[\u0074\u24E3\uFF54\u1E6B\u1E97\u0165\u1E6D\u021B\u0163\u1E71\u1E6F\u0167\u01AD\u0288\u2C66\uA787]/g
        }, {
            base: "tz",
            letters: /[\uA729]/g
        }, {
            base: "u",
            letters: /[\u0075\u24E4\uFF55\u00F9\u00FA\u00FB\u0169\u1E79\u016B\u1E7B\u016D\u00FC\u01DC\u01D8\u01D6\u01DA\u1EE7\u016F\u0171\u01D4\u0215\u0217\u01B0\u1EEB\u1EE9\u1EEF\u1EED\u1EF1\u1EE5\u1E73\u0173\u1E77\u1E75\u0289]/g
        }, {
            base: "v",
            letters: /[\u0076\u24E5\uFF56\u1E7D\u1E7F\u028B\uA75F\u028C]/g
        }, {
            base: "vy",
            letters: /[\uA761]/g
        }, {
            base: "w",
            letters: /[\u0077\u24E6\uFF57\u1E81\u1E83\u0175\u1E87\u1E85\u1E98\u1E89\u2C73]/g
        }, {
            base: "x",
            letters: /[\u0078\u24E7\uFF58\u1E8B\u1E8D]/g
        }, {
            base: "y",
            letters: /[\u0079\u24E8\uFF59\u1EF3\u00FD\u0177\u1EF9\u0233\u1E8F\u00FF\u1EF7\u1E99\u1EF5\u01B4\u024F\u1EFF]/g
        }, {
            base: "z",
            letters: /[\u007A\u24E9\uFF5A\u017A\u1E91\u017C\u017E\u1E93\u1E95\u01B6\u0225\u0240\u2C6C\uA763]/g
        } ];
    }, /* 153 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function menuRenderer(_ref) {
            var focusedOption = _ref.focusedOption, instancePrefix = _ref.instancePrefix, onFocus = (_ref.labelKey, 
            _ref.onFocus), onSelect = _ref.onSelect, optionClassName = _ref.optionClassName, optionComponent = _ref.optionComponent, optionRenderer = _ref.optionRenderer, options = _ref.options, valueArray = _ref.valueArray, valueKey = _ref.valueKey, onOptionRef = _ref.onOptionRef, Option = optionComponent;
            return options.map(function(option, i) {
                var isSelected = valueArray && valueArray.indexOf(option) > -1, isFocused = option === focusedOption, optionClass = (0, 
                _classnames2.default)(optionClassName, {
                    "Select-option": !0,
                    "is-selected": isSelected,
                    "is-focused": isFocused,
                    "is-disabled": option.disabled
                });
                return _react2.default.createElement(Option, {
                    className: optionClass,
                    instancePrefix: instancePrefix,
                    isDisabled: option.disabled,
                    isFocused: isFocused,
                    isSelected: isSelected,
                    key: "option-" + i + "-" + option[valueKey],
                    onFocus: onFocus,
                    onSelect: onSelect,
                    option: option,
                    optionIndex: i,
                    ref: function(_ref2) {
                        onOptionRef(_ref2, isFocused);
                    }
                }, optionRenderer(option, i));
            });
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _classnames = __webpack_require__(121), _classnames2 = _interopRequireDefault(_classnames), _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react);
        exports.default = menuRenderer;
    }, /* 154 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function clearRenderer() {
            return _react2.default.createElement("span", {
                className: "Select-clear",
                dangerouslySetInnerHTML: {
                    __html: "&times;"
                }
            });
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = clearRenderer;
        var _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react);
    }, /* 155 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }(), _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _propTypes = __webpack_require__(109), _propTypes2 = _interopRequireDefault(_propTypes), _classnames = __webpack_require__(121), _classnames2 = _interopRequireDefault(_classnames), Option = function(_React$Component) {
            function Option(props) {
                _classCallCheck(this, Option);
                var _this = _possibleConstructorReturn(this, (Option.__proto__ || Object.getPrototypeOf(Option)).call(this, props));
                return _this.handleMouseDown = _this.handleMouseDown.bind(_this), _this.handleMouseEnter = _this.handleMouseEnter.bind(_this), 
                _this.handleMouseMove = _this.handleMouseMove.bind(_this), _this.handleTouchStart = _this.handleTouchStart.bind(_this), 
                _this.handleTouchEnd = _this.handleTouchEnd.bind(_this), _this.handleTouchMove = _this.handleTouchMove.bind(_this), 
                _this.onFocus = _this.onFocus.bind(_this), _this;
            }
            return _inherits(Option, _React$Component), _createClass(Option, [ {
                key: "blockEvent",
                value: function(event) {
                    event.preventDefault(), event.stopPropagation(), "A" === event.target.tagName && "href" in event.target && (event.target.target ? window.open(event.target.href, event.target.target) : window.location.href = event.target.href);
                }
            }, {
                key: "handleMouseDown",
                value: function(event) {
                    event.preventDefault(), event.stopPropagation(), this.props.onSelect(this.props.option, event);
                }
            }, {
                key: "handleMouseEnter",
                value: function(event) {
                    this.onFocus(event);
                }
            }, {
                key: "handleMouseMove",
                value: function(event) {
                    this.onFocus(event);
                }
            }, {
                key: "handleTouchEnd",
                value: function(event) {
                    // Check if the view is being dragged, In this case
                    // we don't want to fire the click event (because the user only wants to scroll)
                    this.dragging || this.handleMouseDown(event);
                }
            }, {
                key: "handleTouchMove",
                value: function(event) {
                    // Set a flag that the view is being dragged
                    this.dragging = !0;
                }
            }, {
                key: "handleTouchStart",
                value: function(event) {
                    // Set a flag that the view is not being dragged
                    this.dragging = !1;
                }
            }, {
                key: "onFocus",
                value: function(event) {
                    this.props.isFocused || this.props.onFocus(this.props.option, event);
                }
            }, {
                key: "render",
                value: function() {
                    var _props = this.props, option = _props.option, instancePrefix = _props.instancePrefix, optionIndex = _props.optionIndex, className = (0, 
                    _classnames2.default)(this.props.className, option.className);
                    return option.disabled ? _react2.default.createElement("div", {
                        className: className,
                        onMouseDown: this.blockEvent,
                        onClick: this.blockEvent
                    }, this.props.children) : _react2.default.createElement("div", {
                        className: className,
                        style: option.style,
                        role: "option",
                        onMouseDown: this.handleMouseDown,
                        onMouseEnter: this.handleMouseEnter,
                        onMouseMove: this.handleMouseMove,
                        onTouchStart: this.handleTouchStart,
                        onTouchMove: this.handleTouchMove,
                        onTouchEnd: this.handleTouchEnd,
                        id: instancePrefix + "-option-" + optionIndex,
                        title: option.title
                    }, this.props.children);
                }
            } ]), Option;
        }(_react2.default.Component);
        Option.propTypes = {
            children: _propTypes2.default.node,
            className: _propTypes2.default.string,
            // className (based on mouse position)
            instancePrefix: _propTypes2.default.string.isRequired,
            // unique prefix for the ids (used for aria)
            isDisabled: _propTypes2.default.bool,
            // the option is disabled
            isFocused: _propTypes2.default.bool,
            // the option is focused
            isSelected: _propTypes2.default.bool,
            // the option is selected
            onFocus: _propTypes2.default.func,
            // method to handle mouseEnter on option element
            onSelect: _propTypes2.default.func,
            // method to handle click on option element
            onUnfocus: _propTypes2.default.func,
            // method to handle mouseLeave on option element
            option: _propTypes2.default.object.isRequired,
            // object that is base for that option
            optionIndex: _propTypes2.default.number
        }, exports.default = Option;
    }, /* 156 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }(), _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _propTypes = __webpack_require__(109), _propTypes2 = _interopRequireDefault(_propTypes), _classnames = __webpack_require__(121), _classnames2 = _interopRequireDefault(_classnames), Value = function(_React$Component) {
            function Value(props) {
                _classCallCheck(this, Value);
                var _this = _possibleConstructorReturn(this, (Value.__proto__ || Object.getPrototypeOf(Value)).call(this, props));
                return _this.handleMouseDown = _this.handleMouseDown.bind(_this), _this.onRemove = _this.onRemove.bind(_this), 
                _this.handleTouchEndRemove = _this.handleTouchEndRemove.bind(_this), _this.handleTouchMove = _this.handleTouchMove.bind(_this), 
                _this.handleTouchStart = _this.handleTouchStart.bind(_this), _this;
            }
            return _inherits(Value, _React$Component), _createClass(Value, [ {
                key: "handleMouseDown",
                value: function(event) {
                    if ("mousedown" !== event.type || 0 === event.button) return this.props.onClick ? (event.stopPropagation(), 
                    void this.props.onClick(this.props.value, event)) : void (this.props.value.href && event.stopPropagation());
                }
            }, {
                key: "onRemove",
                value: function(event) {
                    event.preventDefault(), event.stopPropagation(), this.props.onRemove(this.props.value);
                }
            }, {
                key: "handleTouchEndRemove",
                value: function(event) {
                    // Check if the view is being dragged, In this case
                    // we don't want to fire the click event (because the user only wants to scroll)
                    this.dragging || // Fire the mouse events
                    this.onRemove(event);
                }
            }, {
                key: "handleTouchMove",
                value: function(event) {
                    // Set a flag that the view is being dragged
                    this.dragging = !0;
                }
            }, {
                key: "handleTouchStart",
                value: function(event) {
                    // Set a flag that the view is not being dragged
                    this.dragging = !1;
                }
            }, {
                key: "renderRemoveIcon",
                value: function() {
                    if (!this.props.disabled && this.props.onRemove) return _react2.default.createElement("span", {
                        className: "Select-value-icon",
                        "aria-hidden": "true",
                        onMouseDown: this.onRemove,
                        onTouchEnd: this.handleTouchEndRemove,
                        onTouchStart: this.handleTouchStart,
                        onTouchMove: this.handleTouchMove
                    }, "×");
                }
            }, {
                key: "renderLabel",
                value: function() {
                    var className = "Select-value-label";
                    return this.props.onClick || this.props.value.href ? _react2.default.createElement("a", {
                        className: className,
                        href: this.props.value.href,
                        target: this.props.value.target,
                        onMouseDown: this.handleMouseDown,
                        onTouchEnd: this.handleMouseDown
                    }, this.props.children) : _react2.default.createElement("span", {
                        className: className,
                        role: "option",
                        "aria-selected": "true",
                        id: this.props.id
                    }, this.props.children);
                }
            }, {
                key: "render",
                value: function() {
                    return _react2.default.createElement("div", {
                        className: (0, _classnames2.default)("Select-value", this.props.value.className),
                        style: this.props.value.style,
                        title: this.props.value.title
                    }, this.renderRemoveIcon(), this.renderLabel());
                }
            } ]), Value;
        }(_react2.default.Component);
        Value.propTypes = {
            children: _propTypes2.default.node,
            disabled: _propTypes2.default.bool,
            // disabled prop passed to ReactSelect
            id: _propTypes2.default.string,
            // Unique id for the value - used for aria
            onClick: _propTypes2.default.func,
            // method to handle click on value label
            onRemove: _propTypes2.default.func,
            // method to handle removal of the value
            value: _propTypes2.default.object.isRequired
        }, exports.default = Value;
    }, /* 157 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        function defaultChildren(props) {
            return _react2.default.createElement(_Select2.default, props);
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        }, _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }(), _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _propTypes = __webpack_require__(109), _propTypes2 = _interopRequireDefault(_propTypes), _Select = __webpack_require__(148), _Select2 = _interopRequireDefault(_Select), _stripDiacritics = __webpack_require__(152), _stripDiacritics2 = _interopRequireDefault(_stripDiacritics), propTypes = {
            autoload: _propTypes2.default.bool.isRequired,
            // automatically call the `loadOptions` prop on-mount; defaults to true
            cache: _propTypes2.default.any,
            // object to use to cache results; set to null/false to disable caching
            children: _propTypes2.default.func.isRequired,
            // Child function responsible for creating the inner Select component; (props: Object): PropTypes.element
            ignoreAccents: _propTypes2.default.bool,
            // strip diacritics when filtering; defaults to true
            ignoreCase: _propTypes2.default.bool,
            // perform case-insensitive filtering; defaults to true
            loadOptions: _propTypes2.default.func.isRequired,
            // callback to load options asynchronously; (inputValue: string, callback: Function): ?Promise
            loadingPlaceholder: _propTypes2.default.oneOfType([ // replaces the placeholder while options are loading
            _propTypes2.default.string, _propTypes2.default.node ]),
            multi: _propTypes2.default.bool,
            // multi-value input
            noResultsText: _propTypes2.default.oneOfType([ // field noResultsText, displayed when no options come back from the server
            _propTypes2.default.string, _propTypes2.default.node ]),
            onChange: _propTypes2.default.func,
            // onChange handler: function (newValue) {}
            onInputChange: _propTypes2.default.func,
            // optional for keeping track of what is being typed
            options: _propTypes2.default.array.isRequired,
            // array of options
            placeholder: _propTypes2.default.oneOfType([ // field placeholder, displayed when there's no value (shared with Select)
            _propTypes2.default.string, _propTypes2.default.node ]),
            searchPromptText: _propTypes2.default.oneOfType([ // label to prompt for search input
            _propTypes2.default.string, _propTypes2.default.node ]),
            value: _propTypes2.default.any
        }, defaultCache = {}, defaultProps = {
            autoload: !0,
            cache: defaultCache,
            children: defaultChildren,
            ignoreAccents: !0,
            ignoreCase: !0,
            loadingPlaceholder: "Loading...",
            options: [],
            searchPromptText: "Type to search"
        }, Async = function(_Component) {
            function Async(props, context) {
                _classCallCheck(this, Async);
                var _this = _possibleConstructorReturn(this, (Async.__proto__ || Object.getPrototypeOf(Async)).call(this, props, context));
                return _this._cache = props.cache === defaultCache ? {} : props.cache, _this.state = {
                    inputValue: "",
                    isLoading: !1,
                    options: props.options
                }, _this.onInputChange = _this.onInputChange.bind(_this), _this;
            }
            return _inherits(Async, _Component), _createClass(Async, [ {
                key: "componentDidMount",
                value: function() {
                    var autoload = this.props.autoload;
                    autoload && this.loadOptions("");
                }
            }, {
                key: "componentWillReceiveProps",
                value: function(nextProps) {
                    nextProps.options !== this.props.options && this.setState({
                        options: nextProps.options
                    });
                }
            }, {
                key: "componentWillUnmount",
                value: function() {
                    this._callback = null;
                }
            }, {
                key: "loadOptions",
                value: function loadOptions(inputValue) {
                    var _this2 = this, loadOptions = this.props.loadOptions, cache = this._cache;
                    if (cache && Object.prototype.hasOwnProperty.call(cache, inputValue)) return void this.setState({
                        options: cache[inputValue]
                    });
                    var callback = function callback(error, data) {
                        if (callback === _this2._callback) {
                            _this2._callback = null;
                            var options = data && data.options || [];
                            cache && (cache[inputValue] = options), _this2.setState({
                                isLoading: !1,
                                options: options
                            });
                        }
                    };
                    // Ignore all but the most recent request
                    this._callback = callback;
                    var promise = loadOptions(inputValue, callback);
                    promise && promise.then(function(data) {
                        return callback(null, data);
                    }, function(error) {
                        return callback(error);
                    }), this._callback && !this.state.isLoading && this.setState({
                        isLoading: !0
                    });
                }
            }, {
                key: "onInputChange",
                value: function onInputChange(inputValue) {
                    var _props = this.props, ignoreAccents = _props.ignoreAccents, ignoreCase = _props.ignoreCase, onInputChange = _props.onInputChange, transformedInputValue = inputValue;
                    // Return the original input value to avoid modifying the user's view of the input while typing.
                    return ignoreAccents && (transformedInputValue = (0, _stripDiacritics2.default)(transformedInputValue)), 
                    ignoreCase && (transformedInputValue = transformedInputValue.toLowerCase()), onInputChange && onInputChange(transformedInputValue), 
                    this.setState({
                        inputValue: inputValue
                    }), this.loadOptions(transformedInputValue), inputValue;
                }
            }, {
                key: "noResultsText",
                value: function noResultsText() {
                    var _props2 = this.props, loadingPlaceholder = _props2.loadingPlaceholder, noResultsText = _props2.noResultsText, searchPromptText = _props2.searchPromptText, _state = this.state, inputValue = _state.inputValue, isLoading = _state.isLoading;
                    return isLoading ? loadingPlaceholder : inputValue && noResultsText ? noResultsText : searchPromptText;
                }
            }, {
                key: "focus",
                value: function() {
                    this.select.focus();
                }
            }, {
                key: "render",
                value: function() {
                    var _this3 = this, _props3 = this.props, children = _props3.children, loadingPlaceholder = _props3.loadingPlaceholder, placeholder = (_props3.multi, 
                    _props3.onChange, _props3.placeholder), _state2 = (_props3.value, this.state), isLoading = _state2.isLoading, options = _state2.options, props = {
                        noResultsText: this.noResultsText(),
                        placeholder: isLoading ? loadingPlaceholder : placeholder,
                        options: isLoading && loadingPlaceholder ? [] : options,
                        ref: function(_ref) {
                            return _this3.select = _ref;
                        }
                    };
                    return children(_extends({}, this.props, props, {
                        isLoading: isLoading,
                        onInputChange: this.onInputChange
                    }));
                }
            } ]), Async;
        }(_react.Component);
        exports.default = Async, Async.propTypes = propTypes, Async.defaultProps = defaultProps;
    }, /* 158 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        function reduce(obj) {
            var props = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            return Object.keys(obj).reduce(function(props, key) {
                var value = obj[key];
                return void 0 !== value && (props[key] = value), props;
            }, props);
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        }, _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }(), _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _Select = __webpack_require__(148), _Select2 = _interopRequireDefault(_Select), _Async = __webpack_require__(157), _Async2 = _interopRequireDefault(_Async), _Creatable = __webpack_require__(159), _Creatable2 = _interopRequireDefault(_Creatable), AsyncCreatableSelect = function(_React$Component) {
            function AsyncCreatableSelect() {
                return _classCallCheck(this, AsyncCreatableSelect), _possibleConstructorReturn(this, (AsyncCreatableSelect.__proto__ || Object.getPrototypeOf(AsyncCreatableSelect)).apply(this, arguments));
            }
            return _inherits(AsyncCreatableSelect, _React$Component), _createClass(AsyncCreatableSelect, [ {
                key: "focus",
                value: function() {
                    this.select.focus();
                }
            }, {
                key: "render",
                value: function() {
                    var _this2 = this;
                    return _react2.default.createElement(_Async2.default, this.props, function(asyncProps) {
                        return _react2.default.createElement(_Creatable2.default, _this2.props, function(creatableProps) {
                            return _react2.default.createElement(_Select2.default, _extends({}, reduce(asyncProps, reduce(creatableProps, {})), {
                                onInputChange: function(input) {
                                    return creatableProps.onInputChange(input), asyncProps.onInputChange(input);
                                },
                                ref: function(_ref) {
                                    _this2.select = _ref, creatableProps.ref(_ref), asyncProps.ref(_ref);
                                }
                            }));
                        });
                    });
                }
            } ]), AsyncCreatableSelect;
        }(_react2.default.Component);
        exports.default = AsyncCreatableSelect;
    }, /* 159 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _objectWithoutProperties(obj, keys) {
            var target = {};
            for (var i in obj) keys.indexOf(i) >= 0 || Object.prototype.hasOwnProperty.call(obj, i) && (target[i] = obj[i]);
            return target;
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        function defaultChildren(props) {
            return _react2.default.createElement(_Select2.default, props);
        }
        function isOptionUnique(_ref3) {
            var option = _ref3.option, options = _ref3.options, labelKey = _ref3.labelKey, valueKey = _ref3.valueKey;
            return 0 === options.filter(function(existingOption) {
                return existingOption[labelKey] === option[labelKey] || existingOption[valueKey] === option[valueKey];
            }).length;
        }
        function isValidNewOption(_ref4) {
            var label = _ref4.label;
            return !!label;
        }
        function newOptionCreator(_ref5) {
            var label = _ref5.label, labelKey = _ref5.labelKey, valueKey = _ref5.valueKey, option = {};
            return option[valueKey] = label, option[labelKey] = label, option.className = "Select-create-option-placeholder", 
            option;
        }
        function promptTextCreator(label) {
            return 'Create option "' + label + '"';
        }
        function shouldKeyDownEventCreateNewOption(_ref6) {
            var keyCode = _ref6.keyCode;
            switch (keyCode) {
              case 9:
              // TAB
                case 13:
              // ENTER
                case 188:
                // COMMA
                return !0;
            }
            return !1;
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        }, _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }(), _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _propTypes = __webpack_require__(109), _propTypes2 = _interopRequireDefault(_propTypes), _Select = __webpack_require__(148), _Select2 = _interopRequireDefault(_Select), _defaultFilterOptions = __webpack_require__(151), _defaultFilterOptions2 = _interopRequireDefault(_defaultFilterOptions), _defaultMenuRenderer = __webpack_require__(153), _defaultMenuRenderer2 = _interopRequireDefault(_defaultMenuRenderer), CreatableSelect = function(_React$Component) {
            function CreatableSelect(props, context) {
                _classCallCheck(this, CreatableSelect);
                var _this = _possibleConstructorReturn(this, (CreatableSelect.__proto__ || Object.getPrototypeOf(CreatableSelect)).call(this, props, context));
                return _this.filterOptions = _this.filterOptions.bind(_this), _this.menuRenderer = _this.menuRenderer.bind(_this), 
                _this.onInputKeyDown = _this.onInputKeyDown.bind(_this), _this.onInputChange = _this.onInputChange.bind(_this), 
                _this.onOptionSelect = _this.onOptionSelect.bind(_this), _this;
            }
            return _inherits(CreatableSelect, _React$Component), _createClass(CreatableSelect, [ {
                key: "createNewOption",
                value: function() {
                    var _props = this.props, isValidNewOption = _props.isValidNewOption, newOptionCreator = _props.newOptionCreator, onNewOptionClick = _props.onNewOptionClick, _props$options = _props.options, options = void 0 === _props$options ? [] : _props$options;
                    _props.shouldKeyDownEventCreateNewOption;
                    if (isValidNewOption({
                        label: this.inputValue
                    })) {
                        var option = newOptionCreator({
                            label: this.inputValue,
                            labelKey: this.labelKey,
                            valueKey: this.valueKey
                        }), _isOptionUnique = this.isOptionUnique({
                            option: option
                        });
                        // Don't add the same option twice.
                        _isOptionUnique && (onNewOptionClick ? onNewOptionClick(option) : (options.unshift(option), 
                        this.select.selectValue(option)));
                    }
                }
            }, {
                key: "filterOptions",
                value: function filterOptions() {
                    var _props2 = this.props, filterOptions = _props2.filterOptions, isValidNewOption = _props2.isValidNewOption, promptTextCreator = (_props2.options, 
                    _props2.promptTextCreator), excludeOptions = (arguments.length <= 2 ? void 0 : arguments[2]) || [], filteredOptions = filterOptions.apply(void 0, arguments) || [];
                    if (isValidNewOption({
                        label: this.inputValue
                    })) {
                        var _newOptionCreator = this.props.newOptionCreator, option = _newOptionCreator({
                            label: this.inputValue,
                            labelKey: this.labelKey,
                            valueKey: this.valueKey
                        }), _isOptionUnique2 = this.isOptionUnique({
                            option: option,
                            options: excludeOptions.concat(filteredOptions)
                        });
                        if (_isOptionUnique2) {
                            var prompt = promptTextCreator(this.inputValue);
                            this._createPlaceholderOption = _newOptionCreator({
                                label: prompt,
                                labelKey: this.labelKey,
                                valueKey: this.valueKey
                            }), filteredOptions.unshift(this._createPlaceholderOption);
                        }
                    }
                    return filteredOptions;
                }
            }, {
                key: "isOptionUnique",
                value: function isOptionUnique(_ref) {
                    var option = _ref.option, options = _ref.options, isOptionUnique = this.props.isOptionUnique;
                    return options = options || this.select.filterOptions(), isOptionUnique({
                        labelKey: this.labelKey,
                        option: option,
                        options: options,
                        valueKey: this.valueKey
                    });
                }
            }, {
                key: "menuRenderer",
                value: function menuRenderer(params) {
                    var menuRenderer = this.props.menuRenderer;
                    return menuRenderer(_extends({}, params, {
                        onSelect: this.onOptionSelect,
                        selectValue: this.onOptionSelect
                    }));
                }
            }, {
                key: "onInputChange",
                value: function onInputChange(input) {
                    var onInputChange = this.props.onInputChange;
                    onInputChange && onInputChange(input), // This value may be needed in between Select mounts (when this.select is null)
                    this.inputValue = input;
                }
            }, {
                key: "onInputKeyDown",
                value: function onInputKeyDown(event) {
                    var _props3 = this.props, shouldKeyDownEventCreateNewOption = _props3.shouldKeyDownEventCreateNewOption, onInputKeyDown = _props3.onInputKeyDown, focusedOption = this.select.getFocusedOption();
                    focusedOption && focusedOption === this._createPlaceholderOption && shouldKeyDownEventCreateNewOption({
                        keyCode: event.keyCode
                    }) ? (this.createNewOption(), // Prevent decorated Select from doing anything additional with this keyDown event
                    event.preventDefault()) : onInputKeyDown && onInputKeyDown(event);
                }
            }, {
                key: "onOptionSelect",
                value: function(option, event) {
                    option === this._createPlaceholderOption ? this.createNewOption() : this.select.selectValue(option);
                }
            }, {
                key: "focus",
                value: function() {
                    this.select.focus();
                }
            }, {
                key: "render",
                value: function() {
                    var _this2 = this, _props4 = this.props, restProps = (_props4.newOptionCreator, 
                    _props4.shouldKeyDownEventCreateNewOption, _objectWithoutProperties(_props4, [ "newOptionCreator", "shouldKeyDownEventCreateNewOption" ])), children = this.props.children;
                    // We can't use destructuring default values to set the children,
                    // because it won't apply work if `children` is null. A falsy check is
                    // more reliable in real world use-cases.
                    children || (children = defaultChildren);
                    var props = _extends({}, restProps, {
                        allowCreate: !0,
                        filterOptions: this.filterOptions,
                        menuRenderer: this.menuRenderer,
                        onInputChange: this.onInputChange,
                        onInputKeyDown: this.onInputKeyDown,
                        ref: function(_ref2) {
                            _this2.select = _ref2, // These values may be needed in between Select mounts (when this.select is null)
                            _ref2 && (_this2.labelKey = _ref2.props.labelKey, _this2.valueKey = _ref2.props.valueKey);
                        }
                    });
                    return children(props);
                }
            } ]), CreatableSelect;
        }(_react2.default.Component);
        // Default prop methods
        CreatableSelect.isOptionUnique = isOptionUnique, CreatableSelect.isValidNewOption = isValidNewOption, 
        CreatableSelect.newOptionCreator = newOptionCreator, CreatableSelect.promptTextCreator = promptTextCreator, 
        CreatableSelect.shouldKeyDownEventCreateNewOption = shouldKeyDownEventCreateNewOption, 
        CreatableSelect.defaultProps = {
            filterOptions: _defaultFilterOptions2.default,
            isOptionUnique: isOptionUnique,
            isValidNewOption: isValidNewOption,
            menuRenderer: _defaultMenuRenderer2.default,
            newOptionCreator: newOptionCreator,
            promptTextCreator: promptTextCreator,
            shouldKeyDownEventCreateNewOption: shouldKeyDownEventCreateNewOption
        }, CreatableSelect.propTypes = {
            // Child function responsible for creating the inner Select component
            // This component can be used to compose HOCs (eg Creatable and Async)
            // (props: Object): PropTypes.element
            children: _propTypes2.default.func,
            // See Select.propTypes.filterOptions
            filterOptions: _propTypes2.default.any,
            // Searches for any matching option within the set of options.
            // This function prevents duplicate options from being created.
            // ({ option: Object, options: Array, labelKey: string, valueKey: string }): boolean
            isOptionUnique: _propTypes2.default.func,
            // Determines if the current input text represents a valid option.
            // ({ label: string }): boolean
            isValidNewOption: _propTypes2.default.func,
            // See Select.propTypes.menuRenderer
            menuRenderer: _propTypes2.default.any,
            // Factory to create new option.
            // ({ label: string, labelKey: string, valueKey: string }): Object
            newOptionCreator: _propTypes2.default.func,
            // input change handler: function (inputValue) {}
            onInputChange: _propTypes2.default.func,
            // input keyDown handler: function (event) {}
            onInputKeyDown: _propTypes2.default.func,
            // new option click handler: function (option) {}
            onNewOptionClick: _propTypes2.default.func,
            // See Select.propTypes.options
            options: _propTypes2.default.array,
            // Creates prompt/placeholder option text.
            // (filterText: string): string
            promptTextCreator: _propTypes2.default.func,
            // Decides if a keyDown event (eg its `keyCode`) should result in the creation of a new option.
            shouldKeyDownEventCreateNewOption: _propTypes2.default.func
        }, exports.default = CreatableSelect;
    }, /* 160 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _AutoSizer = __webpack_require__(161);
        Object.defineProperty(exports, "default", {
            enumerable: !0,
            get: function() {
                return _interopRequireDefault(_AutoSizer).default;
            }
        }), Object.defineProperty(exports, "AutoSizer", {
            enumerable: !0,
            get: function() {
                return _interopRequireDefault(_AutoSizer).default;
            }
        });
    }, /* 161 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }(), _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _detectElementResize = __webpack_require__(162), _detectElementResize2 = _interopRequireDefault(_detectElementResize), AutoSizer = (__webpack_require__(163).babelPluginFlowReactPropTypes_proptype_Size || __webpack_require__(109).any, 
        function(_React$PureComponent) {
            function AutoSizer() {
                var _ref, _temp, _this, _ret;
                _classCallCheck(this, AutoSizer);
                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                return _temp = _this = _possibleConstructorReturn(this, (_ref = AutoSizer.__proto__ || Object.getPrototypeOf(AutoSizer)).call.apply(_ref, [ this ].concat(args))), 
                _this.state = {
                    height: 0,
                    width: 0
                }, _this._onResize = function() {
                    var _this$props = _this.props, disableHeight = _this$props.disableHeight, disableWidth = _this$props.disableWidth, onResize = _this$props.onResize;
                    if (_this._parentNode) {
                        // Guard against AutoSizer component being removed from the DOM immediately after being added.
                        // This can result in invalid style values which can result in NaN values if we don't handle them.
                        // See issue #150 for more context.
                        var height = _this._parentNode.offsetHeight || 0, width = _this._parentNode.offsetWidth || 0, style = window.getComputedStyle(_this._parentNode) || {}, paddingLeft = parseInt(style.paddingLeft, 10) || 0, paddingRight = parseInt(style.paddingRight, 10) || 0, paddingTop = parseInt(style.paddingTop, 10) || 0, paddingBottom = parseInt(style.paddingBottom, 10) || 0, newHeight = height - paddingTop - paddingBottom, newWidth = width - paddingLeft - paddingRight;
                        (!disableHeight && _this.state.height !== newHeight || !disableWidth && _this.state.width !== newWidth) && (_this.setState({
                            height: height - paddingTop - paddingBottom,
                            width: width - paddingLeft - paddingRight
                        }), onResize({
                            height: height,
                            width: width
                        }));
                    }
                }, _this._setRef = function(autoSizer) {
                    _this._autoSizer = autoSizer;
                }, _ret = _temp, _possibleConstructorReturn(_this, _ret);
            }
            return _inherits(AutoSizer, _React$PureComponent), _createClass(AutoSizer, [ {
                key: "componentDidMount",
                value: function() {
                    var nonce = this.props.nonce;
                    this._autoSizer && this._autoSizer.parentNode instanceof HTMLElement && (// Delay access of parentNode until mount.
                    // This handles edge-cases where the component has already been unmounted before its ref has been set,
                    // As well as libraries like react-lite which have a slightly different lifecycle.
                    this._parentNode = this._autoSizer.parentNode, // Defer requiring resize handler in order to support server-side rendering.
                    // See issue #41
                    this._detectElementResize = (0, _detectElementResize2.default)(nonce), this._detectElementResize.addResizeListener(this._parentNode, this._onResize), 
                    this._onResize());
                }
            }, {
                key: "componentWillUnmount",
                value: function() {
                    this._detectElementResize && this._parentNode && this._detectElementResize.removeResizeListener(this._parentNode, this._onResize);
                }
            }, {
                key: "render",
                value: function() {
                    var _props = this.props, children = _props.children, disableHeight = _props.disableHeight, disableWidth = _props.disableWidth, _state = this.state, height = _state.height, width = _state.width, outerStyle = {
                        overflow: "visible"
                    };
                    /**
	       * TODO: Avoid rendering children before the initial measurements have been collected.
	       * At best this would just be wasting cycles.
	       * Add this check into version 10 though as it could break too many ref callbacks in version 9.
	      if (
	        height !== 0 &&
	        width !== 0
	      ) {
	        child = children({ height, width })
	      }
	      */
                    return disableHeight || (outerStyle.height = 0), disableWidth || (outerStyle.width = 0), 
                    _react2.default.createElement("div", {
                        ref: this._setRef,
                        style: outerStyle
                    }, children({
                        height: height,
                        width: width
                    }));
                }
            } ]), AutoSizer;
        }(_react2.default.PureComponent));
        AutoSizer.defaultProps = {
            onResize: function() {},
            disableHeight: !1,
            disableWidth: !1
        }, AutoSizer.propTypes = {
            children: __webpack_require__(109).func.isRequired,
            disableHeight: __webpack_require__(109).bool.isRequired,
            disableWidth: __webpack_require__(109).bool.isRequired,
            nonce: __webpack_require__(109).string,
            onResize: __webpack_require__(109).func.isRequired
        }, exports.default = AutoSizer;
    }, /* 162 */
    /***/
    function(module, exports) {
        "use strict";
        /**
	 * Detect Element Resize.
	 * https://github.com/sdecima/javascript-detect-element-resize
	 * Sebastian Decima
	 *
	 * Forked from version 0.5.3; includes the following modifications:
	 * 1) Guard against unsafe 'window' and 'document' references (to support SSR).
	 * 2) Defer initialization code via a top-level function wrapper (to support SSR).
	 * 3) Avoid unnecessary reflows by not measuring size for scroll events bubbling from children.
	 * 4) Add nonce for style element.
	 **/
        function createDetectElementResize(nonce) {
            // Check `document` and `window` in case of server-side rendering
            var _window;
            _window = "undefined" != typeof window ? window : "undefined" != typeof self ? self : this;
            var attachEvent = "undefined" != typeof document && document.attachEvent;
            if (!attachEvent) {
                var requestFrame = function() {
                    var raf = _window.requestAnimationFrame || _window.mozRequestAnimationFrame || _window.webkitRequestAnimationFrame || function(fn) {
                        return _window.setTimeout(fn, 20);
                    };
                    return function(fn) {
                        return raf(fn);
                    };
                }(), cancelFrame = function() {
                    var cancel = _window.cancelAnimationFrame || _window.mozCancelAnimationFrame || _window.webkitCancelAnimationFrame || _window.clearTimeout;
                    return function(id) {
                        return cancel(id);
                    };
                }(), resetTriggers = function(element) {
                    var triggers = element.__resizeTriggers__, expand = triggers.firstElementChild, contract = triggers.lastElementChild, expandChild = expand.firstElementChild;
                    contract.scrollLeft = contract.scrollWidth, contract.scrollTop = contract.scrollHeight, 
                    expandChild.style.width = expand.offsetWidth + 1 + "px", expandChild.style.height = expand.offsetHeight + 1 + "px", 
                    expand.scrollLeft = expand.scrollWidth, expand.scrollTop = expand.scrollHeight;
                }, checkTriggers = function(element) {
                    return element.offsetWidth != element.__resizeLast__.width || element.offsetHeight != element.__resizeLast__.height;
                }, scrollListener = function(e) {
                    // Don't measure (which forces) reflow for scrolls that happen inside of children!
                    if (!(e.target.className.indexOf("contract-trigger") < 0 && e.target.className.indexOf("expand-trigger") < 0)) {
                        var element = this;
                        resetTriggers(this), this.__resizeRAF__ && cancelFrame(this.__resizeRAF__), this.__resizeRAF__ = requestFrame(function() {
                            checkTriggers(element) && (element.__resizeLast__.width = element.offsetWidth, element.__resizeLast__.height = element.offsetHeight, 
                            element.__resizeListeners__.forEach(function(fn) {
                                fn.call(element, e);
                            }));
                        });
                    }
                }, animation = !1, keyframeprefix = "", animationstartevent = "animationstart", domPrefixes = "Webkit Moz O ms".split(" "), startEvents = "webkitAnimationStart animationstart oAnimationStart MSAnimationStart".split(" "), pfx = "", elm = document.createElement("fakeelement");
                if (void 0 !== elm.style.animationName && (animation = !0), animation === !1) for (var i = 0; i < domPrefixes.length; i++) if (void 0 !== elm.style[domPrefixes[i] + "AnimationName"]) {
                    pfx = domPrefixes[i], keyframeprefix = "-" + pfx.toLowerCase() + "-", animationstartevent = startEvents[i], 
                    animation = !0;
                    break;
                }
                var animationName = "resizeanim", animationKeyframes = "@" + keyframeprefix + "keyframes " + animationName + " { from { opacity: 0; } to { opacity: 0; } } ", animationStyle = keyframeprefix + "animation: 1ms " + animationName + "; ";
            }
            var createStyles = function() {
                if (!document.getElementById("detectElementResize")) {
                    //opacity:0 works around a chrome bug https://code.google.com/p/chromium/issues/detail?id=286360
                    var css = (animationKeyframes ? animationKeyframes : "") + ".resize-triggers { " + (animationStyle ? animationStyle : "") + 'visibility: hidden; opacity: 0; } .resize-triggers, .resize-triggers > div, .contract-trigger:before { content: " "; display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; z-index: -1; } .resize-triggers > div { background: #eee; overflow: auto; } .contract-trigger:before { width: 200%; height: 200%; }', head = document.head || document.getElementsByTagName("head")[0], style = document.createElement("style");
                    style.id = "detectElementResize", style.type = "text/css", null != nonce && style.setAttribute("nonce", nonce), 
                    style.styleSheet ? style.styleSheet.cssText = css : style.appendChild(document.createTextNode(css)), 
                    head.appendChild(style);
                }
            }, addResizeListener = function(element, fn) {
                if (attachEvent) element.attachEvent("onresize", fn); else {
                    if (!element.__resizeTriggers__) {
                        var elementStyle = _window.getComputedStyle(element);
                        elementStyle && "static" == elementStyle.position && (element.style.position = "relative"), 
                        createStyles(), element.__resizeLast__ = {}, element.__resizeListeners__ = [], (element.__resizeTriggers__ = document.createElement("div")).className = "resize-triggers", 
                        element.__resizeTriggers__.innerHTML = '<div class="expand-trigger"><div></div></div><div class="contract-trigger"></div>', 
                        element.appendChild(element.__resizeTriggers__), resetTriggers(element), element.addEventListener("scroll", scrollListener, !0), 
                        /* Listen for a css animation to detect element display/re-attach */
                        animationstartevent && (element.__resizeTriggers__.__animationListener__ = function(e) {
                            e.animationName == animationName && resetTriggers(element);
                        }, element.__resizeTriggers__.addEventListener(animationstartevent, element.__resizeTriggers__.__animationListener__));
                    }
                    element.__resizeListeners__.push(fn);
                }
            }, removeResizeListener = function(element, fn) {
                if (attachEvent) element.detachEvent("onresize", fn); else if (element.__resizeListeners__.splice(element.__resizeListeners__.indexOf(fn), 1), 
                !element.__resizeListeners__.length) {
                    element.removeEventListener("scroll", scrollListener, !0), element.__resizeTriggers__.__animationListener__ && (element.__resizeTriggers__.removeEventListener(animationstartevent, element.__resizeTriggers__.__animationListener__), 
                    element.__resizeTriggers__.__animationListener__ = null);
                    try {
                        element.__resizeTriggers__ = !element.removeChild(element.__resizeTriggers__);
                    } catch (e) {}
                }
            };
            return {
                addResizeListener: addResizeListener,
                removeResizeListener: removeResizeListener
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = createDetectElementResize;
    }, /* 163 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "babelPluginFlowReactPropTypes_proptype_Size", {
            value: {
                height: __webpack_require__(109).number.isRequired,
                width: __webpack_require__(109).number.isRequired
            },
            configurable: !0
        });
    }, /* 164 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _List = __webpack_require__(165);
        Object.defineProperty(exports, "default", {
            enumerable: !0,
            get: function() {
                return _interopRequireDefault(_List).default;
            }
        }), Object.defineProperty(exports, "List", {
            enumerable: !0,
            get: function() {
                return _interopRequireDefault(_List).default;
            }
        });
    }, /* 165 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        }, _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }(), _Grid = __webpack_require__(166), _Grid2 = _interopRequireDefault(_Grid), _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _classnames = __webpack_require__(121), _classnames2 = _interopRequireDefault(_classnames), babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetter = (__webpack_require__(166).babelPluginFlowReactPropTypes_proptype_Scroll || __webpack_require__(109).any, 
        __webpack_require__(166).babelPluginFlowReactPropTypes_proptype_CellRendererParams || __webpack_require__(109).any, 
        __webpack_require__(166).babelPluginFlowReactPropTypes_proptype_RenderedSection || __webpack_require__(109).any, 
        __webpack_require__(166).babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetter || __webpack_require__(109).any), babelPluginFlowReactPropTypes_proptype_CellSize = (__webpack_require__(166).babelPluginFlowReactPropTypes_proptype_CellPosition || __webpack_require__(109).any, 
        __webpack_require__(166).babelPluginFlowReactPropTypes_proptype_CellSize || __webpack_require__(109).any), babelPluginFlowReactPropTypes_proptype_Alignment = __webpack_require__(166).babelPluginFlowReactPropTypes_proptype_Alignment || __webpack_require__(109).any, babelPluginFlowReactPropTypes_proptype_NoContentRenderer = __webpack_require__(166).babelPluginFlowReactPropTypes_proptype_NoContentRenderer || __webpack_require__(109).any, babelPluginFlowReactPropTypes_proptype_RowRenderer = (__webpack_require__(181).babelPluginFlowReactPropTypes_proptype_Scroll || __webpack_require__(109).any, 
        __webpack_require__(181).babelPluginFlowReactPropTypes_proptype_RenderedRows || __webpack_require__(109).any, 
        __webpack_require__(181).babelPluginFlowReactPropTypes_proptype_RowRenderer || __webpack_require__(109).any), List = function(_React$PureComponent) {
            function List() {
                var _ref, _temp, _this, _ret;
                _classCallCheck(this, List);
                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                return _temp = _this = _possibleConstructorReturn(this, (_ref = List.__proto__ || Object.getPrototypeOf(List)).call.apply(_ref, [ this ].concat(args))), 
                _this._cellRenderer = function(_ref2) {
                    var rowIndex = _ref2.rowIndex, style = _ref2.style, isScrolling = _ref2.isScrolling, isVisible = _ref2.isVisible, key = _ref2.key, rowRenderer = _this.props.rowRenderer, _Object$getOwnPropert = Object.getOwnPropertyDescriptor(style, "width"), writable = _Object$getOwnPropert.writable;
                    // By default, List cells should be 100% width.
                    // This prevents them from flowing under a scrollbar (if present).
                    return writable && (style.width = "100%"), rowRenderer({
                        index: rowIndex,
                        style: style,
                        isScrolling: isScrolling,
                        isVisible: isVisible,
                        key: key,
                        parent: _this
                    });
                }, _this._setRef = function(ref) {
                    _this.Grid = ref;
                }, _this._onScroll = function(_ref3) {
                    var clientHeight = _ref3.clientHeight, scrollHeight = _ref3.scrollHeight, scrollTop = _ref3.scrollTop, onScroll = _this.props.onScroll;
                    onScroll({
                        clientHeight: clientHeight,
                        scrollHeight: scrollHeight,
                        scrollTop: scrollTop
                    });
                }, _this._onSectionRendered = function(_ref4) {
                    var rowOverscanStartIndex = _ref4.rowOverscanStartIndex, rowOverscanStopIndex = _ref4.rowOverscanStopIndex, rowStartIndex = _ref4.rowStartIndex, rowStopIndex = _ref4.rowStopIndex, onRowsRendered = _this.props.onRowsRendered;
                    onRowsRendered({
                        overscanStartIndex: rowOverscanStartIndex,
                        overscanStopIndex: rowOverscanStopIndex,
                        startIndex: rowStartIndex,
                        stopIndex: rowStopIndex
                    });
                }, _ret = _temp, _possibleConstructorReturn(_this, _ret);
            }
            return _inherits(List, _React$PureComponent), _createClass(List, [ {
                key: "forceUpdateGrid",
                value: function() {
                    this.Grid && this.Grid.forceUpdate();
                }
            }, {
                key: "getOffsetForRow",
                value: function(_ref5) {
                    var alignment = _ref5.alignment, index = _ref5.index;
                    if (this.Grid) {
                        var _Grid$getOffsetForCel = this.Grid.getOffsetForCell({
                            alignment: alignment,
                            rowIndex: index,
                            columnIndex: 0
                        }), _scrollTop = _Grid$getOffsetForCel.scrollTop;
                        return _scrollTop;
                    }
                    return 0;
                }
            }, {
                key: "invalidateCellSizeAfterRender",
                value: function(_ref6) {
                    var columnIndex = _ref6.columnIndex, rowIndex = _ref6.rowIndex;
                    this.Grid && this.Grid.invalidateCellSizeAfterRender({
                        rowIndex: rowIndex,
                        columnIndex: columnIndex
                    });
                }
            }, {
                key: "measureAllRows",
                value: function() {
                    this.Grid && this.Grid.measureAllCells();
                }
            }, {
                key: "recomputeGridSize",
                value: function() {
                    var _ref7 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, _ref7$columnIndex = _ref7.columnIndex, columnIndex = void 0 === _ref7$columnIndex ? 0 : _ref7$columnIndex, _ref7$rowIndex = _ref7.rowIndex, rowIndex = void 0 === _ref7$rowIndex ? 0 : _ref7$rowIndex;
                    this.Grid && this.Grid.recomputeGridSize({
                        rowIndex: rowIndex,
                        columnIndex: columnIndex
                    });
                }
            }, {
                key: "recomputeRowHeights",
                value: function() {
                    var index = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                    this.Grid && this.Grid.recomputeGridSize({
                        rowIndex: index,
                        columnIndex: 0
                    });
                }
            }, {
                key: "scrollToPosition",
                value: function() {
                    var scrollTop = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                    this.Grid && this.Grid.scrollToPosition({
                        scrollTop: scrollTop
                    });
                }
            }, {
                key: "scrollToRow",
                value: function() {
                    var index = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                    this.Grid && this.Grid.scrollToCell({
                        columnIndex: 0,
                        rowIndex: index
                    });
                }
            }, {
                key: "render",
                value: function() {
                    var _props = this.props, className = _props.className, noRowsRenderer = _props.noRowsRenderer, scrollToIndex = _props.scrollToIndex, width = _props.width, classNames = (0, 
                    _classnames2.default)("ReactVirtualized__List", className);
                    return _react2.default.createElement(_Grid2.default, _extends({}, this.props, {
                        autoContainerWidth: !0,
                        cellRenderer: this._cellRenderer,
                        className: classNames,
                        columnWidth: width,
                        columnCount: 1,
                        noContentRenderer: noRowsRenderer,
                        onScroll: this._onScroll,
                        onSectionRendered: this._onSectionRendered,
                        ref: this._setRef,
                        scrollToRow: scrollToIndex
                    }));
                }
            } ]), List;
        }(_react2.default.PureComponent);
        List.defaultProps = {
            autoHeight: !1,
            estimatedRowSize: 30,
            onScroll: function() {},
            noRowsRenderer: function() {
                return null;
            },
            onRowsRendered: function() {},
            overscanIndicesGetter: _Grid.accessibilityOverscanIndicesGetter,
            overscanRowCount: 10,
            scrollToAlignment: "auto",
            scrollToIndex: -1,
            style: {}
        }, List.propTypes = {
            "aria-label": __webpack_require__(109).string,
            autoHeight: __webpack_require__(109).bool.isRequired,
            className: __webpack_require__(109).string,
            estimatedRowSize: __webpack_require__(109).number.isRequired,
            height: __webpack_require__(109).number.isRequired,
            noRowsRenderer: "function" == typeof babelPluginFlowReactPropTypes_proptype_NoContentRenderer ? babelPluginFlowReactPropTypes_proptype_NoContentRenderer.isRequired ? babelPluginFlowReactPropTypes_proptype_NoContentRenderer.isRequired : babelPluginFlowReactPropTypes_proptype_NoContentRenderer : __webpack_require__(109).shape(babelPluginFlowReactPropTypes_proptype_NoContentRenderer).isRequired,
            onRowsRendered: __webpack_require__(109).func.isRequired,
            onScroll: __webpack_require__(109).func.isRequired,
            overscanIndicesGetter: "function" == typeof babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetter ? babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetter.isRequired ? babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetter.isRequired : babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetter : __webpack_require__(109).shape(babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetter).isRequired,
            overscanRowCount: __webpack_require__(109).number.isRequired,
            rowHeight: "function" == typeof babelPluginFlowReactPropTypes_proptype_CellSize ? babelPluginFlowReactPropTypes_proptype_CellSize.isRequired ? babelPluginFlowReactPropTypes_proptype_CellSize.isRequired : babelPluginFlowReactPropTypes_proptype_CellSize : __webpack_require__(109).shape(babelPluginFlowReactPropTypes_proptype_CellSize).isRequired,
            rowRenderer: "function" == typeof babelPluginFlowReactPropTypes_proptype_RowRenderer ? babelPluginFlowReactPropTypes_proptype_RowRenderer.isRequired ? babelPluginFlowReactPropTypes_proptype_RowRenderer.isRequired : babelPluginFlowReactPropTypes_proptype_RowRenderer : __webpack_require__(109).shape(babelPluginFlowReactPropTypes_proptype_RowRenderer).isRequired,
            rowCount: __webpack_require__(109).number.isRequired,
            scrollToAlignment: "function" == typeof babelPluginFlowReactPropTypes_proptype_Alignment ? babelPluginFlowReactPropTypes_proptype_Alignment.isRequired ? babelPluginFlowReactPropTypes_proptype_Alignment.isRequired : babelPluginFlowReactPropTypes_proptype_Alignment : __webpack_require__(109).shape(babelPluginFlowReactPropTypes_proptype_Alignment).isRequired,
            scrollToIndex: __webpack_require__(109).number.isRequired,
            scrollTop: __webpack_require__(109).number,
            style: __webpack_require__(109).object.isRequired,
            tabIndex: __webpack_require__(109).number,
            width: __webpack_require__(109).number.isRequired
        }, exports.default = List;
    }, /* 166 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _Grid = __webpack_require__(167);
        Object.defineProperty(exports, "default", {
            enumerable: !0,
            get: function() {
                return _interopRequireDefault(_Grid).default;
            }
        }), Object.defineProperty(exports, "Grid", {
            enumerable: !0,
            get: function() {
                return _interopRequireDefault(_Grid).default;
            }
        });
        var _accessibilityOverscanIndicesGetter = __webpack_require__(180);
        Object.defineProperty(exports, "accessibilityOverscanIndicesGetter", {
            enumerable: !0,
            get: function() {
                return _interopRequireDefault(_accessibilityOverscanIndicesGetter).default;
            }
        });
        var _defaultCellRangeRenderer = __webpack_require__(175);
        Object.defineProperty(exports, "defaultCellRangeRenderer", {
            enumerable: !0,
            get: function() {
                return _interopRequireDefault(_defaultCellRangeRenderer).default;
            }
        });
        var _defaultOverscanIndicesGetter = __webpack_require__(173);
        Object.defineProperty(exports, "defaultOverscanIndicesGetter", {
            enumerable: !0,
            get: function() {
                return _interopRequireDefault(_defaultOverscanIndicesGetter).default;
            }
        });
    }, /* 167 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _objectDestructuringEmpty(obj) {
            if (null == obj) throw new TypeError("Cannot destructure undefined");
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.DEFAULT_SCROLLING_RESET_TIME_INTERVAL = void 0;
        var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        }, _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }(), _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _classnames = __webpack_require__(121), _classnames2 = _interopRequireDefault(_classnames), _calculateSizeAndPositionDataAndUpdateScrollOffset = __webpack_require__(168), _calculateSizeAndPositionDataAndUpdateScrollOffset2 = _interopRequireDefault(_calculateSizeAndPositionDataAndUpdateScrollOffset), _ScalingCellSizeAndPositionManager = __webpack_require__(169), _ScalingCellSizeAndPositionManager2 = _interopRequireDefault(_ScalingCellSizeAndPositionManager), _createCallbackMemoizer = __webpack_require__(172), _createCallbackMemoizer2 = _interopRequireDefault(_createCallbackMemoizer), _defaultOverscanIndicesGetter = __webpack_require__(173), _defaultOverscanIndicesGetter2 = _interopRequireDefault(_defaultOverscanIndicesGetter), _updateScrollIndexHelper = __webpack_require__(174), _updateScrollIndexHelper2 = _interopRequireDefault(_updateScrollIndexHelper), _defaultCellRangeRenderer = __webpack_require__(175), _defaultCellRangeRenderer2 = _interopRequireDefault(_defaultCellRangeRenderer), _scrollbarSize = __webpack_require__(176), _scrollbarSize2 = _interopRequireDefault(_scrollbarSize), _requestAnimationTimeout = __webpack_require__(178), babelPluginFlowReactPropTypes_proptype_Alignment = __webpack_require__(171).babelPluginFlowReactPropTypes_proptype_Alignment || __webpack_require__(109).any, babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetter = __webpack_require__(171).babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetter || __webpack_require__(109).any, babelPluginFlowReactPropTypes_proptype_NoContentRenderer = (__webpack_require__(171).babelPluginFlowReactPropTypes_proptype_RenderedSection || __webpack_require__(109).any, 
        __webpack_require__(171).babelPluginFlowReactPropTypes_proptype_ScrollbarPresenceChange || __webpack_require__(109).any, 
        __webpack_require__(171).babelPluginFlowReactPropTypes_proptype_Scroll || __webpack_require__(109).any, 
        __webpack_require__(171).babelPluginFlowReactPropTypes_proptype_NoContentRenderer || __webpack_require__(109).any), babelPluginFlowReactPropTypes_proptype_CellSize = (__webpack_require__(171).babelPluginFlowReactPropTypes_proptype_CellSizeGetter || __webpack_require__(109).any, 
        __webpack_require__(171).babelPluginFlowReactPropTypes_proptype_CellSize || __webpack_require__(109).any), babelPluginFlowReactPropTypes_proptype_CellRangeRenderer = (__webpack_require__(171).babelPluginFlowReactPropTypes_proptype_CellPosition || __webpack_require__(109).any, 
        __webpack_require__(171).babelPluginFlowReactPropTypes_proptype_CellRangeRenderer || __webpack_require__(109).any), babelPluginFlowReactPropTypes_proptype_CellRenderer = __webpack_require__(171).babelPluginFlowReactPropTypes_proptype_CellRenderer || __webpack_require__(109).any, DEFAULT_SCROLLING_RESET_TIME_INTERVAL = (__webpack_require__(178).babelPluginFlowReactPropTypes_proptype_AnimationTimeoutId || __webpack_require__(109).any, 
        exports.DEFAULT_SCROLLING_RESET_TIME_INTERVAL = 150), SCROLL_POSITION_CHANGE_REASONS = {
            OBSERVED: "observed",
            REQUESTED: "requested"
        }, renderNull = function() {
            return null;
        }, Grid = function(_React$PureComponent) {
            // Invokes onSectionRendered callback only when start/stop row or column indices change
            function Grid(props) {
                _classCallCheck(this, Grid);
                var _this = _possibleConstructorReturn(this, (Grid.__proto__ || Object.getPrototypeOf(Grid)).call(this, props));
                _this.state = {
                    isScrolling: !1,
                    scrollDirectionHorizontal: _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD,
                    scrollDirectionVertical: _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD,
                    scrollLeft: 0,
                    scrollTop: 0
                }, _this._onGridRenderedMemoizer = (0, _createCallbackMemoizer2.default)(), _this._onScrollMemoizer = (0, 
                _createCallbackMemoizer2.default)(!1), _this._deferredInvalidateColumnIndex = null, 
                _this._deferredInvalidateRowIndex = null, _this._recomputeScrollLeftFlag = !1, _this._recomputeScrollTopFlag = !1, 
                _this._horizontalScrollBarSize = 0, _this._verticalScrollBarSize = 0, _this._scrollbarPresenceChanged = !1, 
                _this._cellCache = {}, _this._styleCache = {}, _this._scrollbarSizeMeasured = !1, 
                _this._renderedColumnStartIndex = 0, _this._renderedColumnStopIndex = 0, _this._renderedRowStartIndex = 0, 
                _this._renderedRowStopIndex = 0, _this._debounceScrollEndedCallback = function() {
                    _this._disablePointerEventsTimeoutId = null, _this._resetStyleCache();
                }, _this._invokeOnGridRenderedHelper = function() {
                    var onSectionRendered = _this.props.onSectionRendered;
                    _this._onGridRenderedMemoizer({
                        callback: onSectionRendered,
                        indices: {
                            columnOverscanStartIndex: _this._columnStartIndex,
                            columnOverscanStopIndex: _this._columnStopIndex,
                            columnStartIndex: _this._renderedColumnStartIndex,
                            columnStopIndex: _this._renderedColumnStopIndex,
                            rowOverscanStartIndex: _this._rowStartIndex,
                            rowOverscanStopIndex: _this._rowStopIndex,
                            rowStartIndex: _this._renderedRowStartIndex,
                            rowStopIndex: _this._renderedRowStopIndex
                        }
                    });
                }, _this._setScrollingContainerRef = function(ref) {
                    _this._scrollingContainer = ref;
                }, _this._onScroll = function(event) {
                    // In certain edge-cases React dispatches an onScroll event with an invalid target.scrollLeft / target.scrollTop.
                    // This invalid event can be detected by comparing event.target to this component's scrollable DOM element.
                    // See issue #404 for more information.
                    event.target === _this._scrollingContainer && _this.handleScrollEvent(event.target);
                }, _this._columnWidthGetter = _this._wrapSizeGetter(props.columnWidth), _this._rowHeightGetter = _this._wrapSizeGetter(props.rowHeight);
                var deferredMeasurementCache = props.deferredMeasurementCache;
                return _this._columnSizeAndPositionManager = new _ScalingCellSizeAndPositionManager2.default({
                    batchAllCells: void 0 !== deferredMeasurementCache && !deferredMeasurementCache.hasFixedHeight(),
                    cellCount: props.columnCount,
                    cellSizeGetter: function(params) {
                        return _this._columnWidthGetter(params);
                    },
                    estimatedCellSize: _this._getEstimatedColumnSize(props)
                }), _this._rowSizeAndPositionManager = new _ScalingCellSizeAndPositionManager2.default({
                    batchAllCells: void 0 !== deferredMeasurementCache && !deferredMeasurementCache.hasFixedWidth(),
                    cellCount: props.rowCount,
                    cellSizeGetter: function(params) {
                        return _this._rowHeightGetter(params);
                    },
                    estimatedCellSize: _this._getEstimatedRowSize(props)
                }), _this;
            }
            /**
	   * Gets offsets for a given cell and alignment.
	   */
            // See defaultCellRangeRenderer() for more information on the usage of these caches
            return _inherits(Grid, _React$PureComponent), _createClass(Grid, [ {
                key: "getOffsetForCell",
                value: function() {
                    var _ref = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, _ref$alignment = _ref.alignment, alignment = void 0 === _ref$alignment ? this.props.scrollToAlignment : _ref$alignment, _ref$columnIndex = _ref.columnIndex, columnIndex = void 0 === _ref$columnIndex ? this.props.scrollToColumn : _ref$columnIndex, _ref$rowIndex = _ref.rowIndex, rowIndex = void 0 === _ref$rowIndex ? this.props.scrollToRow : _ref$rowIndex, offsetProps = _extends({}, this.props, {
                        scrollToAlignment: alignment,
                        scrollToColumn: columnIndex,
                        scrollToRow: rowIndex
                    });
                    return {
                        scrollLeft: this._getCalculatedScrollLeft(offsetProps),
                        scrollTop: this._getCalculatedScrollTop(offsetProps)
                    };
                }
            }, {
                key: "handleScrollEvent",
                value: function(_ref2) {
                    var _ref2$scrollLeft = _ref2.scrollLeft, scrollLeftParam = void 0 === _ref2$scrollLeft ? 0 : _ref2$scrollLeft, _ref2$scrollTop = _ref2.scrollTop, scrollTopParam = void 0 === _ref2$scrollTop ? 0 : _ref2$scrollTop;
                    // On iOS, we can arrive at negative offsets by swiping past the start.
                    // To prevent flicker here, we make playing in the negative offset zone cause nothing to happen.
                    if (!(scrollTopParam < 0)) {
                        // Prevent pointer events from interrupting a smooth scroll
                        this._debounceScrollEnded();
                        var _props = this.props, autoHeight = _props.autoHeight, autoWidth = _props.autoWidth, height = _props.height, width = _props.width, scrollbarSize = this._scrollbarSize, totalRowsHeight = this._rowSizeAndPositionManager.getTotalSize(), totalColumnsWidth = this._columnSizeAndPositionManager.getTotalSize(), scrollLeft = Math.min(Math.max(0, totalColumnsWidth - width + scrollbarSize), scrollLeftParam), scrollTop = Math.min(Math.max(0, totalRowsHeight - height + scrollbarSize), scrollTopParam);
                        // Certain devices (like Apple touchpad) rapid-fire duplicate events.
                        // Don't force a re-render if this is the case.
                        // The mouse may move faster then the animation frame does.
                        // Use requestAnimationFrame to avoid over-updating.
                        if (this.state.scrollLeft !== scrollLeft || this.state.scrollTop !== scrollTop) {
                            // Track scrolling direction so we can more efficiently overscan rows to reduce empty space around the edges while scrolling.
                            // Don't change direction for an axis unless scroll offset has changed.
                            var _scrollDirectionHorizontal = scrollLeft !== this.state.scrollLeft ? scrollLeft > this.state.scrollLeft ? _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD : _defaultOverscanIndicesGetter.SCROLL_DIRECTION_BACKWARD : this.state.scrollDirectionHorizontal, _scrollDirectionVertical = scrollTop !== this.state.scrollTop ? scrollTop > this.state.scrollTop ? _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD : _defaultOverscanIndicesGetter.SCROLL_DIRECTION_BACKWARD : this.state.scrollDirectionVertical, newState = {
                                isScrolling: !0,
                                scrollDirectionHorizontal: _scrollDirectionHorizontal,
                                scrollDirectionVertical: _scrollDirectionVertical,
                                scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.OBSERVED
                            };
                            autoHeight || (newState.scrollTop = scrollTop), autoWidth || (newState.scrollLeft = scrollLeft), 
                            this.setState(newState);
                        }
                        this._invokeOnScrollMemoizer({
                            scrollLeft: scrollLeft,
                            scrollTop: scrollTop,
                            totalColumnsWidth: totalColumnsWidth,
                            totalRowsHeight: totalRowsHeight
                        });
                    }
                }
            }, {
                key: "invalidateCellSizeAfterRender",
                value: function(_ref3) {
                    var columnIndex = _ref3.columnIndex, rowIndex = _ref3.rowIndex;
                    this._deferredInvalidateColumnIndex = "number" == typeof this._deferredInvalidateColumnIndex ? Math.min(this._deferredInvalidateColumnIndex, columnIndex) : columnIndex, 
                    this._deferredInvalidateRowIndex = "number" == typeof this._deferredInvalidateRowIndex ? Math.min(this._deferredInvalidateRowIndex, rowIndex) : rowIndex;
                }
            }, {
                key: "measureAllCells",
                value: function() {
                    var _props2 = this.props, columnCount = _props2.columnCount, rowCount = _props2.rowCount;
                    this._columnSizeAndPositionManager.getSizeAndPositionOfCell(columnCount - 1), this._rowSizeAndPositionManager.getSizeAndPositionOfCell(rowCount - 1);
                }
            }, {
                key: "recomputeGridSize",
                value: function() {
                    var _ref4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, _ref4$columnIndex = _ref4.columnIndex, columnIndex = void 0 === _ref4$columnIndex ? 0 : _ref4$columnIndex, _ref4$rowIndex = _ref4.rowIndex, rowIndex = void 0 === _ref4$rowIndex ? 0 : _ref4$rowIndex, _props3 = this.props, scrollToColumn = _props3.scrollToColumn, scrollToRow = _props3.scrollToRow;
                    this._columnSizeAndPositionManager.resetCell(columnIndex), this._rowSizeAndPositionManager.resetCell(rowIndex), 
                    // Cell sizes may be determined by a function property.
                    // In this case the cDU handler can't know if they changed.
                    // Store this flag to let the next cDU pass know it needs to recompute the scroll offset.
                    this._recomputeScrollLeftFlag = scrollToColumn >= 0 && columnIndex <= scrollToColumn, 
                    this._recomputeScrollTopFlag = scrollToRow >= 0 && rowIndex <= scrollToRow, // Clear cell cache in case we are scrolling;
                    // Invalid row heights likely mean invalid cached content as well.
                    this._cellCache = {}, this._styleCache = {}, this.forceUpdate();
                }
            }, {
                key: "scrollToCell",
                value: function(_ref5) {
                    var columnIndex = _ref5.columnIndex, rowIndex = _ref5.rowIndex, columnCount = this.props.columnCount, props = this.props;
                    // Don't adjust scroll offset for single-column grids (eg List, Table).
                    // This can cause a funky scroll offset because of the vertical scrollbar width.
                    columnCount > 1 && void 0 !== columnIndex && this._updateScrollLeftForScrollToColumn(_extends({}, props, {
                        scrollToColumn: columnIndex
                    })), void 0 !== rowIndex && this._updateScrollTopForScrollToRow(_extends({}, props, {
                        scrollToRow: rowIndex
                    }));
                }
            }, {
                key: "componentDidMount",
                value: function() {
                    var _props4 = this.props, getScrollbarSize = _props4.getScrollbarSize, height = _props4.height, scrollLeft = _props4.scrollLeft, scrollToColumn = _props4.scrollToColumn, scrollTop = _props4.scrollTop, scrollToRow = _props4.scrollToRow, width = _props4.width;
                    // If cell sizes have been invalidated (eg we are using CellMeasurer) then reset cached positions.
                    // We must do this at the start of the method as we may calculate and update scroll position below.
                    this._handleInvalidatedGridSize(), // If this component was first rendered server-side, scrollbar size will be undefined.
                    // In that event we need to remeasure.
                    this._scrollbarSizeMeasured || (this._scrollbarSize = getScrollbarSize(), this._scrollbarSizeMeasured = !0, 
                    this.setState({})), ("number" == typeof scrollLeft && scrollLeft >= 0 || "number" == typeof scrollTop && scrollTop >= 0) && this.scrollToPosition({
                        scrollLeft: scrollLeft,
                        scrollTop: scrollTop
                    });
                    // Don't update scroll offset if the size is 0; we don't render any cells in this case.
                    // Setting a state may cause us to later thing we've updated the offce when we haven't.
                    var sizeIsBiggerThanZero = height > 0 && width > 0;
                    scrollToColumn >= 0 && sizeIsBiggerThanZero && this._updateScrollLeftForScrollToColumn(), 
                    scrollToRow >= 0 && sizeIsBiggerThanZero && this._updateScrollTopForScrollToRow(), 
                    // Update onRowsRendered callback
                    this._invokeOnGridRenderedHelper(), // Initialize onScroll callback
                    this._invokeOnScrollMemoizer({
                        scrollLeft: scrollLeft || 0,
                        scrollTop: scrollTop || 0,
                        totalColumnsWidth: this._columnSizeAndPositionManager.getTotalSize(),
                        totalRowsHeight: this._rowSizeAndPositionManager.getTotalSize()
                    }), this._maybeCallOnScrollbarPresenceChange();
                }
            }, {
                key: "componentDidUpdate",
                value: function(prevProps, prevState) {
                    var _this2 = this, _props5 = this.props, autoHeight = _props5.autoHeight, autoWidth = _props5.autoWidth, columnCount = _props5.columnCount, height = _props5.height, rowCount = _props5.rowCount, scrollToAlignment = _props5.scrollToAlignment, scrollToColumn = _props5.scrollToColumn, scrollToRow = _props5.scrollToRow, width = _props5.width, _state = this.state, scrollLeft = _state.scrollLeft, scrollPositionChangeReason = _state.scrollPositionChangeReason, scrollTop = _state.scrollTop;
                    // If cell sizes have been invalidated (eg we are using CellMeasurer) then reset cached positions.
                    // We must do this at the start of the method as we may calculate and update scroll position below.
                    this._handleInvalidatedGridSize();
                    // Handle edge case where column or row count has only just increased over 0.
                    // In this case we may have to restore a previously-specified scroll offset.
                    // For more info see bvaughn/react-virtualized/issues/218
                    var columnOrRowCountJustIncreasedFromZero = columnCount > 0 && 0 === prevProps.columnCount || rowCount > 0 && 0 === prevProps.rowCount;
                    // Make sure requested changes to :scrollLeft or :scrollTop get applied.
                    // Assigning to scrollLeft/scrollTop tells the browser to interrupt any running scroll animations,
                    // And to discard any pending async changes to the scroll position that may have happened in the meantime (e.g. on a separate scrolling thread).
                    // So we only set these when we require an adjustment of the scroll position.
                    // See issue #2 for more information.
                    scrollPositionChangeReason === SCROLL_POSITION_CHANGE_REASONS.REQUESTED && (// @TRICKY :autoHeight and :autoWidth properties instructs Grid to leave :scrollTop and :scrollLeft management to an external HOC (eg WindowScroller).
                    // In this case we should avoid checking scrollingContainer.scrollTop and scrollingContainer.scrollLeft since it forces layout/flow.
                    !autoWidth && scrollLeft >= 0 && (scrollLeft !== prevState.scrollLeft && scrollLeft !== this._scrollingContainer.scrollLeft || columnOrRowCountJustIncreasedFromZero) && (this._scrollingContainer.scrollLeft = scrollLeft), 
                    !autoHeight && scrollTop >= 0 && (scrollTop !== prevState.scrollTop && scrollTop !== this._scrollingContainer.scrollTop || columnOrRowCountJustIncreasedFromZero) && (this._scrollingContainer.scrollTop = scrollTop));
                    // Special case where the previous size was 0:
                    // In this case we don't show any windowed cells at all.
                    // So we should always recalculate offset afterwards.
                    var sizeJustIncreasedFromZero = (0 === prevProps.width || 0 === prevProps.height) && height > 0 && width > 0;
                    // Changes to :scrollLeft or :scrollTop should also notify :onScroll listeners
                    if (// Update scroll offsets if the current :scrollToColumn or :scrollToRow values requires it
                    // @TODO Do we also need this check or can the one in componentWillUpdate() suffice?
                    this._recomputeScrollLeftFlag ? (this._recomputeScrollLeftFlag = !1, this._updateScrollLeftForScrollToColumn(this.props)) : (0, 
                    _updateScrollIndexHelper2.default)({
                        cellSizeAndPositionManager: this._columnSizeAndPositionManager,
                        previousCellsCount: prevProps.columnCount,
                        previousCellSize: "number" == typeof prevProps.columnWidth ? prevProps.columnWidth : null,
                        previousScrollToAlignment: prevProps.scrollToAlignment,
                        previousScrollToIndex: prevProps.scrollToColumn,
                        previousSize: prevProps.width,
                        scrollOffset: scrollLeft,
                        scrollToAlignment: scrollToAlignment,
                        scrollToIndex: scrollToColumn,
                        size: width,
                        sizeJustIncreasedFromZero: sizeJustIncreasedFromZero,
                        updateScrollIndexCallback: function() {
                            return _this2._updateScrollLeftForScrollToColumn(_this2.props);
                        }
                    }), this._recomputeScrollTopFlag ? (this._recomputeScrollTopFlag = !1, this._updateScrollTopForScrollToRow(this.props)) : (0, 
                    _updateScrollIndexHelper2.default)({
                        cellSizeAndPositionManager: this._rowSizeAndPositionManager,
                        previousCellsCount: prevProps.rowCount,
                        previousCellSize: "number" == typeof prevProps.rowHeight ? prevProps.rowHeight : null,
                        previousScrollToAlignment: prevProps.scrollToAlignment,
                        previousScrollToIndex: prevProps.scrollToRow,
                        previousSize: prevProps.height,
                        scrollOffset: scrollTop,
                        scrollToAlignment: scrollToAlignment,
                        scrollToIndex: scrollToRow,
                        size: height,
                        sizeJustIncreasedFromZero: sizeJustIncreasedFromZero,
                        updateScrollIndexCallback: function() {
                            return _this2._updateScrollTopForScrollToRow(_this2.props);
                        }
                    }), // Update onRowsRendered callback if start/stop indices have changed
                    this._invokeOnGridRenderedHelper(), scrollLeft !== prevState.scrollLeft || scrollTop !== prevState.scrollTop) {
                        var totalRowsHeight = this._rowSizeAndPositionManager.getTotalSize(), totalColumnsWidth = this._columnSizeAndPositionManager.getTotalSize();
                        this._invokeOnScrollMemoizer({
                            scrollLeft: scrollLeft,
                            scrollTop: scrollTop,
                            totalColumnsWidth: totalColumnsWidth,
                            totalRowsHeight: totalRowsHeight
                        });
                    }
                    this._maybeCallOnScrollbarPresenceChange();
                }
            }, {
                key: "componentWillMount",
                value: function() {
                    var getScrollbarSize = this.props.getScrollbarSize;
                    // If this component is being rendered server-side, getScrollbarSize() will return undefined.
                    // We handle this case in componentDidMount()
                    this._scrollbarSize = getScrollbarSize(), void 0 === this._scrollbarSize ? (this._scrollbarSizeMeasured = !1, 
                    this._scrollbarSize = 0) : this._scrollbarSizeMeasured = !0, this._calculateChildrenToRender();
                }
            }, {
                key: "componentWillUnmount",
                value: function() {
                    this._disablePointerEventsTimeoutId && (0, _requestAnimationTimeout.cancelAnimationTimeout)(this._disablePointerEventsTimeoutId);
                }
            }, {
                key: "componentWillReceiveProps",
                value: function(nextProps) {
                    var _this3 = this, _state2 = this.state, scrollLeft = _state2.scrollLeft, scrollTop = _state2.scrollTop;
                    if (0 === nextProps.columnCount && 0 !== scrollLeft || 0 === nextProps.rowCount && 0 !== scrollTop) this.scrollToPosition({
                        scrollLeft: 0,
                        scrollTop: 0
                    }); else if (nextProps.scrollLeft !== this.props.scrollLeft || nextProps.scrollTop !== this.props.scrollTop) {
                        var newState = {};
                        null != nextProps.scrollLeft && (newState.scrollLeft = nextProps.scrollLeft), null != nextProps.scrollTop && (newState.scrollTop = nextProps.scrollTop), 
                        this.scrollToPosition(newState);
                    }
                    nextProps.columnWidth === this.props.columnWidth && nextProps.rowHeight === this.props.rowHeight || (this._styleCache = {}), 
                    this._columnWidthGetter = this._wrapSizeGetter(nextProps.columnWidth), this._rowHeightGetter = this._wrapSizeGetter(nextProps.rowHeight), 
                    this._columnSizeAndPositionManager.configure({
                        cellCount: nextProps.columnCount,
                        estimatedCellSize: this._getEstimatedColumnSize(nextProps)
                    }), this._rowSizeAndPositionManager.configure({
                        cellCount: nextProps.rowCount,
                        estimatedCellSize: this._getEstimatedRowSize(nextProps)
                    });
                    var _props6 = this.props, columnCount = _props6.columnCount, rowCount = _props6.rowCount;
                    // Special case when either cols or rows were 0
                    // This would prevent any cells from rendering
                    // So we need to reset row scroll if cols changed from 0 (and vice versa)
                    0 !== columnCount && 0 !== rowCount || (columnCount = 0, rowCount = 0), // If scrolling is controlled outside this component, clear cache when scrolling stops
                    nextProps.autoHeight && nextProps.isScrolling === !1 && this.props.isScrolling === !0 && this._resetStyleCache(), 
                    // Update scroll offsets if the size or number of cells have changed, invalidating the previous value
                    (0, _calculateSizeAndPositionDataAndUpdateScrollOffset2.default)({
                        cellCount: columnCount,
                        cellSize: "number" == typeof this.props.columnWidth ? this.props.columnWidth : null,
                        computeMetadataCallback: function() {
                            return _this3._columnSizeAndPositionManager.resetCell(0);
                        },
                        computeMetadataCallbackProps: nextProps,
                        nextCellsCount: nextProps.columnCount,
                        nextCellSize: "number" == typeof nextProps.columnWidth ? nextProps.columnWidth : null,
                        nextScrollToIndex: nextProps.scrollToColumn,
                        scrollToIndex: this.props.scrollToColumn,
                        updateScrollOffsetForScrollToIndex: function() {
                            return _this3._updateScrollLeftForScrollToColumn(nextProps, _this3.state);
                        }
                    }), (0, _calculateSizeAndPositionDataAndUpdateScrollOffset2.default)({
                        cellCount: rowCount,
                        cellSize: "number" == typeof this.props.rowHeight ? this.props.rowHeight : null,
                        computeMetadataCallback: function() {
                            return _this3._rowSizeAndPositionManager.resetCell(0);
                        },
                        computeMetadataCallbackProps: nextProps,
                        nextCellsCount: nextProps.rowCount,
                        nextCellSize: "number" == typeof nextProps.rowHeight ? nextProps.rowHeight : null,
                        nextScrollToIndex: nextProps.scrollToRow,
                        scrollToIndex: this.props.scrollToRow,
                        updateScrollOffsetForScrollToIndex: function() {
                            return _this3._updateScrollTopForScrollToRow(nextProps, _this3.state);
                        }
                    });
                }
            }, {
                key: "componentWillUpdate",
                value: function(nextProps, nextState) {
                    this._calculateChildrenToRender(nextProps, nextState);
                }
            }, {
                key: "render",
                value: function() {
                    var _props7 = this.props, autoContainerWidth = _props7.autoContainerWidth, autoHeight = _props7.autoHeight, autoWidth = _props7.autoWidth, className = _props7.className, containerProps = _props7.containerProps, containerRole = _props7.containerRole, containerStyle = _props7.containerStyle, height = _props7.height, id = _props7.id, noContentRenderer = _props7.noContentRenderer, role = _props7.role, style = _props7.style, tabIndex = _props7.tabIndex, width = _props7.width, isScrolling = this._isScrolling(), gridStyle = {
                        boxSizing: "border-box",
                        direction: "ltr",
                        height: autoHeight ? "auto" : height,
                        position: "relative",
                        width: autoWidth ? "auto" : width,
                        WebkitOverflowScrolling: "touch",
                        willChange: "transform"
                    }, totalColumnsWidth = this._columnSizeAndPositionManager.getTotalSize(), totalRowsHeight = this._rowSizeAndPositionManager.getTotalSize(), verticalScrollBarSize = totalRowsHeight > height ? this._scrollbarSize : 0, horizontalScrollBarSize = totalColumnsWidth > width ? this._scrollbarSize : 0;
                    horizontalScrollBarSize === this._horizontalScrollBarSize && verticalScrollBarSize === this._verticalScrollBarSize || (this._horizontalScrollBarSize = horizontalScrollBarSize, 
                    this._verticalScrollBarSize = verticalScrollBarSize, this._scrollbarPresenceChanged = !0), 
                    // Also explicitly init styles to 'auto' if scrollbars are required.
                    // This works around an obscure edge case where external CSS styles have not yet been loaded,
                    // But an initial scroll index of offset is set as an external prop.
                    // Without this style, Grid would render the correct range of cells but would NOT update its internal offset.
                    // This was originally reported via clauderic/react-infinite-calendar/issues/23
                    gridStyle.overflowX = totalColumnsWidth + verticalScrollBarSize <= width ? "hidden" : "auto", 
                    gridStyle.overflowY = totalRowsHeight + horizontalScrollBarSize <= height ? "hidden" : "auto";
                    var childrenToDisplay = this._childrenToDisplay, showNoContentRenderer = 0 === childrenToDisplay.length && height > 0 && width > 0;
                    return _react2.default.createElement("div", _extends({
                        ref: this._setScrollingContainerRef
                    }, containerProps, {
                        "aria-label": this.props["aria-label"],
                        "aria-readonly": this.props["aria-readonly"],
                        className: (0, _classnames2.default)("ReactVirtualized__Grid", className),
                        id: id,
                        onScroll: this._onScroll,
                        role: role,
                        style: _extends({}, gridStyle, style),
                        tabIndex: tabIndex
                    }), childrenToDisplay.length > 0 && _react2.default.createElement("div", {
                        className: "ReactVirtualized__Grid__innerScrollContainer",
                        role: containerRole,
                        style: _extends({
                            width: autoContainerWidth ? "auto" : totalColumnsWidth,
                            height: totalRowsHeight,
                            maxWidth: totalColumnsWidth,
                            maxHeight: totalRowsHeight,
                            overflow: "hidden",
                            pointerEvents: isScrolling ? "none" : "",
                            position: "relative"
                        }, containerStyle)
                    }, childrenToDisplay), showNoContentRenderer && noContentRenderer());
                }
            }, {
                key: "_calculateChildrenToRender",
                value: function() {
                    var props = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.props, state = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.state, cellRenderer = props.cellRenderer, cellRangeRenderer = props.cellRangeRenderer, columnCount = props.columnCount, deferredMeasurementCache = props.deferredMeasurementCache, height = props.height, overscanColumnCount = props.overscanColumnCount, overscanIndicesGetter = props.overscanIndicesGetter, overscanRowCount = props.overscanRowCount, rowCount = props.rowCount, width = props.width, scrollDirectionHorizontal = state.scrollDirectionHorizontal, scrollDirectionVertical = state.scrollDirectionVertical, scrollLeft = state.scrollLeft, scrollTop = state.scrollTop, isScrolling = this._isScrolling(props, state);
                    // Render only enough columns and rows to cover the visible area of the grid.
                    if (this._childrenToDisplay = [], height > 0 && width > 0) {
                        var visibleColumnIndices = this._columnSizeAndPositionManager.getVisibleCellRange({
                            containerSize: width,
                            offset: scrollLeft
                        }), visibleRowIndices = this._rowSizeAndPositionManager.getVisibleCellRange({
                            containerSize: height,
                            offset: scrollTop
                        }), horizontalOffsetAdjustment = this._columnSizeAndPositionManager.getOffsetAdjustment({
                            containerSize: width,
                            offset: scrollLeft
                        }), verticalOffsetAdjustment = this._rowSizeAndPositionManager.getOffsetAdjustment({
                            containerSize: height,
                            offset: scrollTop
                        });
                        // Store for _invokeOnGridRenderedHelper()
                        this._renderedColumnStartIndex = visibleColumnIndices.start, this._renderedColumnStopIndex = visibleColumnIndices.stop, 
                        this._renderedRowStartIndex = visibleRowIndices.start, this._renderedRowStopIndex = visibleRowIndices.stop;
                        var overscanColumnIndices = overscanIndicesGetter({
                            direction: "horizontal",
                            cellCount: columnCount,
                            overscanCellsCount: overscanColumnCount,
                            scrollDirection: scrollDirectionHorizontal,
                            startIndex: "number" == typeof this._renderedColumnStartIndex ? this._renderedColumnStartIndex : 0,
                            stopIndex: "number" == typeof this._renderedColumnStopIndex ? this._renderedColumnStopIndex : -1
                        }), overscanRowIndices = overscanIndicesGetter({
                            direction: "vertical",
                            cellCount: rowCount,
                            overscanCellsCount: overscanRowCount,
                            scrollDirection: scrollDirectionVertical,
                            startIndex: "number" == typeof this._renderedRowStartIndex ? this._renderedRowStartIndex : 0,
                            stopIndex: "number" == typeof this._renderedRowStopIndex ? this._renderedRowStopIndex : -1
                        });
                        // Store for _invokeOnGridRenderedHelper()
                        this._columnStartIndex = overscanColumnIndices.overscanStartIndex, this._columnStopIndex = overscanColumnIndices.overscanStopIndex, 
                        this._rowStartIndex = overscanRowIndices.overscanStartIndex, this._rowStopIndex = overscanRowIndices.overscanStopIndex, 
                        this._childrenToDisplay = cellRangeRenderer({
                            cellCache: this._cellCache,
                            cellRenderer: cellRenderer,
                            columnSizeAndPositionManager: this._columnSizeAndPositionManager,
                            columnStartIndex: this._columnStartIndex,
                            columnStopIndex: this._columnStopIndex,
                            deferredMeasurementCache: deferredMeasurementCache,
                            horizontalOffsetAdjustment: horizontalOffsetAdjustment,
                            isScrolling: isScrolling,
                            parent: this,
                            rowSizeAndPositionManager: this._rowSizeAndPositionManager,
                            rowStartIndex: this._rowStartIndex,
                            rowStopIndex: this._rowStopIndex,
                            scrollLeft: scrollLeft,
                            scrollTop: scrollTop,
                            styleCache: this._styleCache,
                            verticalOffsetAdjustment: verticalOffsetAdjustment,
                            visibleColumnIndices: visibleColumnIndices,
                            visibleRowIndices: visibleRowIndices
                        });
                    }
                }
            }, {
                key: "_debounceScrollEnded",
                value: function() {
                    var scrollingResetTimeInterval = this.props.scrollingResetTimeInterval;
                    this._disablePointerEventsTimeoutId && (0, _requestAnimationTimeout.cancelAnimationTimeout)(this._disablePointerEventsTimeoutId), 
                    this._disablePointerEventsTimeoutId = (0, _requestAnimationTimeout.requestAnimationTimeout)(this._debounceScrollEndedCallback, scrollingResetTimeInterval);
                }
            }, {
                key: "_getEstimatedColumnSize",
                value: function(props) {
                    return "number" == typeof props.columnWidth ? props.columnWidth : props.estimatedColumnSize;
                }
            }, {
                key: "_getEstimatedRowSize",
                value: function(props) {
                    return "number" == typeof props.rowHeight ? props.rowHeight : props.estimatedRowSize;
                }
            }, {
                key: "_handleInvalidatedGridSize",
                value: function() {
                    if ("number" == typeof this._deferredInvalidateColumnIndex && "number" == typeof this._deferredInvalidateRowIndex) {
                        var columnIndex = this._deferredInvalidateColumnIndex, rowIndex = this._deferredInvalidateRowIndex;
                        this._deferredInvalidateColumnIndex = null, this._deferredInvalidateRowIndex = null, 
                        this.recomputeGridSize({
                            columnIndex: columnIndex,
                            rowIndex: rowIndex
                        });
                    }
                }
            }, {
                key: "_invokeOnScrollMemoizer",
                value: function(_ref6) {
                    var _this4 = this, scrollLeft = _ref6.scrollLeft, scrollTop = _ref6.scrollTop, totalColumnsWidth = _ref6.totalColumnsWidth, totalRowsHeight = _ref6.totalRowsHeight;
                    this._onScrollMemoizer({
                        callback: function(_ref7) {
                            var scrollLeft = _ref7.scrollLeft, scrollTop = _ref7.scrollTop, _props8 = _this4.props, height = _props8.height, onScroll = _props8.onScroll, width = _props8.width;
                            onScroll({
                                clientHeight: height,
                                clientWidth: width,
                                scrollHeight: totalRowsHeight,
                                scrollLeft: scrollLeft,
                                scrollTop: scrollTop,
                                scrollWidth: totalColumnsWidth
                            });
                        },
                        indices: {
                            scrollLeft: scrollLeft,
                            scrollTop: scrollTop
                        }
                    });
                }
            }, {
                key: "_isScrolling",
                value: function() {
                    var props = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.props, state = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.state;
                    // If isScrolling is defined in props, use it to override the value in state
                    // This is a performance optimization for WindowScroller + Grid
                    return Object.hasOwnProperty.call(props, "isScrolling") ? Boolean(props.isScrolling) : Boolean(state.isScrolling);
                }
            }, {
                key: "_maybeCallOnScrollbarPresenceChange",
                value: function() {
                    if (this._scrollbarPresenceChanged) {
                        var _onScrollbarPresenceChange = this.props.onScrollbarPresenceChange;
                        this._scrollbarPresenceChanged = !1, _onScrollbarPresenceChange({
                            horizontal: this._horizontalScrollBarSize > 0,
                            size: this._scrollbarSize,
                            vertical: this._verticalScrollBarSize > 0
                        });
                    }
                }
            }, {
                key: "scrollToPosition",
                /**
	     * Scroll to the specified offset(s).
	     * Useful for animating position changes.
	     */
                value: function(_ref8) {
                    var scrollLeft = _ref8.scrollLeft, scrollTop = _ref8.scrollTop, newState = {
                        scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.REQUESTED
                    };
                    "number" == typeof scrollLeft && scrollLeft >= 0 && (newState.scrollDirectionHorizontal = scrollLeft > this.state.scrollLeft ? _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD : _defaultOverscanIndicesGetter.SCROLL_DIRECTION_BACKWARD, 
                    newState.scrollLeft = scrollLeft), "number" == typeof scrollTop && scrollTop >= 0 && (newState.scrollDirectionVertical = scrollTop > this.state.scrollTop ? _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD : _defaultOverscanIndicesGetter.SCROLL_DIRECTION_BACKWARD, 
                    newState.scrollTop = scrollTop), ("number" == typeof scrollLeft && scrollLeft >= 0 && scrollLeft !== this.state.scrollLeft || "number" == typeof scrollTop && scrollTop >= 0 && scrollTop !== this.state.scrollTop) && this.setState(newState);
                }
            }, {
                key: "_wrapSizeGetter",
                value: function(value) {
                    return "function" == typeof value ? value : function() {
                        return value;
                    };
                }
            }, {
                key: "_getCalculatedScrollLeft",
                value: function() {
                    var props = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.props, state = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.state, columnCount = props.columnCount, height = props.height, scrollToAlignment = props.scrollToAlignment, scrollToColumn = props.scrollToColumn, width = props.width, scrollLeft = state.scrollLeft;
                    if (columnCount > 0) {
                        var finalColumn = columnCount - 1, targetIndex = scrollToColumn < 0 ? finalColumn : Math.min(finalColumn, scrollToColumn), totalRowsHeight = this._rowSizeAndPositionManager.getTotalSize(), scrollBarSize = totalRowsHeight > height ? this._scrollbarSize : 0;
                        return this._columnSizeAndPositionManager.getUpdatedOffsetForIndex({
                            align: scrollToAlignment,
                            containerSize: width - scrollBarSize,
                            currentOffset: scrollLeft,
                            targetIndex: targetIndex
                        });
                    }
                }
            }, {
                key: "_updateScrollLeftForScrollToColumn",
                value: function() {
                    var props = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.props, state = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.state, scrollLeft = state.scrollLeft, calculatedScrollLeft = this._getCalculatedScrollLeft(props, state);
                    "number" == typeof calculatedScrollLeft && calculatedScrollLeft >= 0 && scrollLeft !== calculatedScrollLeft && this.scrollToPosition({
                        scrollLeft: calculatedScrollLeft,
                        scrollTop: -1
                    });
                }
            }, {
                key: "_getCalculatedScrollTop",
                value: function() {
                    var props = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.props, state = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.state, height = props.height, rowCount = props.rowCount, scrollToAlignment = props.scrollToAlignment, scrollToRow = props.scrollToRow, width = props.width, scrollTop = state.scrollTop;
                    if (rowCount > 0) {
                        var finalRow = rowCount - 1, targetIndex = scrollToRow < 0 ? finalRow : Math.min(finalRow, scrollToRow), totalColumnsWidth = this._columnSizeAndPositionManager.getTotalSize(), scrollBarSize = totalColumnsWidth > width ? this._scrollbarSize : 0;
                        return this._rowSizeAndPositionManager.getUpdatedOffsetForIndex({
                            align: scrollToAlignment,
                            containerSize: height - scrollBarSize,
                            currentOffset: scrollTop,
                            targetIndex: targetIndex
                        });
                    }
                }
            }, {
                key: "_resetStyleCache",
                value: function() {
                    var styleCache = this._styleCache;
                    // Reset cell and style caches once scrolling stops.
                    // This makes Grid simpler to use (since cells commonly change).
                    // And it keeps the caches from growing too large.
                    // Performance is most sensitive when a user is scrolling.
                    this._cellCache = {}, this._styleCache = {};
                    // Copy over the visible cell styles so avoid unnecessary re-render.
                    for (var rowIndex = this._rowStartIndex; rowIndex <= this._rowStopIndex; rowIndex++) for (var columnIndex = this._columnStartIndex; columnIndex <= this._columnStopIndex; columnIndex++) {
                        var key = rowIndex + "-" + columnIndex;
                        this._styleCache[key] = styleCache[key];
                    }
                    this.setState({
                        isScrolling: !1
                    });
                }
            }, {
                key: "_updateScrollTopForScrollToRow",
                value: function() {
                    var props = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.props, state = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.state, scrollTop = state.scrollTop, calculatedScrollTop = this._getCalculatedScrollTop(props, state);
                    "number" == typeof calculatedScrollTop && calculatedScrollTop >= 0 && scrollTop !== calculatedScrollTop && this.scrollToPosition({
                        scrollLeft: -1,
                        scrollTop: calculatedScrollTop
                    });
                }
            } ]), Grid;
        }(_react2.default.PureComponent);
        Grid.defaultProps = {
            "aria-label": "grid",
            "aria-readonly": !0,
            autoContainerWidth: !1,
            autoHeight: !1,
            autoWidth: !1,
            cellRangeRenderer: _defaultCellRangeRenderer2.default,
            containerRole: "rowgroup",
            containerStyle: {},
            estimatedColumnSize: 100,
            estimatedRowSize: 30,
            getScrollbarSize: _scrollbarSize2.default,
            noContentRenderer: renderNull,
            onScroll: function(_ref9) {
                _objectDestructuringEmpty(_ref9);
            },
            onScrollbarPresenceChange: function() {},
            onSectionRendered: function(_ref10) {
                _objectDestructuringEmpty(_ref10);
            },
            overscanColumnCount: 0,
            overscanIndicesGetter: _defaultOverscanIndicesGetter2.default,
            overscanRowCount: 10,
            role: "grid",
            scrollingResetTimeInterval: DEFAULT_SCROLLING_RESET_TIME_INTERVAL,
            scrollToAlignment: "auto",
            scrollToColumn: -1,
            scrollToRow: -1,
            style: {},
            tabIndex: 0
        }, Grid.propTypes = {
            "aria-label": __webpack_require__(109).string.isRequired,
            "aria-readonly": __webpack_require__(109).bool,
            autoContainerWidth: __webpack_require__(109).bool.isRequired,
            autoHeight: __webpack_require__(109).bool.isRequired,
            autoWidth: __webpack_require__(109).bool.isRequired,
            cellRenderer: "function" == typeof babelPluginFlowReactPropTypes_proptype_CellRenderer ? babelPluginFlowReactPropTypes_proptype_CellRenderer.isRequired ? babelPluginFlowReactPropTypes_proptype_CellRenderer.isRequired : babelPluginFlowReactPropTypes_proptype_CellRenderer : __webpack_require__(109).shape(babelPluginFlowReactPropTypes_proptype_CellRenderer).isRequired,
            cellRangeRenderer: "function" == typeof babelPluginFlowReactPropTypes_proptype_CellRangeRenderer ? babelPluginFlowReactPropTypes_proptype_CellRangeRenderer.isRequired ? babelPluginFlowReactPropTypes_proptype_CellRangeRenderer.isRequired : babelPluginFlowReactPropTypes_proptype_CellRangeRenderer : __webpack_require__(109).shape(babelPluginFlowReactPropTypes_proptype_CellRangeRenderer).isRequired,
            className: __webpack_require__(109).string,
            columnCount: __webpack_require__(109).number.isRequired,
            columnWidth: "function" == typeof babelPluginFlowReactPropTypes_proptype_CellSize ? babelPluginFlowReactPropTypes_proptype_CellSize.isRequired ? babelPluginFlowReactPropTypes_proptype_CellSize.isRequired : babelPluginFlowReactPropTypes_proptype_CellSize : __webpack_require__(109).shape(babelPluginFlowReactPropTypes_proptype_CellSize).isRequired,
            containerProps: __webpack_require__(109).object,
            containerRole: __webpack_require__(109).string.isRequired,
            containerStyle: __webpack_require__(109).object.isRequired,
            deferredMeasurementCache: __webpack_require__(109).object,
            estimatedColumnSize: __webpack_require__(109).number.isRequired,
            estimatedRowSize: __webpack_require__(109).number.isRequired,
            getScrollbarSize: __webpack_require__(109).func.isRequired,
            height: __webpack_require__(109).number.isRequired,
            id: __webpack_require__(109).string,
            isScrolling: __webpack_require__(109).bool,
            noContentRenderer: "function" == typeof babelPluginFlowReactPropTypes_proptype_NoContentRenderer ? babelPluginFlowReactPropTypes_proptype_NoContentRenderer.isRequired ? babelPluginFlowReactPropTypes_proptype_NoContentRenderer.isRequired : babelPluginFlowReactPropTypes_proptype_NoContentRenderer : __webpack_require__(109).shape(babelPluginFlowReactPropTypes_proptype_NoContentRenderer).isRequired,
            onScroll: __webpack_require__(109).func.isRequired,
            onScrollbarPresenceChange: __webpack_require__(109).func.isRequired,
            onSectionRendered: __webpack_require__(109).func.isRequired,
            overscanColumnCount: __webpack_require__(109).number.isRequired,
            overscanIndicesGetter: "function" == typeof babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetter ? babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetter.isRequired ? babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetter.isRequired : babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetter : __webpack_require__(109).shape(babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetter).isRequired,
            overscanRowCount: __webpack_require__(109).number.isRequired,
            role: __webpack_require__(109).string.isRequired,
            rowHeight: "function" == typeof babelPluginFlowReactPropTypes_proptype_CellSize ? babelPluginFlowReactPropTypes_proptype_CellSize.isRequired ? babelPluginFlowReactPropTypes_proptype_CellSize.isRequired : babelPluginFlowReactPropTypes_proptype_CellSize : __webpack_require__(109).shape(babelPluginFlowReactPropTypes_proptype_CellSize).isRequired,
            rowCount: __webpack_require__(109).number.isRequired,
            scrollingResetTimeInterval: __webpack_require__(109).number.isRequired,
            scrollLeft: __webpack_require__(109).number,
            scrollToAlignment: "function" == typeof babelPluginFlowReactPropTypes_proptype_Alignment ? babelPluginFlowReactPropTypes_proptype_Alignment.isRequired ? babelPluginFlowReactPropTypes_proptype_Alignment.isRequired : babelPluginFlowReactPropTypes_proptype_Alignment : __webpack_require__(109).shape(babelPluginFlowReactPropTypes_proptype_Alignment).isRequired,
            scrollToColumn: __webpack_require__(109).number.isRequired,
            scrollTop: __webpack_require__(109).number,
            scrollToRow: __webpack_require__(109).number.isRequired,
            style: __webpack_require__(109).object.isRequired,
            tabIndex: __webpack_require__(109).number.isRequired,
            width: __webpack_require__(109).number.isRequired
        }, exports.default = Grid;
    }, /* 168 */
    /***/
    function(module, exports) {
        "use strict";
        function calculateSizeAndPositionDataAndUpdateScrollOffset(_ref) {
            var cellCount = _ref.cellCount, cellSize = _ref.cellSize, computeMetadataCallback = _ref.computeMetadataCallback, computeMetadataCallbackProps = _ref.computeMetadataCallbackProps, nextCellsCount = _ref.nextCellsCount, nextCellSize = _ref.nextCellSize, nextScrollToIndex = _ref.nextScrollToIndex, scrollToIndex = _ref.scrollToIndex, updateScrollOffsetForScrollToIndex = _ref.updateScrollOffsetForScrollToIndex;
            // Don't compare cell sizes if they are functions because inline functions would cause infinite loops.
            // In that event users should use the manual recompute methods to inform of changes.
            cellCount === nextCellsCount && ("number" != typeof cellSize && "number" != typeof nextCellSize || cellSize === nextCellSize) || (computeMetadataCallback(computeMetadataCallbackProps), 
            // Updated cell metadata may have hidden the previous scrolled-to item.
            // In this case we should also update the scrollTop to ensure it stays visible.
            scrollToIndex >= 0 && scrollToIndex === nextScrollToIndex && updateScrollOffsetForScrollToIndex());
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = calculateSizeAndPositionDataAndUpdateScrollOffset;
    }, /* 169 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _objectWithoutProperties(obj, keys) {
            var target = {};
            for (var i in obj) keys.indexOf(i) >= 0 || Object.prototype.hasOwnProperty.call(obj, i) && (target[i] = obj[i]);
            return target;
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.DEFAULT_MAX_SCROLL_SIZE = void 0;
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }(), _CellSizeAndPositionManager = __webpack_require__(170), _CellSizeAndPositionManager2 = _interopRequireDefault(_CellSizeAndPositionManager), DEFAULT_MAX_SCROLL_SIZE = (__webpack_require__(171).babelPluginFlowReactPropTypes_proptype_VisibleCellRange || __webpack_require__(109).any, 
        __webpack_require__(171).babelPluginFlowReactPropTypes_proptype_CellSizeGetter || __webpack_require__(109).any, 
        __webpack_require__(171).babelPluginFlowReactPropTypes_proptype_Alignment || __webpack_require__(109).any, 
        exports.DEFAULT_MAX_SCROLL_SIZE = 15e5), ScalingCellSizeAndPositionManager = function() {
            function ScalingCellSizeAndPositionManager(_ref) {
                var _ref$maxScrollSize = _ref.maxScrollSize, maxScrollSize = void 0 === _ref$maxScrollSize ? DEFAULT_MAX_SCROLL_SIZE : _ref$maxScrollSize, params = _objectWithoutProperties(_ref, [ "maxScrollSize" ]);
                _classCallCheck(this, ScalingCellSizeAndPositionManager), // Favor composition over inheritance to simplify IE10 support
                this._cellSizeAndPositionManager = new _CellSizeAndPositionManager2.default(params), 
                this._maxScrollSize = maxScrollSize;
            }
            return _createClass(ScalingCellSizeAndPositionManager, [ {
                key: "areOffsetsAdjusted",
                value: function() {
                    return this._cellSizeAndPositionManager.getTotalSize() > this._maxScrollSize;
                }
            }, {
                key: "configure",
                value: function(params) {
                    this._cellSizeAndPositionManager.configure(params);
                }
            }, {
                key: "getCellCount",
                value: function() {
                    return this._cellSizeAndPositionManager.getCellCount();
                }
            }, {
                key: "getEstimatedCellSize",
                value: function() {
                    return this._cellSizeAndPositionManager.getEstimatedCellSize();
                }
            }, {
                key: "getLastMeasuredIndex",
                value: function() {
                    return this._cellSizeAndPositionManager.getLastMeasuredIndex();
                }
            }, {
                key: "getOffsetAdjustment",
                value: function(_ref2) {
                    var containerSize = _ref2.containerSize, offset = _ref2.offset, totalSize = this._cellSizeAndPositionManager.getTotalSize(), safeTotalSize = this.getTotalSize(), offsetPercentage = this._getOffsetPercentage({
                        containerSize: containerSize,
                        offset: offset,
                        totalSize: safeTotalSize
                    });
                    return Math.round(offsetPercentage * (safeTotalSize - totalSize));
                }
            }, {
                key: "getSizeAndPositionOfCell",
                value: function(index) {
                    return this._cellSizeAndPositionManager.getSizeAndPositionOfCell(index);
                }
            }, {
                key: "getSizeAndPositionOfLastMeasuredCell",
                value: function() {
                    return this._cellSizeAndPositionManager.getSizeAndPositionOfLastMeasuredCell();
                }
            }, {
                key: "getTotalSize",
                value: function() {
                    return Math.min(this._maxScrollSize, this._cellSizeAndPositionManager.getTotalSize());
                }
            }, {
                key: "getUpdatedOffsetForIndex",
                value: function(_ref3) {
                    var _ref3$align = _ref3.align, align = void 0 === _ref3$align ? "auto" : _ref3$align, containerSize = _ref3.containerSize, currentOffset = _ref3.currentOffset, targetIndex = _ref3.targetIndex;
                    currentOffset = this._safeOffsetToOffset({
                        containerSize: containerSize,
                        offset: currentOffset
                    });
                    var offset = this._cellSizeAndPositionManager.getUpdatedOffsetForIndex({
                        align: align,
                        containerSize: containerSize,
                        currentOffset: currentOffset,
                        targetIndex: targetIndex
                    });
                    return this._offsetToSafeOffset({
                        containerSize: containerSize,
                        offset: offset
                    });
                }
            }, {
                key: "getVisibleCellRange",
                value: function(_ref4) {
                    var containerSize = _ref4.containerSize, offset = _ref4.offset;
                    return offset = this._safeOffsetToOffset({
                        containerSize: containerSize,
                        offset: offset
                    }), this._cellSizeAndPositionManager.getVisibleCellRange({
                        containerSize: containerSize,
                        offset: offset
                    });
                }
            }, {
                key: "resetCell",
                value: function(index) {
                    this._cellSizeAndPositionManager.resetCell(index);
                }
            }, {
                key: "_getOffsetPercentage",
                value: function(_ref5) {
                    var containerSize = _ref5.containerSize, offset = _ref5.offset, totalSize = _ref5.totalSize;
                    return totalSize <= containerSize ? 0 : offset / (totalSize - containerSize);
                }
            }, {
                key: "_offsetToSafeOffset",
                value: function(_ref6) {
                    var containerSize = _ref6.containerSize, offset = _ref6.offset, totalSize = this._cellSizeAndPositionManager.getTotalSize(), safeTotalSize = this.getTotalSize();
                    if (totalSize === safeTotalSize) return offset;
                    var offsetPercentage = this._getOffsetPercentage({
                        containerSize: containerSize,
                        offset: offset,
                        totalSize: totalSize
                    });
                    return Math.round(offsetPercentage * (safeTotalSize - containerSize));
                }
            }, {
                key: "_safeOffsetToOffset",
                value: function(_ref7) {
                    var containerSize = _ref7.containerSize, offset = _ref7.offset, totalSize = this._cellSizeAndPositionManager.getTotalSize(), safeTotalSize = this.getTotalSize();
                    if (totalSize === safeTotalSize) return offset;
                    var offsetPercentage = this._getOffsetPercentage({
                        containerSize: containerSize,
                        offset: offset,
                        totalSize: safeTotalSize
                    });
                    return Math.round(offsetPercentage * (totalSize - containerSize));
                }
            } ]), ScalingCellSizeAndPositionManager;
        }();
        exports.default = ScalingCellSizeAndPositionManager;
    }, /* 170 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }(), CellSizeAndPositionManager = (__webpack_require__(171).babelPluginFlowReactPropTypes_proptype_VisibleCellRange || __webpack_require__(109).any, 
        __webpack_require__(171).babelPluginFlowReactPropTypes_proptype_CellSizeGetter || __webpack_require__(109).any, 
        __webpack_require__(171).babelPluginFlowReactPropTypes_proptype_Alignment || __webpack_require__(109).any, 
        function() {
            // Measurements for cells up to this index can be trusted; cells afterward should be estimated.
            function CellSizeAndPositionManager(_ref) {
                var _ref$batchAllCells = _ref.batchAllCells, batchAllCells = void 0 !== _ref$batchAllCells && _ref$batchAllCells, cellCount = _ref.cellCount, cellSizeGetter = _ref.cellSizeGetter, estimatedCellSize = _ref.estimatedCellSize;
                _classCallCheck(this, CellSizeAndPositionManager), this._cellSizeAndPositionData = {}, 
                this._lastMeasuredIndex = -1, this._lastBatchedIndex = -1, this._batchAllCells = batchAllCells, 
                this._cellSizeGetter = cellSizeGetter, this._cellCount = cellCount, this._estimatedCellSize = estimatedCellSize;
            }
            // Used in deferred mode to track which cells have been queued for measurement.
            // Cache of size and position data for cells, mapped by cell index.
            // Note that invalid values may exist in this map so only rely on cells up to this._lastMeasuredIndex
            return _createClass(CellSizeAndPositionManager, [ {
                key: "areOffsetsAdjusted",
                value: function() {
                    return !1;
                }
            }, {
                key: "configure",
                value: function(_ref2) {
                    var cellCount = _ref2.cellCount, estimatedCellSize = _ref2.estimatedCellSize;
                    this._cellCount = cellCount, this._estimatedCellSize = estimatedCellSize;
                }
            }, {
                key: "getCellCount",
                value: function() {
                    return this._cellCount;
                }
            }, {
                key: "getEstimatedCellSize",
                value: function() {
                    return this._estimatedCellSize;
                }
            }, {
                key: "getLastMeasuredIndex",
                value: function() {
                    return this._lastMeasuredIndex;
                }
            }, {
                key: "getOffsetAdjustment",
                value: function() {
                    return 0;
                }
            }, {
                key: "getSizeAndPositionOfCell",
                value: function(index) {
                    if (index < 0 || index >= this._cellCount) throw Error("Requested index " + index + " is outside of range 0.." + this._cellCount);
                    if (index > this._lastMeasuredIndex) for (var lastMeasuredCellSizeAndPosition = this.getSizeAndPositionOfLastMeasuredCell(), _offset = lastMeasuredCellSizeAndPosition.offset + lastMeasuredCellSizeAndPosition.size, i = this._lastMeasuredIndex + 1; i <= index; i++) {
                        var _size = this._cellSizeGetter({
                            index: i
                        });
                        // undefined or NaN probably means a logic error in the size getter.
                        // null means we're using CellMeasurer and haven't yet measured a given index.
                        if (void 0 === _size || isNaN(_size)) throw Error("Invalid size returned for cell " + i + " of value " + _size);
                        null === _size ? (this._cellSizeAndPositionData[i] = {
                            offset: _offset,
                            size: 0
                        }, this._lastBatchedIndex = index) : (this._cellSizeAndPositionData[i] = {
                            offset: _offset,
                            size: _size
                        }, _offset += _size, this._lastMeasuredIndex = index);
                    }
                    return this._cellSizeAndPositionData[index];
                }
            }, {
                key: "getSizeAndPositionOfLastMeasuredCell",
                value: function() {
                    return this._lastMeasuredIndex >= 0 ? this._cellSizeAndPositionData[this._lastMeasuredIndex] : {
                        offset: 0,
                        size: 0
                    };
                }
            }, {
                key: "getTotalSize",
                value: function() {
                    var lastMeasuredCellSizeAndPosition = this.getSizeAndPositionOfLastMeasuredCell(), totalSizeOfMeasuredCells = lastMeasuredCellSizeAndPosition.offset + lastMeasuredCellSizeAndPosition.size, numUnmeasuredCells = this._cellCount - this._lastMeasuredIndex - 1, totalSizeOfUnmeasuredCells = numUnmeasuredCells * this._estimatedCellSize;
                    return totalSizeOfMeasuredCells + totalSizeOfUnmeasuredCells;
                }
            }, {
                key: "getUpdatedOffsetForIndex",
                value: function(_ref3) {
                    var _ref3$align = _ref3.align, align = void 0 === _ref3$align ? "auto" : _ref3$align, containerSize = _ref3.containerSize, currentOffset = _ref3.currentOffset, targetIndex = _ref3.targetIndex;
                    if (containerSize <= 0) return 0;
                    var datum = this.getSizeAndPositionOfCell(targetIndex), maxOffset = datum.offset, minOffset = maxOffset - containerSize + datum.size, idealOffset = void 0;
                    switch (align) {
                      case "start":
                        idealOffset = maxOffset;
                        break;

                      case "end":
                        idealOffset = minOffset;
                        break;

                      case "center":
                        idealOffset = maxOffset - (containerSize - datum.size) / 2;
                        break;

                      default:
                        idealOffset = Math.max(minOffset, Math.min(maxOffset, currentOffset));
                    }
                    var totalSize = this.getTotalSize();
                    return Math.max(0, Math.min(totalSize - containerSize, idealOffset));
                }
            }, {
                key: "getVisibleCellRange",
                value: function(params) {
                    // Advanced use-cases (eg CellMeasurer) require batched measurements to determine accurate sizes.
                    // eg we can't know a row's height without measuring the height of all columns within that row.
                    if (this._batchAllCells) return {
                        start: 0,
                        stop: this._cellCount - 1
                    };
                    var containerSize = params.containerSize, offset = params.offset, totalSize = this.getTotalSize();
                    if (0 === totalSize) return {};
                    var maxOffset = offset + containerSize, start = this._findNearestCell(offset), datum = this.getSizeAndPositionOfCell(start);
                    offset = datum.offset + datum.size;
                    for (var stop = start; offset < maxOffset && stop < this._cellCount - 1; ) stop++, 
                    offset += this.getSizeAndPositionOfCell(stop).size;
                    return {
                        start: start,
                        stop: stop
                    };
                }
            }, {
                key: "resetCell",
                value: function(index) {
                    this._lastMeasuredIndex = Math.min(this._lastMeasuredIndex, index - 1);
                }
            }, {
                key: "_binarySearch",
                value: function(high, low, offset) {
                    for (;low <= high; ) {
                        var middle = low + Math.floor((high - low) / 2), _currentOffset = this.getSizeAndPositionOfCell(middle).offset;
                        if (_currentOffset === offset) return middle;
                        _currentOffset < offset ? low = middle + 1 : _currentOffset > offset && (high = middle - 1);
                    }
                    return low > 0 ? low - 1 : 0;
                }
            }, {
                key: "_exponentialSearch",
                value: function(index, offset) {
                    for (var interval = 1; index < this._cellCount && this.getSizeAndPositionOfCell(index).offset < offset; ) index += interval, 
                    interval *= 2;
                    return this._binarySearch(Math.min(index, this._cellCount - 1), Math.floor(index / 2), offset);
                }
            }, {
                key: "_findNearestCell",
                value: function(offset) {
                    if (isNaN(offset)) throw Error("Invalid offset " + offset + " specified");
                    // Our search algorithms find the nearest match at or below the specified offset.
                    // So make sure the offset is at least 0 or no match will be found.
                    offset = Math.max(0, offset);
                    var lastMeasuredCellSizeAndPosition = this.getSizeAndPositionOfLastMeasuredCell(), lastMeasuredIndex = Math.max(0, this._lastMeasuredIndex);
                    return lastMeasuredCellSizeAndPosition.offset >= offset ? this._binarySearch(lastMeasuredIndex, 0, offset) : this._exponentialSearch(lastMeasuredIndex, offset);
                }
            } ]), CellSizeAndPositionManager;
        }());
        exports.default = CellSizeAndPositionManager;
    }, /* 171 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        var _react = __webpack_require__(108), _ScalingCellSizeAndPositionManager = (_interopRequireDefault(_react), 
        __webpack_require__(169)), _ScalingCellSizeAndPositionManager2 = _interopRequireDefault(_ScalingCellSizeAndPositionManager);
        Object.defineProperty(exports, "babelPluginFlowReactPropTypes_proptype_CellPosition", {
            value: {
                columnIndex: __webpack_require__(109).number.isRequired,
                rowIndex: __webpack_require__(109).number.isRequired
            },
            configurable: !0
        }), Object.defineProperty(exports, "babelPluginFlowReactPropTypes_proptype_CellRendererParams", {
            value: {
                columnIndex: __webpack_require__(109).number.isRequired,
                isScrolling: __webpack_require__(109).bool.isRequired,
                isVisible: __webpack_require__(109).bool.isRequired,
                key: __webpack_require__(109).string.isRequired,
                parent: __webpack_require__(109).object.isRequired,
                rowIndex: __webpack_require__(109).number.isRequired,
                style: __webpack_require__(109).object.isRequired
            },
            configurable: !0
        }), Object.defineProperty(exports, "babelPluginFlowReactPropTypes_proptype_CellRenderer", {
            value: __webpack_require__(109).func,
            configurable: !0
        }), Object.defineProperty(exports, "babelPluginFlowReactPropTypes_proptype_CellRangeRendererParams", {
            value: {
                cellCache: __webpack_require__(109).object.isRequired,
                cellRenderer: __webpack_require__(109).func.isRequired,
                columnSizeAndPositionManager: "function" == typeof _ScalingCellSizeAndPositionManager2.default ? __webpack_require__(109).instanceOf(_ScalingCellSizeAndPositionManager2.default).isRequired : __webpack_require__(109).any.isRequired,
                columnStartIndex: __webpack_require__(109).number.isRequired,
                columnStopIndex: __webpack_require__(109).number.isRequired,
                deferredMeasurementCache: __webpack_require__(109).object,
                horizontalOffsetAdjustment: __webpack_require__(109).number.isRequired,
                isScrolling: __webpack_require__(109).bool.isRequired,
                parent: __webpack_require__(109).object.isRequired,
                rowSizeAndPositionManager: "function" == typeof _ScalingCellSizeAndPositionManager2.default ? __webpack_require__(109).instanceOf(_ScalingCellSizeAndPositionManager2.default).isRequired : __webpack_require__(109).any.isRequired,
                rowStartIndex: __webpack_require__(109).number.isRequired,
                rowStopIndex: __webpack_require__(109).number.isRequired,
                scrollLeft: __webpack_require__(109).number.isRequired,
                scrollTop: __webpack_require__(109).number.isRequired,
                styleCache: __webpack_require__(109).object.isRequired,
                verticalOffsetAdjustment: __webpack_require__(109).number.isRequired,
                visibleColumnIndices: __webpack_require__(109).object.isRequired,
                visibleRowIndices: __webpack_require__(109).object.isRequired
            },
            configurable: !0
        }), Object.defineProperty(exports, "babelPluginFlowReactPropTypes_proptype_CellRangeRenderer", {
            value: __webpack_require__(109).func,
            configurable: !0
        }), Object.defineProperty(exports, "babelPluginFlowReactPropTypes_proptype_CellSizeGetter", {
            value: __webpack_require__(109).func,
            configurable: !0
        }), Object.defineProperty(exports, "babelPluginFlowReactPropTypes_proptype_CellSize", {
            value: __webpack_require__(109).oneOfType([ __webpack_require__(109).func, __webpack_require__(109).number ]),
            configurable: !0
        }), Object.defineProperty(exports, "babelPluginFlowReactPropTypes_proptype_NoContentRenderer", {
            value: __webpack_require__(109).func,
            configurable: !0
        }), Object.defineProperty(exports, "babelPluginFlowReactPropTypes_proptype_Scroll", {
            value: {
                clientHeight: __webpack_require__(109).number.isRequired,
                clientWidth: __webpack_require__(109).number.isRequired,
                scrollHeight: __webpack_require__(109).number.isRequired,
                scrollLeft: __webpack_require__(109).number.isRequired,
                scrollTop: __webpack_require__(109).number.isRequired,
                scrollWidth: __webpack_require__(109).number.isRequired
            },
            configurable: !0
        }), Object.defineProperty(exports, "babelPluginFlowReactPropTypes_proptype_ScrollbarPresenceChange", {
            value: {
                horizontal: __webpack_require__(109).bool.isRequired,
                vertical: __webpack_require__(109).bool.isRequired,
                size: __webpack_require__(109).number.isRequired
            },
            configurable: !0
        }), Object.defineProperty(exports, "babelPluginFlowReactPropTypes_proptype_RenderedSection", {
            value: {
                columnOverscanStartIndex: __webpack_require__(109).number.isRequired,
                columnOverscanStopIndex: __webpack_require__(109).number.isRequired,
                columnStartIndex: __webpack_require__(109).number.isRequired,
                columnStopIndex: __webpack_require__(109).number.isRequired,
                rowOverscanStartIndex: __webpack_require__(109).number.isRequired,
                rowOverscanStopIndex: __webpack_require__(109).number.isRequired,
                rowStartIndex: __webpack_require__(109).number.isRequired,
                rowStopIndex: __webpack_require__(109).number.isRequired
            },
            configurable: !0
        }), Object.defineProperty(exports, "babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetterParams", {
            value: {
                direction: __webpack_require__(109).oneOf([ "horizontal", "vertical" ]).isRequired,
                scrollDirection: __webpack_require__(109).oneOf([ -1, 1 ]).isRequired,
                cellCount: __webpack_require__(109).number.isRequired,
                overscanCellsCount: __webpack_require__(109).number.isRequired,
                startIndex: __webpack_require__(109).number.isRequired,
                stopIndex: __webpack_require__(109).number.isRequired
            },
            configurable: !0
        }), Object.defineProperty(exports, "babelPluginFlowReactPropTypes_proptype_OverscanIndices", {
            value: {
                overscanStartIndex: __webpack_require__(109).number.isRequired,
                overscanStopIndex: __webpack_require__(109).number.isRequired
            },
            configurable: !0
        }), Object.defineProperty(exports, "babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetter", {
            value: __webpack_require__(109).func,
            configurable: !0
        }), Object.defineProperty(exports, "babelPluginFlowReactPropTypes_proptype_Alignment", {
            value: __webpack_require__(109).oneOf([ "auto", "end", "start", "center" ]),
            configurable: !0
        }), Object.defineProperty(exports, "babelPluginFlowReactPropTypes_proptype_VisibleCellRange", {
            value: {
                start: __webpack_require__(109).number,
                stop: __webpack_require__(109).number
            },
            configurable: !0
        });
    }, /* 172 */
    /***/
    function(module, exports) {
        "use strict";
        /**
	 * Helper utility that updates the specified callback whenever any of the specified indices have changed.
	 */
        function createCallbackMemoizer() {
            var requireAllKeys = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0], cachedIndices = {};
            return function(_ref) {
                var callback = _ref.callback, indices = _ref.indices, keys = Object.keys(indices), allInitialized = !requireAllKeys || keys.every(function(key) {
                    var value = indices[key];
                    return Array.isArray(value) ? value.length > 0 : value >= 0;
                }), indexChanged = keys.length !== Object.keys(cachedIndices).length || keys.some(function(key) {
                    var cachedValue = cachedIndices[key], value = indices[key];
                    return Array.isArray(value) ? cachedValue.join(",") !== value.join(",") : cachedValue !== value;
                });
                cachedIndices = indices, allInitialized && indexChanged && callback(indices);
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = createCallbackMemoizer;
    }, /* 173 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        /**
	 * Calculates the number of cells to overscan before and after a specified range.
	 * This function ensures that overscanning doesn't exceed the available cells.
	 */
        function defaultOverscanIndicesGetter(_ref) {
            var cellCount = _ref.cellCount, overscanCellsCount = _ref.overscanCellsCount, scrollDirection = _ref.scrollDirection, startIndex = _ref.startIndex, stopIndex = _ref.stopIndex;
            return scrollDirection === SCROLL_DIRECTION_FORWARD ? {
                overscanStartIndex: Math.max(0, startIndex),
                overscanStopIndex: Math.min(cellCount - 1, stopIndex + overscanCellsCount)
            } : {
                overscanStartIndex: Math.max(0, startIndex - overscanCellsCount),
                overscanStopIndex: Math.min(cellCount - 1, stopIndex)
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = defaultOverscanIndicesGetter;
        var SCROLL_DIRECTION_FORWARD = (__webpack_require__(171).babelPluginFlowReactPropTypes_proptype_OverscanIndices || __webpack_require__(109).any, 
        __webpack_require__(171).babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetterParams || __webpack_require__(109).any, 
        exports.SCROLL_DIRECTION_BACKWARD = -1, exports.SCROLL_DIRECTION_FORWARD = 1);
        exports.SCROLL_DIRECTION_HORIZONTAL = "horizontal", exports.SCROLL_DIRECTION_VERTICAL = "vertical";
    }, /* 174 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        /**
	 * Helper function that determines when to update scroll offsets to ensure that a scroll-to-index remains visible.
	 * This function also ensures that the scroll ofset isn't past the last column/row of cells.
	 */
        function updateScrollIndexHelper(_ref) {
            var cellSize = _ref.cellSize, cellSizeAndPositionManager = _ref.cellSizeAndPositionManager, previousCellsCount = _ref.previousCellsCount, previousCellSize = _ref.previousCellSize, previousScrollToAlignment = _ref.previousScrollToAlignment, previousScrollToIndex = _ref.previousScrollToIndex, previousSize = _ref.previousSize, scrollOffset = _ref.scrollOffset, scrollToAlignment = _ref.scrollToAlignment, scrollToIndex = _ref.scrollToIndex, size = _ref.size, sizeJustIncreasedFromZero = _ref.sizeJustIncreasedFromZero, updateScrollIndexCallback = _ref.updateScrollIndexCallback, cellCount = cellSizeAndPositionManager.getCellCount(), hasScrollToIndex = scrollToIndex >= 0 && scrollToIndex < cellCount, sizeHasChanged = size !== previousSize || sizeJustIncreasedFromZero || !previousCellSize || "number" == typeof cellSize && cellSize !== previousCellSize;
            // If we have a new scroll target OR if height/row-height has changed,
            // We should ensure that the scroll target is visible.
            hasScrollToIndex && (sizeHasChanged || scrollToAlignment !== previousScrollToAlignment || scrollToIndex !== previousScrollToIndex) ? updateScrollIndexCallback(scrollToIndex) : !hasScrollToIndex && cellCount > 0 && (size < previousSize || cellCount < previousCellsCount) && scrollOffset > cellSizeAndPositionManager.getTotalSize() - size && updateScrollIndexCallback(cellCount - 1);
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = updateScrollIndexHelper;
        var _ScalingCellSizeAndPositionManager = __webpack_require__(169);
        _interopRequireDefault(_ScalingCellSizeAndPositionManager), __webpack_require__(171).babelPluginFlowReactPropTypes_proptype_Alignment || __webpack_require__(109).any;
    }, /* 175 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(process) {
            "use strict";
            function defaultCellRangeRenderer(_ref) {
                for (var cellCache = _ref.cellCache, cellRenderer = _ref.cellRenderer, columnSizeAndPositionManager = _ref.columnSizeAndPositionManager, columnStartIndex = _ref.columnStartIndex, columnStopIndex = _ref.columnStopIndex, deferredMeasurementCache = _ref.deferredMeasurementCache, horizontalOffsetAdjustment = _ref.horizontalOffsetAdjustment, isScrolling = _ref.isScrolling, parent = _ref.parent, rowSizeAndPositionManager = _ref.rowSizeAndPositionManager, rowStartIndex = _ref.rowStartIndex, rowStopIndex = _ref.rowStopIndex, styleCache = _ref.styleCache, verticalOffsetAdjustment = _ref.verticalOffsetAdjustment, visibleColumnIndices = _ref.visibleColumnIndices, visibleRowIndices = _ref.visibleRowIndices, renderedCells = [], areOffsetsAdjusted = columnSizeAndPositionManager.areOffsetsAdjusted() || rowSizeAndPositionManager.areOffsetsAdjusted(), canCacheStyle = !isScrolling && !areOffsetsAdjusted, rowIndex = rowStartIndex; rowIndex <= rowStopIndex; rowIndex++) for (var rowDatum = rowSizeAndPositionManager.getSizeAndPositionOfCell(rowIndex), columnIndex = columnStartIndex; columnIndex <= columnStopIndex; columnIndex++) {
                    var columnDatum = columnSizeAndPositionManager.getSizeAndPositionOfCell(columnIndex), isVisible = columnIndex >= visibleColumnIndices.start && columnIndex <= visibleColumnIndices.stop && rowIndex >= visibleRowIndices.start && rowIndex <= visibleRowIndices.stop, key = rowIndex + "-" + columnIndex, style = void 0;
                    // Cache style objects so shallow-compare doesn't re-render unnecessarily.
                    canCacheStyle && styleCache[key] ? style = styleCache[key] : // In deferred mode, cells will be initially rendered before we know their size.
                    // Don't interfere with CellMeasurer's measurements by setting an invalid size.
                    deferredMeasurementCache && !deferredMeasurementCache.has(rowIndex, columnIndex) ? // Position not-yet-measured cells at top/left 0,0,
                    // And give them width/height of 'auto' so they can grow larger than the parent Grid if necessary.
                    // Positioning them further to the right/bottom influences their measured size.
                    style = {
                        height: "auto",
                        left: 0,
                        position: "absolute",
                        top: 0,
                        width: "auto"
                    } : (style = {
                        height: rowDatum.size,
                        left: columnDatum.offset + horizontalOffsetAdjustment,
                        position: "absolute",
                        top: rowDatum.offset + verticalOffsetAdjustment,
                        width: columnDatum.size
                    }, styleCache[key] = style);
                    var cellRendererParams = {
                        columnIndex: columnIndex,
                        isScrolling: isScrolling,
                        isVisible: isVisible,
                        key: key,
                        parent: parent,
                        rowIndex: rowIndex,
                        style: style
                    }, renderedCell = void 0;
                    // Avoid re-creating cells while scrolling.
                    // This can lead to the same cell being created many times and can cause performance issues for "heavy" cells.
                    // If a scroll is in progress- cache and reuse cells.
                    // This cache will be thrown away once scrolling completes.
                    // However if we are scaling scroll positions and sizes, we should also avoid caching.
                    // This is because the offset changes slightly as scroll position changes and caching leads to stale values.
                    // For more info refer to issue #395
                    !isScrolling || horizontalOffsetAdjustment || verticalOffsetAdjustment ? renderedCell = cellRenderer(cellRendererParams) : (cellCache[key] || (cellCache[key] = cellRenderer(cellRendererParams)), 
                    renderedCell = cellCache[key]), null != renderedCell && renderedCell !== !1 && ("production" !== process.env.NODE_ENV && warnAboutMissingStyle(parent, renderedCell), 
                    renderedCells.push(renderedCell));
                }
                return renderedCells;
            }
            function warnAboutMissingStyle(parent, renderedCell) {
                "production" !== process.env.NODE_ENV && renderedCell && (// If the direct child is a CellMeasurer, then we should check its child
                // See issue #611
                renderedCell.type && renderedCell.type.__internalCellMeasurerFlag && (renderedCell = renderedCell.props.children), 
                renderedCell && renderedCell.props && void 0 === renderedCell.props.style && parent.__warnedAboutMissingStyle !== !0 && (parent.__warnedAboutMissingStyle = !0, 
                console.warn("Rendered cell should include style property for positioning.")));
            }
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.default = defaultCellRangeRenderer;
            /**
	 * Default implementation of cellRangeRenderer used by Grid.
	 * This renderer supports cell-caching while the user is scrolling.
	 */
            __webpack_require__(171).babelPluginFlowReactPropTypes_proptype_CellRangeRendererParams || __webpack_require__(109).any;
        }).call(exports, __webpack_require__(110));
    }, /* 176 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = function(recalc) {
            if ((!size || recalc) && _inDOM2.default) {
                var scrollDiv = document.createElement("div");
                scrollDiv.style.position = "absolute", scrollDiv.style.top = "-9999px", scrollDiv.style.width = "50px", 
                scrollDiv.style.height = "50px", scrollDiv.style.overflow = "scroll", document.body.appendChild(scrollDiv), 
                size = scrollDiv.offsetWidth - scrollDiv.clientWidth, document.body.removeChild(scrollDiv);
            }
            return size;
        };
        var _inDOM = __webpack_require__(177), _inDOM2 = _interopRequireDefault(_inDOM), size = void 0;
        module.exports = exports.default;
    }, /* 177 */
    /***/
    function(module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = !("undefined" == typeof window || !window.document || !window.document.createElement), 
        module.exports = exports.default;
    }, /* 178 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.requestAnimationTimeout = exports.cancelAnimationTimeout = void 0;
        var _animationFrame = __webpack_require__(179);
        Object.defineProperty(exports, "babelPluginFlowReactPropTypes_proptype_AnimationTimeoutId", {
            value: {
                id: __webpack_require__(109).number.isRequired
            },
            configurable: !0
        });
        exports.cancelAnimationTimeout = function(frame) {
            return (0, _animationFrame.caf)(frame.id);
        }, exports.requestAnimationTimeout = function(callback, delay) {
            var start = Date.now(), timeout = function timeout() {
                Date.now() - start >= delay ? callback.call() : frame.id = (0, _animationFrame.raf)(timeout);
            }, frame = {
                id: (0, _animationFrame.raf)(timeout)
            };
            return frame;
        };
    }, /* 179 */
    /***/
    function(module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        // Properly handle server-side rendering.
        var win = void 0;
        win = "undefined" != typeof window ? window : "undefined" != typeof self ? self : {};
        // requestAnimationFrame() shim by Paul Irish
        // http://paulirish.com/2011/requestanimationframe-for-smart-animating/
        var request = win.requestAnimationFrame || win.webkitRequestAnimationFrame || win.mozRequestAnimationFrame || win.oRequestAnimationFrame || win.msRequestAnimationFrame || function(callback) {
            return win.setTimeout(callback, 1e3 / 60);
        }, cancel = win.cancelAnimationFrame || win.webkitCancelAnimationFrame || win.mozCancelAnimationFrame || win.oCancelAnimationFrame || win.msCancelAnimationFrame || function(id) {
            win.clearTimeout(id);
        };
        exports.raf = request, exports.caf = cancel;
    }, /* 180 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        /**
	 * Calculates the number of cells to overscan before and after a specified range.
	 * This function ensures that overscanning doesn't exceed the available cells.
	 */
        function defaultOverscanIndicesGetter(_ref) {
            var cellCount = _ref.cellCount, overscanCellsCount = _ref.overscanCellsCount, scrollDirection = _ref.scrollDirection, startIndex = _ref.startIndex, stopIndex = _ref.stopIndex;
            // Make sure we render at least 1 cell extra before and after (except near boundaries)
            // This is necessary in order to support keyboard navigation (TAB/SHIFT+TAB) in some cases
            // For more info see issues #625
            return overscanCellsCount = Math.max(1, overscanCellsCount), scrollDirection === SCROLL_DIRECTION_FORWARD ? {
                overscanStartIndex: Math.max(0, startIndex - 1),
                overscanStopIndex: Math.min(cellCount - 1, stopIndex + overscanCellsCount)
            } : {
                overscanStartIndex: Math.max(0, startIndex - overscanCellsCount),
                overscanStopIndex: Math.min(cellCount - 1, stopIndex + 1)
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = defaultOverscanIndicesGetter;
        var SCROLL_DIRECTION_FORWARD = (__webpack_require__(171).babelPluginFlowReactPropTypes_proptype_OverscanIndices || __webpack_require__(109).any, 
        __webpack_require__(171).babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetterParams || __webpack_require__(109).any, 
        exports.SCROLL_DIRECTION_BACKWARD = -1, exports.SCROLL_DIRECTION_FORWARD = 1);
        exports.SCROLL_DIRECTION_HORIZONTAL = "horizontal", exports.SCROLL_DIRECTION_VERTICAL = "vertical";
    }, /* 181 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        var _react = __webpack_require__(108);
        _interopRequireDefault(_react);
        Object.defineProperty(exports, "babelPluginFlowReactPropTypes_proptype_RowRendererParams", {
            value: {
                index: __webpack_require__(109).number.isRequired,
                isScrolling: __webpack_require__(109).bool.isRequired,
                isVisible: __webpack_require__(109).bool.isRequired,
                key: __webpack_require__(109).string.isRequired,
                parent: __webpack_require__(109).object.isRequired,
                style: __webpack_require__(109).object.isRequired
            },
            configurable: !0
        }), Object.defineProperty(exports, "babelPluginFlowReactPropTypes_proptype_RowRenderer", {
            value: __webpack_require__(109).func,
            configurable: !0
        }), Object.defineProperty(exports, "babelPluginFlowReactPropTypes_proptype_RenderedRows", {
            value: {
                overscanStartIndex: __webpack_require__(109).number.isRequired,
                overscanStopIndex: __webpack_require__(109).number.isRequired,
                startIndex: __webpack_require__(109).number.isRequired,
                stopIndex: __webpack_require__(109).number.isRequired
            },
            configurable: !0
        }), Object.defineProperty(exports, "babelPluginFlowReactPropTypes_proptype_Scroll", {
            value: {
                clientHeight: __webpack_require__(109).number.isRequired,
                scrollHeight: __webpack_require__(109).number.isRequired,
                scrollTop: __webpack_require__(109).number.isRequired
            },
            configurable: !0
        });
    }, /* 182 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _taggedTemplateLiteral2 = __webpack_require__(2), _taggedTemplateLiteral3 = _interopRequireDefault(_taggedTemplateLiteral2), _templateObject = (0, 
        _taggedTemplateLiteral3.default)([ "\n  width: 2.5rem;\n  height: 2.5rem;\n  display: inline-flex;\n  flex-direction: row;\n  justify-content: center;\n  align-items: center;\n  margin-left: 0.5rem;\n  padding: 0;\n  color: #fff;\n  text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.25);\n  transition: 250ms all ease;\n" ], [ "\n  width: 2.5rem;\n  height: 2.5rem;\n  display: inline-flex;\n  flex-direction: row;\n  justify-content: center;\n  align-items: center;\n  margin-left: 0.5rem;\n  padding: 0;\n  color: #fff;\n  text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.25);\n  transition: 250ms all ease;\n" ]), _styledComponents = __webpack_require__(129), _styledComponents2 = _interopRequireDefault(_styledComponents);
        exports.default = _styledComponents2.default.button(_templateObject);
    }, /* 183 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function SvgIconWrapper(_ref) {
            var children = _ref.children, rest = (0, _objectWithoutProperties3.default)(_ref, [ "children" ]);
            return _react2.default.createElement("svg", (0, _extends3.default)({
                height: 24,
                preserveAspectRatio: "xMinYMax meet",
                viewBox: "0 0 24 24",
                width: 24
            }, rest), _react2.default.createElement("path", {
                d: "M0-.5h24v24H0z",
                fill: "none"
            }), children);
        }
        function IconLeft() {
            return _react2.default.createElement(SvgIconWrapper, null, _react2.default.createElement(Path, {
                d: "M15.41 16.09l-4.58-4.59 4.58-4.59L14 5.5l-6 6 6 6z"
            }));
        }
        function IconMore() {
            return _react2.default.createElement(SvgIconWrapper, null, _react2.default.createElement(Path, {
                d: "M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"
            }));
        }
        function IconRight() {
            return _react2.default.createElement(SvgIconWrapper, null, _react2.default.createElement(Path, {
                d: "M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"
            }));
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _extends2 = __webpack_require__(68), _extends3 = _interopRequireDefault(_extends2), _objectWithoutProperties2 = __webpack_require__(184), _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2), _taggedTemplateLiteral2 = __webpack_require__(2), _taggedTemplateLiteral3 = _interopRequireDefault(_taggedTemplateLiteral2), _templateObject = (0, 
        _taggedTemplateLiteral3.default)([ "\n  fill: currentColor;\n" ], [ "\n  fill: currentColor;\n" ]);
        exports.SvgIconWrapper = SvgIconWrapper, exports.IconLeft = IconLeft, exports.IconMore = IconMore, 
        exports.IconRight = IconRight;
        var _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _styledComponents = __webpack_require__(129), _styledComponents2 = _interopRequireDefault(_styledComponents), Path = _styledComponents2.default.path(_templateObject);
    }, /* 184 */
    /***/
    function(module, exports) {
        "use strict";
        exports.__esModule = !0, exports.default = function(obj, keys) {
            var target = {};
            for (var i in obj) keys.indexOf(i) >= 0 || Object.prototype.hasOwnProperty.call(obj, i) && (target[i] = obj[i]);
            return target;
        };
    }, /* 185 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.slideContext = exports.presentationContext = void 0;
        var _propTypes = __webpack_require__(109), _propTypes2 = _interopRequireDefault(_propTypes);
        exports.presentationContext = _propTypes2.default.shape({
            getSlideIndex: _propTypes2.default.func.isRequired,
            getSlideMetadata: _propTypes2.default.func.isRequired,
            getStepIndex: _propTypes2.default.func.isRequired,
            goBack: _propTypes2.default.func.isRequired,
            goForward: _propTypes2.default.func.isRequired,
            goToSlide: _propTypes2.default.func.isRequired,
            isAtBeginning: _propTypes2.default.func.isRequired,
            isAtEnd: _propTypes2.default.func.isRequired,
            setPluginProps: _propTypes2.default.func.isRequired
        }), exports.slideContext = _propTypes2.default.shape({
            getNumSteps: _propTypes2.default.func.isRequired,
            registerStep: _propTypes2.default.func.isRequired,
            setNumSteps: _propTypes2.default.func.isRequired
        });
    }, /* 186 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _taggedTemplateLiteral2 = __webpack_require__(2), _taggedTemplateLiteral3 = _interopRequireDefault(_taggedTemplateLiteral2), _templateObject = (0, 
        _taggedTemplateLiteral3.default)([ "\n  .Select {\n    position: relative;\n  }\n  .Select,\n  .Select div,\n  .Select input,\n  .Select span {\n    -webkit-box-sizing: border-box;\n    -moz-box-sizing: border-box;\n    box-sizing: border-box;\n  }\n  .Select.is-disabled > .Select-control {\n    background-color: #f9f9f9;\n  }\n  .Select.is-disabled > .Select-control:hover {\n    box-shadow: none;\n  }\n  .Select.is-disabled .Select-arrow-zone {\n    cursor: default;\n    pointer-events: none;\n    opacity: 0.35;\n  }\n  .Select-control {\n    background-color: #fff;\n    border-color: #d9d9d9 #ccc #b3b3b3;\n    border-radius: 4px;\n    border: 1px solid #ccc;\n    color: #333;\n    cursor: default;\n    display: table;\n    border-spacing: 0;\n    border-collapse: separate;\n    height: 36px;\n    outline: none;\n    overflow: hidden;\n    position: relative;\n    width: 100%;\n  }\n  .Select-control:hover {\n    box-shadow: 0 1px 0 rgba(0, 0, 0, 0.06);\n  }\n  .Select-control .Select-input:focus {\n    outline: none;\n  }\n  .is-searchable.is-open > .Select-control {\n    cursor: text;\n  }\n  .is-open > .Select-control {\n    border-bottom-right-radius: 0;\n    border-bottom-left-radius: 0;\n    background: #fff;\n    border-color: #b3b3b3 #ccc #d9d9d9;\n  }\n  .is-open > .Select-control > .Select-arrow {\n    border-color: transparent transparent #999;\n    border-width: 0 5px 5px;\n  }\n  .is-searchable.is-focused:not(.is-open) > .Select-control {\n    cursor: text;\n  }\n  .is-focused:not(.is-open) > .Select-control {\n    border-color: #007eff;\n    box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075), 0 0 0 3px rgba(0, 126, 255, 0.1);\n  }\n  .Select-placeholder,\n  .Select--single > .Select-control .Select-value {\n    bottom: 0;\n    color: #aaa;\n    left: 0;\n    line-height: 34px;\n    padding-left: 10px;\n    padding-right: 10px;\n    position: absolute;\n    right: 0;\n    top: 0;\n    max-width: 100%;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n  }\n  .has-value.Select--single > .Select-control .Select-value .Select-value-label,\n  .has-value.is-pseudo-focused.Select--single > .Select-control .Select-value .Select-value-label {\n    color: #333;\n  }\n  .has-value.Select--single > .Select-control .Select-value a.Select-value-label,\n  .has-value.is-pseudo-focused.Select--single > .Select-control .Select-value a.Select-value-label {\n    cursor: pointer;\n    text-decoration: none;\n  }\n  .has-value.Select--single > .Select-control .Select-value a.Select-value-label:hover,\n  .has-value.is-pseudo-focused.Select--single > .Select-control .Select-value a.Select-value-label:hover,\n  .has-value.Select--single > .Select-control .Select-value a.Select-value-label:focus,\n  .has-value.is-pseudo-focused.Select--single > .Select-control .Select-value a.Select-value-label:focus {\n    color: #007eff;\n    outline: none;\n    text-decoration: underline;\n  }\n  .Select-input {\n    height: 34px;\n    padding-left: 10px;\n    padding-right: 10px;\n    vertical-align: middle;\n  }\n  .Select-input > input {\n    width: 100%;\n    background: none transparent;\n    border: 0 none;\n    box-shadow: none;\n    cursor: default;\n    display: inline-block;\n    font-family: inherit;\n    font-size: inherit;\n    margin: 0;\n    outline: none;\n    line-height: 14px;\n    /* For IE 8 compatibility */\n    padding: 8px 0 12px;\n    /* For IE 8 compatibility */\n    -webkit-appearance: none;\n  }\n  .is-focused .Select-input > input {\n    cursor: text;\n  }\n  .has-value.is-pseudo-focused .Select-input {\n    opacity: 0;\n  }\n  .Select-control:not(.is-searchable) > .Select-input {\n    outline: none;\n  }\n  .Select-loading-zone {\n    cursor: pointer;\n    display: table-cell;\n    position: relative;\n    text-align: center;\n    vertical-align: middle;\n    width: 16px;\n  }\n  .Select-loading {\n    -webkit-animation: Select-animation-spin 400ms infinite linear;\n    -o-animation: Select-animation-spin 400ms infinite linear;\n    animation: Select-animation-spin 400ms infinite linear;\n    width: 16px;\n    height: 16px;\n    box-sizing: border-box;\n    border-radius: 50%;\n    border: 2px solid #ccc;\n    border-right-color: #333;\n    display: inline-block;\n    position: relative;\n    vertical-align: middle;\n  }\n  .Select-clear-zone {\n    -webkit-animation: Select-animation-fadeIn 200ms;\n    -o-animation: Select-animation-fadeIn 200ms;\n    animation: Select-animation-fadeIn 200ms;\n    color: #999;\n    cursor: pointer;\n    display: table-cell;\n    position: relative;\n    text-align: center;\n    vertical-align: middle;\n    width: 17px;\n  }\n  .Select-clear-zone:hover {\n    color: #D0021B;\n  }\n  .Select-clear {\n    display: inline-block;\n    font-size: 18px;\n    line-height: 1;\n  }\n  .Select--multi .Select-clear-zone {\n    width: 17px;\n  }\n  .Select-arrow-zone {\n    cursor: pointer;\n    display: table-cell;\n    position: relative;\n    text-align: center;\n    vertical-align: middle;\n    width: 25px;\n    padding-right: 5px;\n  }\n  .Select-arrow {\n    border-color: #999 transparent transparent;\n    border-style: solid;\n    border-width: 5px 5px 2.5px;\n    display: inline-block;\n    height: 0;\n    width: 0;\n  }\n  .is-open .Select-arrow,\n  .Select-arrow-zone:hover > .Select-arrow {\n    border-top-color: #666;\n  }\n  .Select--multi .Select-multi-value-wrapper {\n    display: inline-block;\n  }\n  .Select .Select-aria-only {\n    display: inline-block;\n    height: 1px;\n    width: 1px;\n    margin: -1px;\n    clip: rect(0, 0, 0, 0);\n    overflow: hidden;\n  }\n  @-webkit-keyframes Select-animation-fadeIn {\n    from {\n      opacity: 0;\n    }\n    to {\n      opacity: 1;\n    }\n  }\n  @keyframes Select-animation-fadeIn {\n    from {\n      opacity: 0;\n    }\n    to {\n      opacity: 1;\n    }\n  }\n  .Select-menu-outer {\n    border-bottom-right-radius: 4px;\n    border-bottom-left-radius: 4px;\n    background-color: #fff;\n    border: 1px solid #ccc;\n    border-top-color: #e6e6e6;\n    box-shadow: 0 1px 0 rgba(0, 0, 0, 0.06);\n    box-sizing: border-box;\n    margin-top: -1px;\n    max-height: 200px;\n    position: absolute;\n    top: 100%;\n    width: 100%;\n    z-index: 1;\n    -webkit-overflow-scrolling: touch;\n  }\n  .Select-menu {\n    max-height: 198px;\n    overflow-y: auto;\n  }\n  .Select-option {\n    box-sizing: border-box;\n    background-color: #fff;\n    color: #666666;\n    cursor: pointer;\n    display: block;\n    padding: 8px 10px;\n  }\n  .Select-option:last-child {\n    border-bottom-right-radius: 4px;\n    border-bottom-left-radius: 4px;\n  }\n  .Select-option.is-selected {\n    background-color: #f5faff;\n    /* Fallback color for IE 8 */\n    background-color: rgba(0, 126, 255, 0.04);\n    color: #333;\n  }\n  .Select-option.is-focused {\n    background-color: #ebf5ff;\n    /* Fallback color for IE 8 */\n    background-color: rgba(0, 126, 255, 0.08);\n    color: #333;\n  }\n  .Select-option.is-disabled {\n    color: #cccccc;\n    cursor: default;\n  }\n  .Select-noresults {\n    box-sizing: border-box;\n    color: #999999;\n    cursor: default;\n    display: block;\n    padding: 8px 10px;\n  }\n  .Select--multi .Select-input {\n    vertical-align: middle;\n    margin-left: 10px;\n    padding: 0;\n  }\n  .Select--multi.has-value .Select-input {\n    margin-left: 5px;\n  }\n  .Select--multi .Select-value {\n    background-color: #ebf5ff;\n    /* Fallback color for IE 8 */\n    background-color: rgba(0, 126, 255, 0.08);\n    border-radius: 2px;\n    border: 1px solid #c2e0ff;\n    /* Fallback color for IE 8 */\n    border: 1px solid rgba(0, 126, 255, 0.24);\n    color: #007eff;\n    display: inline-block;\n    font-size: 0.9em;\n    line-height: 1.4;\n    margin-left: 5px;\n    margin-top: 5px;\n    vertical-align: top;\n  }\n  .Select--multi .Select-value-icon,\n  .Select--multi .Select-value-label {\n    display: inline-block;\n    vertical-align: middle;\n  }\n  .Select--multi .Select-value-label {\n    border-bottom-right-radius: 2px;\n    border-top-right-radius: 2px;\n    cursor: default;\n    padding: 2px 5px;\n  }\n  .Select--multi a.Select-value-label {\n    color: #007eff;\n    cursor: pointer;\n    text-decoration: none;\n  }\n  .Select--multi a.Select-value-label:hover {\n    text-decoration: underline;\n  }\n  .Select--multi .Select-value-icon {\n    cursor: pointer;\n    border-bottom-left-radius: 2px;\n    border-top-left-radius: 2px;\n    border-right: 1px solid #c2e0ff;\n    /* Fallback color for IE 8 */\n    border-right: 1px solid rgba(0, 126, 255, 0.24);\n    padding: 1px 5px 3px;\n  }\n  .Select--multi .Select-value-icon:hover,\n  .Select--multi .Select-value-icon:focus {\n    background-color: #d8eafd;\n    /* Fallback color for IE 8 */\n    background-color: rgba(0, 113, 230, 0.08);\n    color: #0071e6;\n  }\n  .Select--multi .Select-value-icon:active {\n    background-color: #c2e0ff;\n    /* Fallback color for IE 8 */\n    background-color: rgba(0, 126, 255, 0.24);\n  }\n  .Select--multi.is-disabled .Select-value {\n    background-color: #fcfcfc;\n    border: 1px solid #e3e3e3;\n    color: #333;\n  }\n  .Select--multi.is-disabled .Select-value-icon {\n    cursor: not-allowed;\n    border-right: 1px solid #e3e3e3;\n  }\n  .Select--multi.is-disabled .Select-value-icon:hover,\n  .Select--multi.is-disabled .Select-value-icon:focus,\n  .Select--multi.is-disabled .Select-value-icon:active {\n    background-color: #fcfcfc;\n  }\n  @keyframes Select-animation-spin {\n    to {\n      transform: rotate(1turn);\n    }\n  }\n  @-webkit-keyframes Select-animation-spin {\n    to {\n      -webkit-transform: rotate(1turn);\n    }\n  }\n\n  .VirtualSelectGrid {\n    z-index: 1;\n  }\n\n  .VirtualizedSelectOption {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    padding: 0 .5rem;\n  }\n  .VirtualizedSelectFocusedOption {\n    background-color: rgba(0, 126, 255, 0.1);\n  }\n  .VirtualizedSelectDisabledOption {\n    opacity: 0.5;\n  }\n" ], [ "\n  .Select {\n    position: relative;\n  }\n  .Select,\n  .Select div,\n  .Select input,\n  .Select span {\n    -webkit-box-sizing: border-box;\n    -moz-box-sizing: border-box;\n    box-sizing: border-box;\n  }\n  .Select.is-disabled > .Select-control {\n    background-color: #f9f9f9;\n  }\n  .Select.is-disabled > .Select-control:hover {\n    box-shadow: none;\n  }\n  .Select.is-disabled .Select-arrow-zone {\n    cursor: default;\n    pointer-events: none;\n    opacity: 0.35;\n  }\n  .Select-control {\n    background-color: #fff;\n    border-color: #d9d9d9 #ccc #b3b3b3;\n    border-radius: 4px;\n    border: 1px solid #ccc;\n    color: #333;\n    cursor: default;\n    display: table;\n    border-spacing: 0;\n    border-collapse: separate;\n    height: 36px;\n    outline: none;\n    overflow: hidden;\n    position: relative;\n    width: 100%;\n  }\n  .Select-control:hover {\n    box-shadow: 0 1px 0 rgba(0, 0, 0, 0.06);\n  }\n  .Select-control .Select-input:focus {\n    outline: none;\n  }\n  .is-searchable.is-open > .Select-control {\n    cursor: text;\n  }\n  .is-open > .Select-control {\n    border-bottom-right-radius: 0;\n    border-bottom-left-radius: 0;\n    background: #fff;\n    border-color: #b3b3b3 #ccc #d9d9d9;\n  }\n  .is-open > .Select-control > .Select-arrow {\n    border-color: transparent transparent #999;\n    border-width: 0 5px 5px;\n  }\n  .is-searchable.is-focused:not(.is-open) > .Select-control {\n    cursor: text;\n  }\n  .is-focused:not(.is-open) > .Select-control {\n    border-color: #007eff;\n    box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075), 0 0 0 3px rgba(0, 126, 255, 0.1);\n  }\n  .Select-placeholder,\n  .Select--single > .Select-control .Select-value {\n    bottom: 0;\n    color: #aaa;\n    left: 0;\n    line-height: 34px;\n    padding-left: 10px;\n    padding-right: 10px;\n    position: absolute;\n    right: 0;\n    top: 0;\n    max-width: 100%;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n  }\n  .has-value.Select--single > .Select-control .Select-value .Select-value-label,\n  .has-value.is-pseudo-focused.Select--single > .Select-control .Select-value .Select-value-label {\n    color: #333;\n  }\n  .has-value.Select--single > .Select-control .Select-value a.Select-value-label,\n  .has-value.is-pseudo-focused.Select--single > .Select-control .Select-value a.Select-value-label {\n    cursor: pointer;\n    text-decoration: none;\n  }\n  .has-value.Select--single > .Select-control .Select-value a.Select-value-label:hover,\n  .has-value.is-pseudo-focused.Select--single > .Select-control .Select-value a.Select-value-label:hover,\n  .has-value.Select--single > .Select-control .Select-value a.Select-value-label:focus,\n  .has-value.is-pseudo-focused.Select--single > .Select-control .Select-value a.Select-value-label:focus {\n    color: #007eff;\n    outline: none;\n    text-decoration: underline;\n  }\n  .Select-input {\n    height: 34px;\n    padding-left: 10px;\n    padding-right: 10px;\n    vertical-align: middle;\n  }\n  .Select-input > input {\n    width: 100%;\n    background: none transparent;\n    border: 0 none;\n    box-shadow: none;\n    cursor: default;\n    display: inline-block;\n    font-family: inherit;\n    font-size: inherit;\n    margin: 0;\n    outline: none;\n    line-height: 14px;\n    /* For IE 8 compatibility */\n    padding: 8px 0 12px;\n    /* For IE 8 compatibility */\n    -webkit-appearance: none;\n  }\n  .is-focused .Select-input > input {\n    cursor: text;\n  }\n  .has-value.is-pseudo-focused .Select-input {\n    opacity: 0;\n  }\n  .Select-control:not(.is-searchable) > .Select-input {\n    outline: none;\n  }\n  .Select-loading-zone {\n    cursor: pointer;\n    display: table-cell;\n    position: relative;\n    text-align: center;\n    vertical-align: middle;\n    width: 16px;\n  }\n  .Select-loading {\n    -webkit-animation: Select-animation-spin 400ms infinite linear;\n    -o-animation: Select-animation-spin 400ms infinite linear;\n    animation: Select-animation-spin 400ms infinite linear;\n    width: 16px;\n    height: 16px;\n    box-sizing: border-box;\n    border-radius: 50%;\n    border: 2px solid #ccc;\n    border-right-color: #333;\n    display: inline-block;\n    position: relative;\n    vertical-align: middle;\n  }\n  .Select-clear-zone {\n    -webkit-animation: Select-animation-fadeIn 200ms;\n    -o-animation: Select-animation-fadeIn 200ms;\n    animation: Select-animation-fadeIn 200ms;\n    color: #999;\n    cursor: pointer;\n    display: table-cell;\n    position: relative;\n    text-align: center;\n    vertical-align: middle;\n    width: 17px;\n  }\n  .Select-clear-zone:hover {\n    color: #D0021B;\n  }\n  .Select-clear {\n    display: inline-block;\n    font-size: 18px;\n    line-height: 1;\n  }\n  .Select--multi .Select-clear-zone {\n    width: 17px;\n  }\n  .Select-arrow-zone {\n    cursor: pointer;\n    display: table-cell;\n    position: relative;\n    text-align: center;\n    vertical-align: middle;\n    width: 25px;\n    padding-right: 5px;\n  }\n  .Select-arrow {\n    border-color: #999 transparent transparent;\n    border-style: solid;\n    border-width: 5px 5px 2.5px;\n    display: inline-block;\n    height: 0;\n    width: 0;\n  }\n  .is-open .Select-arrow,\n  .Select-arrow-zone:hover > .Select-arrow {\n    border-top-color: #666;\n  }\n  .Select--multi .Select-multi-value-wrapper {\n    display: inline-block;\n  }\n  .Select .Select-aria-only {\n    display: inline-block;\n    height: 1px;\n    width: 1px;\n    margin: -1px;\n    clip: rect(0, 0, 0, 0);\n    overflow: hidden;\n  }\n  @-webkit-keyframes Select-animation-fadeIn {\n    from {\n      opacity: 0;\n    }\n    to {\n      opacity: 1;\n    }\n  }\n  @keyframes Select-animation-fadeIn {\n    from {\n      opacity: 0;\n    }\n    to {\n      opacity: 1;\n    }\n  }\n  .Select-menu-outer {\n    border-bottom-right-radius: 4px;\n    border-bottom-left-radius: 4px;\n    background-color: #fff;\n    border: 1px solid #ccc;\n    border-top-color: #e6e6e6;\n    box-shadow: 0 1px 0 rgba(0, 0, 0, 0.06);\n    box-sizing: border-box;\n    margin-top: -1px;\n    max-height: 200px;\n    position: absolute;\n    top: 100%;\n    width: 100%;\n    z-index: 1;\n    -webkit-overflow-scrolling: touch;\n  }\n  .Select-menu {\n    max-height: 198px;\n    overflow-y: auto;\n  }\n  .Select-option {\n    box-sizing: border-box;\n    background-color: #fff;\n    color: #666666;\n    cursor: pointer;\n    display: block;\n    padding: 8px 10px;\n  }\n  .Select-option:last-child {\n    border-bottom-right-radius: 4px;\n    border-bottom-left-radius: 4px;\n  }\n  .Select-option.is-selected {\n    background-color: #f5faff;\n    /* Fallback color for IE 8 */\n    background-color: rgba(0, 126, 255, 0.04);\n    color: #333;\n  }\n  .Select-option.is-focused {\n    background-color: #ebf5ff;\n    /* Fallback color for IE 8 */\n    background-color: rgba(0, 126, 255, 0.08);\n    color: #333;\n  }\n  .Select-option.is-disabled {\n    color: #cccccc;\n    cursor: default;\n  }\n  .Select-noresults {\n    box-sizing: border-box;\n    color: #999999;\n    cursor: default;\n    display: block;\n    padding: 8px 10px;\n  }\n  .Select--multi .Select-input {\n    vertical-align: middle;\n    margin-left: 10px;\n    padding: 0;\n  }\n  .Select--multi.has-value .Select-input {\n    margin-left: 5px;\n  }\n  .Select--multi .Select-value {\n    background-color: #ebf5ff;\n    /* Fallback color for IE 8 */\n    background-color: rgba(0, 126, 255, 0.08);\n    border-radius: 2px;\n    border: 1px solid #c2e0ff;\n    /* Fallback color for IE 8 */\n    border: 1px solid rgba(0, 126, 255, 0.24);\n    color: #007eff;\n    display: inline-block;\n    font-size: 0.9em;\n    line-height: 1.4;\n    margin-left: 5px;\n    margin-top: 5px;\n    vertical-align: top;\n  }\n  .Select--multi .Select-value-icon,\n  .Select--multi .Select-value-label {\n    display: inline-block;\n    vertical-align: middle;\n  }\n  .Select--multi .Select-value-label {\n    border-bottom-right-radius: 2px;\n    border-top-right-radius: 2px;\n    cursor: default;\n    padding: 2px 5px;\n  }\n  .Select--multi a.Select-value-label {\n    color: #007eff;\n    cursor: pointer;\n    text-decoration: none;\n  }\n  .Select--multi a.Select-value-label:hover {\n    text-decoration: underline;\n  }\n  .Select--multi .Select-value-icon {\n    cursor: pointer;\n    border-bottom-left-radius: 2px;\n    border-top-left-radius: 2px;\n    border-right: 1px solid #c2e0ff;\n    /* Fallback color for IE 8 */\n    border-right: 1px solid rgba(0, 126, 255, 0.24);\n    padding: 1px 5px 3px;\n  }\n  .Select--multi .Select-value-icon:hover,\n  .Select--multi .Select-value-icon:focus {\n    background-color: #d8eafd;\n    /* Fallback color for IE 8 */\n    background-color: rgba(0, 113, 230, 0.08);\n    color: #0071e6;\n  }\n  .Select--multi .Select-value-icon:active {\n    background-color: #c2e0ff;\n    /* Fallback color for IE 8 */\n    background-color: rgba(0, 126, 255, 0.24);\n  }\n  .Select--multi.is-disabled .Select-value {\n    background-color: #fcfcfc;\n    border: 1px solid #e3e3e3;\n    color: #333;\n  }\n  .Select--multi.is-disabled .Select-value-icon {\n    cursor: not-allowed;\n    border-right: 1px solid #e3e3e3;\n  }\n  .Select--multi.is-disabled .Select-value-icon:hover,\n  .Select--multi.is-disabled .Select-value-icon:focus,\n  .Select--multi.is-disabled .Select-value-icon:active {\n    background-color: #fcfcfc;\n  }\n  @keyframes Select-animation-spin {\n    to {\n      transform: rotate(1turn);\n    }\n  }\n  @-webkit-keyframes Select-animation-spin {\n    to {\n      -webkit-transform: rotate(1turn);\n    }\n  }\n\n  .VirtualSelectGrid {\n    z-index: 1;\n  }\n\n  .VirtualizedSelectOption {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    padding: 0 .5rem;\n  }\n  .VirtualizedSelectFocusedOption {\n    background-color: rgba(0, 126, 255, 0.1);\n  }\n  .VirtualizedSelectDisabledOption {\n    opacity: 0.5;\n  }\n" ]), _styledComponents = __webpack_require__(129);
        exports.default = (0, _styledComponents.createGlobalStyle)(_templateObject);
    }, /* 187 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _extends2 = __webpack_require__(68), _extends3 = _interopRequireDefault(_extends2), _keys = __webpack_require__(188), _keys2 = _interopRequireDefault(_keys), _getPrototypeOf = __webpack_require__(75), _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf), _classCallCheck2 = __webpack_require__(78), _classCallCheck3 = _interopRequireDefault(_classCallCheck2), _createClass2 = __webpack_require__(79), _createClass3 = _interopRequireDefault(_createClass2), _possibleConstructorReturn2 = __webpack_require__(83), _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2), _inherits2 = __webpack_require__(100), _inherits3 = _interopRequireDefault(_inherits2), _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _propTypes = __webpack_require__(109), _propTypes2 = _interopRequireDefault(_propTypes), _reactRouter = __webpack_require__(191), _reactRouterDom = __webpack_require__(216), _DefaultTheme = __webpack_require__(230), _DefaultTheme2 = _interopRequireDefault(_DefaultTheme), _PropTypes = __webpack_require__(185), _TouchNav = __webpack_require__(231), _TouchNav2 = _interopRequireDefault(_TouchNav), Presentation = function(_Component) {
            function Presentation() {
                return (0, _classCallCheck3.default)(this, Presentation), (0, _possibleConstructorReturn3.default)(this, (Presentation.__proto__ || (0, 
                _getPrototypeOf2.default)(Presentation)).apply(this, arguments));
            }
            return (0, _inherits3.default)(Presentation, _Component), (0, _createClass3.default)(Presentation, [ {
                key: "render",
                value: function() {
                    var Router = this.props.router;
                    return _react2.default.createElement(Router, null, _react2.default.createElement(PresentationInner, this.props));
                }
            } ]), Presentation;
        }(_react.Component);
        Presentation.defaultProps = {
            disableTheme: !1,
            router: _reactRouterDom.HashRouter
        }, exports.default = Presentation;
        var PresentationInner = function(_Component2) {
            function PresentationInner(props, context) {
                (0, _classCallCheck3.default)(this, PresentationInner);
                var _this2 = (0, _possibleConstructorReturn3.default)(this, (PresentationInner.__proto__ || (0, 
                _getPrototypeOf2.default)(PresentationInner)).call(this, props, context));
                return _this2.state = {
                    pluginProps: {}
                }, _this2._index = 0, _this2._slideIndex = 0, _this2._slideIndexMap = {}, _this2._stepIndex = 0, 
                _this2.getSlideIndex = _this2.getSlideIndex.bind(_this2), _this2.getSlideMetadata = _this2.getSlideMetadata.bind(_this2), 
                _this2.getStepIndex = _this2.getStepIndex.bind(_this2), _this2.goBack = _this2.goBack.bind(_this2), 
                _this2.goForward = _this2.goForward.bind(_this2), _this2.goToSlide = _this2.goToSlide.bind(_this2), 
                _this2.setPluginProps = _this2.setPluginProps.bind(_this2), _this2._onKeyDown = _this2._onKeyDown.bind(_this2), 
                _this2;
            }
            return (0, _inherits3.default)(PresentationInner, _Component2), (0, _createClass3.default)(PresentationInner, [ {
                key: "componentDidMount",
                value: function() {
                    document.body.addEventListener("keydown", this._onKeyDown);
                }
            }, {
                key: "componentWillMount",
                value: function() {
                    this._parseLocation(window.location);
                }
            }, {
                key: "componentWillUnmount",
                value: function() {
                    document.body.removeEventListener("keydown", this._onKeyDown);
                }
            }, {
                key: "componentWillUpdate",
                value: function(nextProps, nextState) {
                    this._parseLocation(window.location);
                }
            }, {
                key: "getChildContext",
                value: function() {
                    var pluginProps = this.state.pluginProps;
                    return {
                        pluginProps: pluginProps,
                        presentation: this
                    };
                }
            }, {
                key: "getSlideIndex",
                value: function() {
                    return this._slideIndex;
                }
            }, {
                key: "getSlideMetadata",
                value: function(slide) {
                    var slideIndex = this._index;
                    this._slideIndexMap[slideIndex] = slide, this._index++;
                    var path = this._createPath({
                        slideIndex: slideIndex
                    });
                    return {
                        path: path,
                        slideIndex: slideIndex
                    };
                }
            }, {
                key: "getStepIndex",
                value: function() {
                    return this._stepIndex;
                }
            }, {
                key: "goBack",
                value: function() {
                    var slideIndex = this._slideIndex, stepIndex = this._stepIndex;
                    stepIndex > 0 ? this.goToSlide({
                        slideIndex: slideIndex,
                        stepIndex: stepIndex - 1
                    }) : slideIndex > 0 && (slideIndex--, this.goToSlide({
                        slideIndex: slideIndex
                    }), stepIndex = this._getNumStepsForSlide(slideIndex) - 1, this.goToSlide({
                        slideIndex: slideIndex,
                        stepIndex: stepIndex
                    }));
                }
            }, {
                key: "goForward",
                value: function() {
                    var slideIndex = this._slideIndex, stepIndex = this._stepIndex, numCurrentSlideSteps = this._getNumStepsForSlide(slideIndex), numSlides = (0, 
                    _keys2.default)(this._slideIndexMap).length;
                    stepIndex + 1 < numCurrentSlideSteps ? stepIndex++ : slideIndex + 1 < numSlides && (slideIndex++, 
                    stepIndex = 0), this.goToSlide({
                        slideIndex: slideIndex,
                        stepIndex: stepIndex
                    });
                }
            }, {
                key: "goToSlide",
                value: function(_ref) {
                    var slideIndex = _ref.slideIndex, _ref$stepIndex = _ref.stepIndex, stepIndex = void 0 === _ref$stepIndex ? 0 : _ref$stepIndex;
                    if (slideIndex !== this._slideIndex || stepIndex !== this._stepIndex) {
                        var router = this.context.router, path = this._createPath({
                            slideIndex: slideIndex,
                            stepIndex: stepIndex
                        });
                        "function" == typeof router.replace ? router.replace(path) : router.history.replace(path), 
                        this.forceUpdate();
                    }
                }
            }, {
                key: "isAtBeginning",
                value: function() {
                    return 0 === this._slideIndex && 0 === this._stepIndex;
                }
            }, {
                key: "isAtEnd",
                value: function() {
                    var numSlides = (0, _keys2.default)(this._slideIndexMap).length, numLastSlideSteps = this._getNumStepsForSlide(numSlides - 1);
                    return this._slideIndex === numSlides - 1 && this._stepIndex === numLastSlideSteps - 1;
                }
            }, {
                key: "setPluginProps",
                value: function(props) {
                    var pluginProps = this.state.pluginProps;
                    this.setState({
                        pluginProps: (0, _extends3.default)({}, pluginProps, props)
                    });
                }
            }, {
                key: "render",
                value: function() {
                    var _props = this.props, children = _props.children, disableTheme = _props.disableTheme;
                    return _react2.default.createElement("div", {
                        style: {
                            height: "100%",
                            width: "100%"
                        }
                    }, !disableTheme && _react2.default.createElement(_DefaultTheme2.default, null), _react2.default.createElement(_reactRouterDom.Route, {
                        exact: !0,
                        path: "/",
                        render: function() {
                            return _react2.default.createElement(_reactRouter.Redirect, {
                                to: "/0/0"
                            });
                        }
                    }), "function" == typeof children ? children({
                        presentation: this
                    }) : children, _react2.default.createElement(_TouchNav2.default, null));
                }
            }, {
                key: "_createPath",
                value: function(_ref2) {
                    var slideIndex = _ref2.slideIndex, _ref2$stepIndex = _ref2.stepIndex, stepIndex = void 0 === _ref2$stepIndex ? ":step" : _ref2$stepIndex;
                    return "/" + slideIndex + "/" + stepIndex;
                }
            }, {
                key: "_getNumStepsForSlide",
                value: function(slideIndex) {
                    return this._slideIndexMap[slideIndex].getNumSteps() || 1;
                }
            }, {
                key: "_parseLocation",
                value: function(location) {
                    var parsed = (location.pathname + location.hash).match(/(\d+)\/(\d+)/);
                    parsed ? (this._slideIndex = parseInt(parsed[1], 10), this._stepIndex = parseInt(parsed[2], 10)) : (this._slideIndex = 0, 
                    this._stepIndex = 0);
                }
            }, {
                key: "_onKeyDown",
                value: function(event) {
                    if ("INPUT" !== event.target.tagName && "SELECT" !== event.target.tagName && "TEXTAREA" !== event.target.tagName && event.target.isContentEditable !== !0) switch (event.key) {
                      case "ArrowLeft":
                      case "PageUp":
                        this.goBack();
                        break;

                      case "ArrowRight":
                      case "PageDown":
                      case "Enter":
                      case " ":
                        this.goForward();
                    }
                }
            } ]), PresentationInner;
        }(_react.Component);
        PresentationInner.childContextTypes = {
            pluginProps: _propTypes2.default.object.isRequired,
            presentation: _PropTypes.presentationContext.isRequired
        }, PresentationInner.contextTypes = {
            router: _propTypes2.default.object.isRequired
        };
    }, /* 188 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = {
            default: __webpack_require__(189),
            __esModule: !0
        };
    }, /* 189 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(190), module.exports = __webpack_require__(8).Object.keys;
    }, /* 190 */
    /***/
    function(module, exports, __webpack_require__) {
        // 19.1.2.14 Object.keys(O)
        var toObject = __webpack_require__(59), $keys = __webpack_require__(22);
        __webpack_require__(41)("keys", function() {
            return function(it) {
                return $keys(toObject(it));
            };
        });
    }, /* 191 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0, exports.withRouter = exports.matchPath = exports.Switch = exports.StaticRouter = exports.Router = exports.Route = exports.Redirect = exports.Prompt = exports.MemoryRouter = void 0;
        var _MemoryRouter2 = __webpack_require__(192), _MemoryRouter3 = _interopRequireDefault(_MemoryRouter2), _Prompt2 = __webpack_require__(202), _Prompt3 = _interopRequireDefault(_Prompt2), _Redirect2 = __webpack_require__(203), _Redirect3 = _interopRequireDefault(_Redirect2), _Route2 = __webpack_require__(208), _Route3 = _interopRequireDefault(_Route2), _Router2 = __webpack_require__(200), _Router3 = _interopRequireDefault(_Router2), _StaticRouter2 = __webpack_require__(212), _StaticRouter3 = _interopRequireDefault(_StaticRouter2), _Switch2 = __webpack_require__(213), _Switch3 = _interopRequireDefault(_Switch2), _matchPath2 = __webpack_require__(209), _matchPath3 = _interopRequireDefault(_matchPath2), _withRouter2 = __webpack_require__(214), _withRouter3 = _interopRequireDefault(_withRouter2);
        exports.MemoryRouter = _MemoryRouter3.default, exports.Prompt = _Prompt3.default, 
        exports.Redirect = _Redirect3.default, exports.Route = _Route3.default, exports.Router = _Router3.default, 
        exports.StaticRouter = _StaticRouter3.default, exports.Switch = _Switch3.default, 
        exports.matchPath = _matchPath3.default, exports.withRouter = _withRouter3.default;
    }, /* 192 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        exports.__esModule = !0;
        var _warning = __webpack_require__(193), _warning2 = _interopRequireDefault(_warning), _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _propTypes = __webpack_require__(109), _propTypes2 = _interopRequireDefault(_propTypes), _createMemoryHistory = __webpack_require__(194), _createMemoryHistory2 = _interopRequireDefault(_createMemoryHistory), _Router = __webpack_require__(200), _Router2 = _interopRequireDefault(_Router), MemoryRouter = function(_React$Component) {
            function MemoryRouter() {
                var _temp, _this, _ret;
                _classCallCheck(this, MemoryRouter);
                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                return _temp = _this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [ this ].concat(args))), 
                _this.history = (0, _createMemoryHistory2.default)(_this.props), _ret = _temp, _possibleConstructorReturn(_this, _ret);
            }
            return _inherits(MemoryRouter, _React$Component), MemoryRouter.prototype.componentWillMount = function() {
                (0, _warning2.default)(!this.props.history, "<MemoryRouter> ignores the history prop. To use a custom history, use `import { Router }` instead of `import { MemoryRouter as Router }`.");
            }, MemoryRouter.prototype.render = function() {
                return _react2.default.createElement(_Router2.default, {
                    history: this.history,
                    children: this.props.children
                });
            }, MemoryRouter;
        }(_react2.default.Component);
        MemoryRouter.propTypes = {
            initialEntries: _propTypes2.default.array,
            initialIndex: _propTypes2.default.number,
            getUserConfirmation: _propTypes2.default.func,
            keyLength: _propTypes2.default.number,
            children: _propTypes2.default.node
        }, exports.default = MemoryRouter;
    }, /* 193 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(process) {
            /**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
            "use strict";
            /**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */
            var warning = function() {};
            "production" !== process.env.NODE_ENV && (warning = function(condition, format, args) {
                var len = arguments.length;
                args = new Array(len > 2 ? len - 2 : 0);
                for (var key = 2; key < len; key++) args[key - 2] = arguments[key];
                if (void 0 === format) throw new Error("`warning(condition, format, ...args)` requires a warning message argument");
                if (format.length < 10 || /^[s\W]*$/.test(format)) throw new Error("The warning format should be able to uniquely identify this warning. Please, use a more descriptive format than: " + format);
                if (!condition) {
                    var argIndex = 0, message = "Warning: " + format.replace(/%s/g, function() {
                        return args[argIndex++];
                    });
                    "undefined" != typeof console && console.error(message);
                    try {
                        // This error was thrown as a convenience so that you can use this stack
                        // to find the callsite that caused this warning to fire.
                        throw new Error(message);
                    } catch (x) {}
                }
            }), module.exports = warning;
        }).call(exports, __webpack_require__(110));
    }, /* 194 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0;
        var _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
            return typeof obj;
        } : function(obj) {
            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        }, _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        }, _warning = __webpack_require__(193), _warning2 = _interopRequireDefault(_warning), _PathUtils = __webpack_require__(195), _LocationUtils = __webpack_require__(196), _createTransitionManager = __webpack_require__(199), _createTransitionManager2 = _interopRequireDefault(_createTransitionManager), clamp = function(n, lowerBound, upperBound) {
            return Math.min(Math.max(n, lowerBound), upperBound);
        }, createMemoryHistory = function() {
            var props = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, getUserConfirmation = props.getUserConfirmation, _props$initialEntries = props.initialEntries, initialEntries = void 0 === _props$initialEntries ? [ "/" ] : _props$initialEntries, _props$initialIndex = props.initialIndex, initialIndex = void 0 === _props$initialIndex ? 0 : _props$initialIndex, _props$keyLength = props.keyLength, keyLength = void 0 === _props$keyLength ? 6 : _props$keyLength, transitionManager = (0, 
            _createTransitionManager2.default)(), setState = function(nextState) {
                _extends(history, nextState), history.length = history.entries.length, transitionManager.notifyListeners(history.location, history.action);
            }, createKey = function() {
                return Math.random().toString(36).substr(2, keyLength);
            }, index = clamp(initialIndex, 0, initialEntries.length - 1), entries = initialEntries.map(function(entry) {
                return "string" == typeof entry ? (0, _LocationUtils.createLocation)(entry, void 0, createKey()) : (0, 
                _LocationUtils.createLocation)(entry, void 0, entry.key || createKey());
            }), createHref = _PathUtils.createPath, push = function(path, state) {
                (0, _warning2.default)(!("object" === ("undefined" == typeof path ? "undefined" : _typeof(path)) && void 0 !== path.state && void 0 !== state), "You should avoid providing a 2nd state argument to push when the 1st argument is a location-like object that already has state; it is ignored");
                var action = "PUSH", location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);
                transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
                    if (ok) {
                        var prevIndex = history.index, nextIndex = prevIndex + 1, nextEntries = history.entries.slice(0);
                        nextEntries.length > nextIndex ? nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location) : nextEntries.push(location), 
                        setState({
                            action: action,
                            location: location,
                            index: nextIndex,
                            entries: nextEntries
                        });
                    }
                });
            }, replace = function(path, state) {
                (0, _warning2.default)(!("object" === ("undefined" == typeof path ? "undefined" : _typeof(path)) && void 0 !== path.state && void 0 !== state), "You should avoid providing a 2nd state argument to replace when the 1st argument is a location-like object that already has state; it is ignored");
                var action = "REPLACE", location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);
                transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
                    ok && (history.entries[history.index] = location, setState({
                        action: action,
                        location: location
                    }));
                });
            }, go = function(n) {
                var nextIndex = clamp(history.index + n, 0, history.entries.length - 1), action = "POP", location = history.entries[nextIndex];
                transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
                    ok ? setState({
                        action: action,
                        location: location,
                        index: nextIndex
                    }) : // Mimic the behavior of DOM histories by
                    // causing a render after a cancelled POP.
                    setState();
                });
            }, goBack = function() {
                return go(-1);
            }, goForward = function() {
                return go(1);
            }, canGo = function(n) {
                var nextIndex = history.index + n;
                return nextIndex >= 0 && nextIndex < history.entries.length;
            }, block = function() {
                var prompt = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                return transitionManager.setPrompt(prompt);
            }, listen = function(listener) {
                return transitionManager.appendListener(listener);
            }, history = {
                length: entries.length,
                action: "POP",
                location: entries[index],
                index: index,
                entries: entries,
                createHref: createHref,
                push: push,
                replace: replace,
                go: go,
                goBack: goBack,
                goForward: goForward,
                canGo: canGo,
                block: block,
                listen: listen
            };
            return history;
        };
        exports.default = createMemoryHistory;
    }, /* 195 */
    /***/
    function(module, exports) {
        "use strict";
        exports.__esModule = !0;
        var hasBasename = (exports.addLeadingSlash = function(path) {
            return "/" === path.charAt(0) ? path : "/" + path;
        }, exports.stripLeadingSlash = function(path) {
            return "/" === path.charAt(0) ? path.substr(1) : path;
        }, exports.hasBasename = function(path, prefix) {
            return new RegExp("^" + prefix + "(\\/|\\?|#|$)", "i").test(path);
        });
        exports.stripBasename = function(path, prefix) {
            return hasBasename(path, prefix) ? path.substr(prefix.length) : path;
        }, exports.stripTrailingSlash = function(path) {
            return "/" === path.charAt(path.length - 1) ? path.slice(0, -1) : path;
        }, exports.parsePath = function(path) {
            var pathname = path || "/", search = "", hash = "", hashIndex = pathname.indexOf("#");
            hashIndex !== -1 && (hash = pathname.substr(hashIndex), pathname = pathname.substr(0, hashIndex));
            var searchIndex = pathname.indexOf("?");
            return searchIndex !== -1 && (search = pathname.substr(searchIndex), pathname = pathname.substr(0, searchIndex)), 
            {
                pathname: pathname,
                search: "?" === search ? "" : search,
                hash: "#" === hash ? "" : hash
            };
        }, exports.createPath = function(location) {
            var pathname = location.pathname, search = location.search, hash = location.hash, path = pathname || "/";
            return search && "?" !== search && (path += "?" === search.charAt(0) ? search : "?" + search), 
            hash && "#" !== hash && (path += "#" === hash.charAt(0) ? hash : "#" + hash), path;
        };
    }, /* 196 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0, exports.locationsAreEqual = exports.createLocation = void 0;
        var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        }, _resolvePathname = __webpack_require__(197), _resolvePathname2 = _interopRequireDefault(_resolvePathname), _valueEqual = __webpack_require__(198), _valueEqual2 = _interopRequireDefault(_valueEqual), _PathUtils = __webpack_require__(195);
        exports.createLocation = function(path, state, key, currentLocation) {
            var location = void 0;
            "string" == typeof path ? (// Two-arg form: push(path, state)
            location = (0, _PathUtils.parsePath)(path), location.state = state) : (// One-arg form: push(location)
            location = _extends({}, path), void 0 === location.pathname && (location.pathname = ""), 
            location.search ? "?" !== location.search.charAt(0) && (location.search = "?" + location.search) : location.search = "", 
            location.hash ? "#" !== location.hash.charAt(0) && (location.hash = "#" + location.hash) : location.hash = "", 
            void 0 !== state && void 0 === location.state && (location.state = state));
            try {
                location.pathname = decodeURI(location.pathname);
            } catch (e) {
                throw e instanceof URIError ? new URIError('Pathname "' + location.pathname + '" could not be decoded. This is likely caused by an invalid percent-encoding.') : e;
            }
            // Resolve incomplete/relative pathname relative to current location.
            // When there is no prior location and pathname is empty, set it to /
            return key && (location.key = key), currentLocation ? location.pathname ? "/" !== location.pathname.charAt(0) && (location.pathname = (0, 
            _resolvePathname2.default)(location.pathname, currentLocation.pathname)) : location.pathname = currentLocation.pathname : location.pathname || (location.pathname = "/"), 
            location;
        }, exports.locationsAreEqual = function(a, b) {
            return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && (0, 
            _valueEqual2.default)(a.state, b.state);
        };
    }, /* 197 */
    /***/
    function(module, exports) {
        "use strict";
        function isAbsolute(pathname) {
            return "/" === pathname.charAt(0);
        }
        // About 1.5x faster than the two-arg version of Array#splice()
        function spliceOne(list, index) {
            for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) list[i] = list[k];
            list.pop();
        }
        // This implementation is based heavily on node's url.parse
        function resolvePathname(to) {
            var from = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "", toParts = to && to.split("/") || [], fromParts = from && from.split("/") || [], isToAbs = to && isAbsolute(to), isFromAbs = from && isAbsolute(from), mustEndAbs = isToAbs || isFromAbs;
            if (to && isAbsolute(to) ? // to is absolute
            fromParts = toParts : toParts.length && (// to is relative, drop the filename
            fromParts.pop(), fromParts = fromParts.concat(toParts)), !fromParts.length) return "/";
            var hasTrailingSlash = void 0;
            if (fromParts.length) {
                var last = fromParts[fromParts.length - 1];
                hasTrailingSlash = "." === last || ".." === last || "" === last;
            } else hasTrailingSlash = !1;
            for (var up = 0, i = fromParts.length; i >= 0; i--) {
                var part = fromParts[i];
                "." === part ? spliceOne(fromParts, i) : ".." === part ? (spliceOne(fromParts, i), 
                up++) : up && (spliceOne(fromParts, i), up--);
            }
            if (!mustEndAbs) for (;up--; up) fromParts.unshift("..");
            !mustEndAbs || "" === fromParts[0] || fromParts[0] && isAbsolute(fromParts[0]) || fromParts.unshift("");
            var result = fromParts.join("/");
            return hasTrailingSlash && "/" !== result.substr(-1) && (result += "/"), result;
        }
        exports.__esModule = !0, exports.default = resolvePathname, module.exports = exports.default;
    }, /* 198 */
    /***/
    function(module, exports) {
        "use strict";
        function valueEqual(a, b) {
            if (a === b) return !0;
            if (null == a || null == b) return !1;
            if (Array.isArray(a)) return Array.isArray(b) && a.length === b.length && a.every(function(item, index) {
                return valueEqual(item, b[index]);
            });
            var aType = "undefined" == typeof a ? "undefined" : _typeof(a), bType = "undefined" == typeof b ? "undefined" : _typeof(b);
            if (aType !== bType) return !1;
            if ("object" === aType) {
                var aValue = a.valueOf(), bValue = b.valueOf();
                if (aValue !== a || bValue !== b) return valueEqual(aValue, bValue);
                var aKeys = Object.keys(a), bKeys = Object.keys(b);
                return aKeys.length === bKeys.length && aKeys.every(function(key) {
                    return valueEqual(a[key], b[key]);
                });
            }
            return !1;
        }
        exports.__esModule = !0;
        var _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
            return typeof obj;
        } : function(obj) {
            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
        exports.default = valueEqual, module.exports = exports.default;
    }, /* 199 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0;
        var _warning = __webpack_require__(193), _warning2 = _interopRequireDefault(_warning), createTransitionManager = function() {
            var prompt = null, setPrompt = function(nextPrompt) {
                return (0, _warning2.default)(null == prompt, "A history supports only one prompt at a time"), 
                prompt = nextPrompt, function() {
                    prompt === nextPrompt && (prompt = null);
                };
            }, confirmTransitionTo = function(location, action, getUserConfirmation, callback) {
                // TODO: If another transition starts while we're still confirming
                // the previous one, we may end up in a weird state. Figure out the
                // best way to handle this.
                if (null != prompt) {
                    var result = "function" == typeof prompt ? prompt(location, action) : prompt;
                    "string" == typeof result ? "function" == typeof getUserConfirmation ? getUserConfirmation(result, callback) : ((0, 
                    _warning2.default)(!1, "A history needs a getUserConfirmation function in order to use a prompt message"), 
                    callback(!0)) : // Return false from a transition hook to cancel the transition.
                    callback(result !== !1);
                } else callback(!0);
            }, listeners = [], appendListener = function(fn) {
                var isActive = !0, listener = function() {
                    isActive && fn.apply(void 0, arguments);
                };
                return listeners.push(listener), function() {
                    isActive = !1, listeners = listeners.filter(function(item) {
                        return item !== listener;
                    });
                };
            }, notifyListeners = function() {
                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                listeners.forEach(function(listener) {
                    return listener.apply(void 0, args);
                });
            };
            return {
                setPrompt: setPrompt,
                confirmTransitionTo: confirmTransitionTo,
                appendListener: appendListener,
                notifyListeners: notifyListeners
            };
        };
        exports.default = createTransitionManager;
    }, /* 200 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        exports.__esModule = !0;
        var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        }, _warning = __webpack_require__(193), _warning2 = _interopRequireDefault(_warning), _invariant = __webpack_require__(201), _invariant2 = _interopRequireDefault(_invariant), _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _propTypes = __webpack_require__(109), _propTypes2 = _interopRequireDefault(_propTypes), Router = function(_React$Component) {
            function Router() {
                var _temp, _this, _ret;
                _classCallCheck(this, Router);
                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                return _temp = _this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [ this ].concat(args))), 
                _this.state = {
                    match: _this.computeMatch(_this.props.history.location.pathname)
                }, _ret = _temp, _possibleConstructorReturn(_this, _ret);
            }
            return _inherits(Router, _React$Component), Router.prototype.getChildContext = function() {
                return {
                    router: _extends({}, this.context.router, {
                        history: this.props.history,
                        route: {
                            location: this.props.history.location,
                            match: this.state.match
                        }
                    })
                };
            }, Router.prototype.computeMatch = function(pathname) {
                return {
                    path: "/",
                    url: "/",
                    params: {},
                    isExact: "/" === pathname
                };
            }, Router.prototype.componentWillMount = function() {
                var _this2 = this, _props = this.props, children = _props.children, history = _props.history;
                (0, _invariant2.default)(null == children || 1 === _react2.default.Children.count(children), "A <Router> may have only one child element"), 
                // Do this here so we can setState when a <Redirect> changes the
                // location in componentWillMount. This happens e.g. when doing
                // server rendering using a <StaticRouter>.
                this.unlisten = history.listen(function() {
                    _this2.setState({
                        match: _this2.computeMatch(history.location.pathname)
                    });
                });
            }, Router.prototype.componentWillReceiveProps = function(nextProps) {
                (0, _warning2.default)(this.props.history === nextProps.history, "You cannot change <Router history>");
            }, Router.prototype.componentWillUnmount = function() {
                this.unlisten();
            }, Router.prototype.render = function() {
                var children = this.props.children;
                return children ? _react2.default.Children.only(children) : null;
            }, Router;
        }(_react2.default.Component);
        Router.propTypes = {
            history: _propTypes2.default.object.isRequired,
            children: _propTypes2.default.node
        }, Router.contextTypes = {
            router: _propTypes2.default.object
        }, Router.childContextTypes = {
            router: _propTypes2.default.object.isRequired
        }, exports.default = Router;
    }, /* 201 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(process) {
            /**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
            "use strict";
            /**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */
            var invariant = function(condition, format, a, b, c, d, e, f) {
                if ("production" !== process.env.NODE_ENV && void 0 === format) throw new Error("invariant requires an error message argument");
                if (!condition) {
                    var error;
                    if (void 0 === format) error = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."); else {
                        var args = [ a, b, c, d, e, f ], argIndex = 0;
                        error = new Error(format.replace(/%s/g, function() {
                            return args[argIndex++];
                        })), error.name = "Invariant Violation";
                    }
                    // we don't care about invariant's own frame
                    throw error.framesToPop = 1, error;
                }
            };
            module.exports = invariant;
        }).call(exports, __webpack_require__(110));
    }, /* 202 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        exports.__esModule = !0;
        var _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _propTypes = __webpack_require__(109), _propTypes2 = _interopRequireDefault(_propTypes), _invariant = __webpack_require__(201), _invariant2 = _interopRequireDefault(_invariant), Prompt = function(_React$Component) {
            function Prompt() {
                return _classCallCheck(this, Prompt), _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
            }
            return _inherits(Prompt, _React$Component), Prompt.prototype.enable = function(message) {
                this.unblock && this.unblock(), this.unblock = this.context.router.history.block(message);
            }, Prompt.prototype.disable = function() {
                this.unblock && (this.unblock(), this.unblock = null);
            }, Prompt.prototype.componentWillMount = function() {
                (0, _invariant2.default)(this.context.router, "You should not use <Prompt> outside a <Router>"), 
                this.props.when && this.enable(this.props.message);
            }, Prompt.prototype.componentWillReceiveProps = function(nextProps) {
                nextProps.when ? this.props.when && this.props.message === nextProps.message || this.enable(nextProps.message) : this.disable();
            }, Prompt.prototype.componentWillUnmount = function() {
                this.disable();
            }, Prompt.prototype.render = function() {
                return null;
            }, Prompt;
        }(_react2.default.Component);
        Prompt.propTypes = {
            when: _propTypes2.default.bool,
            message: _propTypes2.default.oneOfType([ _propTypes2.default.func, _propTypes2.default.string ]).isRequired
        }, Prompt.defaultProps = {
            when: !0
        }, Prompt.contextTypes = {
            router: _propTypes2.default.shape({
                history: _propTypes2.default.shape({
                    block: _propTypes2.default.func.isRequired
                }).isRequired
            }).isRequired
        }, exports.default = Prompt;
    }, /* 203 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        exports.__esModule = !0;
        var _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _propTypes = __webpack_require__(109), _propTypes2 = _interopRequireDefault(_propTypes), _warning = __webpack_require__(193), _warning2 = _interopRequireDefault(_warning), _invariant = __webpack_require__(201), _invariant2 = _interopRequireDefault(_invariant), _history = __webpack_require__(204), Redirect = function(_React$Component) {
            function Redirect() {
                return _classCallCheck(this, Redirect), _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
            }
            return _inherits(Redirect, _React$Component), Redirect.prototype.isStatic = function() {
                return this.context.router && this.context.router.staticContext;
            }, Redirect.prototype.componentWillMount = function() {
                (0, _invariant2.default)(this.context.router, "You should not use <Redirect> outside a <Router>"), 
                this.isStatic() && this.perform();
            }, Redirect.prototype.componentDidMount = function() {
                this.isStatic() || this.perform();
            }, Redirect.prototype.componentDidUpdate = function(prevProps) {
                var prevTo = (0, _history.createLocation)(prevProps.to), nextTo = (0, _history.createLocation)(this.props.to);
                return (0, _history.locationsAreEqual)(prevTo, nextTo) ? void (0, _warning2.default)(!1, "You tried to redirect to the same route you're currently on: " + ('"' + nextTo.pathname + nextTo.search + '"')) : void this.perform();
            }, Redirect.prototype.perform = function() {
                var history = this.context.router.history, _props = this.props, push = _props.push, to = _props.to;
                push ? history.push(to) : history.replace(to);
            }, Redirect.prototype.render = function() {
                return null;
            }, Redirect;
        }(_react2.default.Component);
        Redirect.propTypes = {
            push: _propTypes2.default.bool,
            from: _propTypes2.default.string,
            to: _propTypes2.default.oneOfType([ _propTypes2.default.string, _propTypes2.default.object ]).isRequired
        }, Redirect.defaultProps = {
            push: !1
        }, Redirect.contextTypes = {
            router: _propTypes2.default.shape({
                history: _propTypes2.default.shape({
                    push: _propTypes2.default.func.isRequired,
                    replace: _propTypes2.default.func.isRequired
                }).isRequired,
                staticContext: _propTypes2.default.object
            }).isRequired
        }, exports.default = Redirect;
    }, /* 204 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0, exports.createPath = exports.parsePath = exports.locationsAreEqual = exports.createLocation = exports.createMemoryHistory = exports.createHashHistory = exports.createBrowserHistory = void 0;
        var _LocationUtils = __webpack_require__(196);
        Object.defineProperty(exports, "createLocation", {
            enumerable: !0,
            get: function() {
                return _LocationUtils.createLocation;
            }
        }), Object.defineProperty(exports, "locationsAreEqual", {
            enumerable: !0,
            get: function() {
                return _LocationUtils.locationsAreEqual;
            }
        });
        var _PathUtils = __webpack_require__(195);
        Object.defineProperty(exports, "parsePath", {
            enumerable: !0,
            get: function() {
                return _PathUtils.parsePath;
            }
        }), Object.defineProperty(exports, "createPath", {
            enumerable: !0,
            get: function() {
                return _PathUtils.createPath;
            }
        });
        var _createBrowserHistory2 = __webpack_require__(205), _createBrowserHistory3 = _interopRequireDefault(_createBrowserHistory2), _createHashHistory2 = __webpack_require__(207), _createHashHistory3 = _interopRequireDefault(_createHashHistory2), _createMemoryHistory2 = __webpack_require__(194), _createMemoryHistory3 = _interopRequireDefault(_createMemoryHistory2);
        exports.createBrowserHistory = _createBrowserHistory3.default, exports.createHashHistory = _createHashHistory3.default, 
        exports.createMemoryHistory = _createMemoryHistory3.default;
    }, /* 205 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0;
        var _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
            return typeof obj;
        } : function(obj) {
            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        }, _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        }, _warning = __webpack_require__(193), _warning2 = _interopRequireDefault(_warning), _invariant = __webpack_require__(201), _invariant2 = _interopRequireDefault(_invariant), _LocationUtils = __webpack_require__(196), _PathUtils = __webpack_require__(195), _createTransitionManager = __webpack_require__(199), _createTransitionManager2 = _interopRequireDefault(_createTransitionManager), _DOMUtils = __webpack_require__(206), PopStateEvent = "popstate", HashChangeEvent = "hashchange", getHistoryState = function() {
            try {
                return window.history.state || {};
            } catch (e) {
                // IE 11 sometimes throws when accessing window.history.state
                // See https://github.com/ReactTraining/history/pull/289
                return {};
            }
        }, createBrowserHistory = function() {
            var props = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            (0, _invariant2.default)(_DOMUtils.canUseDOM, "Browser history needs a DOM");
            var globalHistory = window.history, canUseHistory = (0, _DOMUtils.supportsHistory)(), needsHashChangeListener = !(0, 
            _DOMUtils.supportsPopStateOnHashChange)(), _props$forceRefresh = props.forceRefresh, forceRefresh = void 0 !== _props$forceRefresh && _props$forceRefresh, _props$getUserConfirm = props.getUserConfirmation, getUserConfirmation = void 0 === _props$getUserConfirm ? _DOMUtils.getConfirmation : _props$getUserConfirm, _props$keyLength = props.keyLength, keyLength = void 0 === _props$keyLength ? 6 : _props$keyLength, basename = props.basename ? (0, 
            _PathUtils.stripTrailingSlash)((0, _PathUtils.addLeadingSlash)(props.basename)) : "", getDOMLocation = function(historyState) {
                var _ref = historyState || {}, key = _ref.key, state = _ref.state, _window$location = window.location, pathname = _window$location.pathname, search = _window$location.search, hash = _window$location.hash, path = pathname + search + hash;
                return (0, _warning2.default)(!basename || (0, _PathUtils.hasBasename)(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin with the basename. Expected path "' + path + '" to begin with "' + basename + '".'), 
                basename && (path = (0, _PathUtils.stripBasename)(path, basename)), (0, _LocationUtils.createLocation)(path, state, key);
            }, createKey = function() {
                return Math.random().toString(36).substr(2, keyLength);
            }, transitionManager = (0, _createTransitionManager2.default)(), setState = function(nextState) {
                _extends(history, nextState), history.length = globalHistory.length, transitionManager.notifyListeners(history.location, history.action);
            }, handlePopState = function(event) {
                // Ignore extraneous popstate events in WebKit.
                (0, _DOMUtils.isExtraneousPopstateEvent)(event) || handlePop(getDOMLocation(event.state));
            }, handleHashChange = function() {
                handlePop(getDOMLocation(getHistoryState()));
            }, forceNextPop = !1, handlePop = function(location) {
                if (forceNextPop) forceNextPop = !1, setState(); else {
                    var action = "POP";
                    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
                        ok ? setState({
                            action: action,
                            location: location
                        }) : revertPop(location);
                    });
                }
            }, revertPop = function(fromLocation) {
                var toLocation = history.location, toIndex = allKeys.indexOf(toLocation.key);
                toIndex === -1 && (toIndex = 0);
                var fromIndex = allKeys.indexOf(fromLocation.key);
                fromIndex === -1 && (fromIndex = 0);
                var delta = toIndex - fromIndex;
                delta && (forceNextPop = !0, go(delta));
            }, initialLocation = getDOMLocation(getHistoryState()), allKeys = [ initialLocation.key ], createHref = function(location) {
                return basename + (0, _PathUtils.createPath)(location);
            }, push = function(path, state) {
                (0, _warning2.default)(!("object" === ("undefined" == typeof path ? "undefined" : _typeof(path)) && void 0 !== path.state && void 0 !== state), "You should avoid providing a 2nd state argument to push when the 1st argument is a location-like object that already has state; it is ignored");
                var action = "PUSH", location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);
                transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
                    if (ok) {
                        var href = createHref(location), key = location.key, state = location.state;
                        if (canUseHistory) if (globalHistory.pushState({
                            key: key,
                            state: state
                        }, null, href), forceRefresh) window.location.href = href; else {
                            var prevIndex = allKeys.indexOf(history.location.key), nextKeys = allKeys.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);
                            nextKeys.push(location.key), allKeys = nextKeys, setState({
                                action: action,
                                location: location
                            });
                        } else (0, _warning2.default)(void 0 === state, "Browser history cannot push state in browsers that do not support HTML5 history"), 
                        window.location.href = href;
                    }
                });
            }, replace = function(path, state) {
                (0, _warning2.default)(!("object" === ("undefined" == typeof path ? "undefined" : _typeof(path)) && void 0 !== path.state && void 0 !== state), "You should avoid providing a 2nd state argument to replace when the 1st argument is a location-like object that already has state; it is ignored");
                var action = "REPLACE", location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);
                transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
                    if (ok) {
                        var href = createHref(location), key = location.key, state = location.state;
                        if (canUseHistory) if (globalHistory.replaceState({
                            key: key,
                            state: state
                        }, null, href), forceRefresh) window.location.replace(href); else {
                            var prevIndex = allKeys.indexOf(history.location.key);
                            prevIndex !== -1 && (allKeys[prevIndex] = location.key), setState({
                                action: action,
                                location: location
                            });
                        } else (0, _warning2.default)(void 0 === state, "Browser history cannot replace state in browsers that do not support HTML5 history"), 
                        window.location.replace(href);
                    }
                });
            }, go = function(n) {
                globalHistory.go(n);
            }, goBack = function() {
                return go(-1);
            }, goForward = function() {
                return go(1);
            }, listenerCount = 0, checkDOMListeners = function(delta) {
                listenerCount += delta, 1 === listenerCount ? ((0, _DOMUtils.addEventListener)(window, PopStateEvent, handlePopState), 
                needsHashChangeListener && (0, _DOMUtils.addEventListener)(window, HashChangeEvent, handleHashChange)) : 0 === listenerCount && ((0, 
                _DOMUtils.removeEventListener)(window, PopStateEvent, handlePopState), needsHashChangeListener && (0, 
                _DOMUtils.removeEventListener)(window, HashChangeEvent, handleHashChange));
            }, isBlocked = !1, block = function() {
                var prompt = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], unblock = transitionManager.setPrompt(prompt);
                return isBlocked || (checkDOMListeners(1), isBlocked = !0), function() {
                    return isBlocked && (isBlocked = !1, checkDOMListeners(-1)), unblock();
                };
            }, listen = function(listener) {
                var unlisten = transitionManager.appendListener(listener);
                return checkDOMListeners(1), function() {
                    checkDOMListeners(-1), unlisten();
                };
            }, history = {
                length: globalHistory.length,
                action: "POP",
                location: initialLocation,
                createHref: createHref,
                push: push,
                replace: replace,
                go: go,
                goBack: goBack,
                goForward: goForward,
                block: block,
                listen: listen
            };
            return history;
        };
        exports.default = createBrowserHistory;
    }, /* 206 */
    /***/
    function(module, exports) {
        "use strict";
        exports.__esModule = !0;
        exports.canUseDOM = !("undefined" == typeof window || !window.document || !window.document.createElement), 
        exports.addEventListener = function(node, event, listener) {
            return node.addEventListener ? node.addEventListener(event, listener, !1) : node.attachEvent("on" + event, listener);
        }, exports.removeEventListener = function(node, event, listener) {
            return node.removeEventListener ? node.removeEventListener(event, listener, !1) : node.detachEvent("on" + event, listener);
        }, exports.getConfirmation = function(message, callback) {
            return callback(window.confirm(message));
        }, exports.supportsHistory = function() {
            var ua = window.navigator.userAgent;
            return (ua.indexOf("Android 2.") === -1 && ua.indexOf("Android 4.0") === -1 || ua.indexOf("Mobile Safari") === -1 || ua.indexOf("Chrome") !== -1 || ua.indexOf("Windows Phone") !== -1) && (window.history && "pushState" in window.history);
        }, exports.supportsPopStateOnHashChange = function() {
            return window.navigator.userAgent.indexOf("Trident") === -1;
        }, exports.supportsGoWithoutReloadUsingHash = function() {
            return window.navigator.userAgent.indexOf("Firefox") === -1;
        }, exports.isExtraneousPopstateEvent = function(event) {
            return void 0 === event.state && navigator.userAgent.indexOf("CriOS") === -1;
        };
    }, /* 207 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0;
        var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        }, _warning = __webpack_require__(193), _warning2 = _interopRequireDefault(_warning), _invariant = __webpack_require__(201), _invariant2 = _interopRequireDefault(_invariant), _LocationUtils = __webpack_require__(196), _PathUtils = __webpack_require__(195), _createTransitionManager = __webpack_require__(199), _createTransitionManager2 = _interopRequireDefault(_createTransitionManager), _DOMUtils = __webpack_require__(206), HashChangeEvent = "hashchange", HashPathCoders = {
            hashbang: {
                encodePath: function(path) {
                    return "!" === path.charAt(0) ? path : "!/" + (0, _PathUtils.stripLeadingSlash)(path);
                },
                decodePath: function(path) {
                    return "!" === path.charAt(0) ? path.substr(1) : path;
                }
            },
            noslash: {
                encodePath: _PathUtils.stripLeadingSlash,
                decodePath: _PathUtils.addLeadingSlash
            },
            slash: {
                encodePath: _PathUtils.addLeadingSlash,
                decodePath: _PathUtils.addLeadingSlash
            }
        }, getHashPath = function() {
            // We can't use window.location.hash here because it's not
            // consistent across browsers - Firefox will pre-decode it!
            var href = window.location.href, hashIndex = href.indexOf("#");
            return hashIndex === -1 ? "" : href.substring(hashIndex + 1);
        }, pushHashPath = function(path) {
            return window.location.hash = path;
        }, replaceHashPath = function(path) {
            var hashIndex = window.location.href.indexOf("#");
            window.location.replace(window.location.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + "#" + path);
        }, createHashHistory = function() {
            var props = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            (0, _invariant2.default)(_DOMUtils.canUseDOM, "Hash history needs a DOM");
            var globalHistory = window.history, canGoWithoutReload = (0, _DOMUtils.supportsGoWithoutReloadUsingHash)(), _props$getUserConfirm = props.getUserConfirmation, getUserConfirmation = void 0 === _props$getUserConfirm ? _DOMUtils.getConfirmation : _props$getUserConfirm, _props$hashType = props.hashType, hashType = void 0 === _props$hashType ? "slash" : _props$hashType, basename = props.basename ? (0, 
            _PathUtils.stripTrailingSlash)((0, _PathUtils.addLeadingSlash)(props.basename)) : "", _HashPathCoders$hashT = HashPathCoders[hashType], encodePath = _HashPathCoders$hashT.encodePath, decodePath = _HashPathCoders$hashT.decodePath, getDOMLocation = function() {
                var path = decodePath(getHashPath());
                return (0, _warning2.default)(!basename || (0, _PathUtils.hasBasename)(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin with the basename. Expected path "' + path + '" to begin with "' + basename + '".'), 
                basename && (path = (0, _PathUtils.stripBasename)(path, basename)), (0, _LocationUtils.createLocation)(path);
            }, transitionManager = (0, _createTransitionManager2.default)(), setState = function(nextState) {
                _extends(history, nextState), history.length = globalHistory.length, transitionManager.notifyListeners(history.location, history.action);
            }, forceNextPop = !1, ignorePath = null, handleHashChange = function() {
                var path = getHashPath(), encodedPath = encodePath(path);
                if (path !== encodedPath) // Ensure we always have a properly-encoded hash.
                replaceHashPath(encodedPath); else {
                    var location = getDOMLocation(), prevLocation = history.location;
                    if (!forceNextPop && (0, _LocationUtils.locationsAreEqual)(prevLocation, location)) return;
                    // A hashchange doesn't always == location change.
                    if (ignorePath === (0, _PathUtils.createPath)(location)) return;
                    // Ignore this change; we already setState in push/replace.
                    ignorePath = null, handlePop(location);
                }
            }, handlePop = function(location) {
                if (forceNextPop) forceNextPop = !1, setState(); else {
                    var action = "POP";
                    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
                        ok ? setState({
                            action: action,
                            location: location
                        }) : revertPop(location);
                    });
                }
            }, revertPop = function(fromLocation) {
                var toLocation = history.location, toIndex = allPaths.lastIndexOf((0, _PathUtils.createPath)(toLocation));
                toIndex === -1 && (toIndex = 0);
                var fromIndex = allPaths.lastIndexOf((0, _PathUtils.createPath)(fromLocation));
                fromIndex === -1 && (fromIndex = 0);
                var delta = toIndex - fromIndex;
                delta && (forceNextPop = !0, go(delta));
            }, path = getHashPath(), encodedPath = encodePath(path);
            path !== encodedPath && replaceHashPath(encodedPath);
            var initialLocation = getDOMLocation(), allPaths = [ (0, _PathUtils.createPath)(initialLocation) ], createHref = function(location) {
                return "#" + encodePath(basename + (0, _PathUtils.createPath)(location));
            }, push = function(path, state) {
                (0, _warning2.default)(void 0 === state, "Hash history cannot push state; it is ignored");
                var action = "PUSH", location = (0, _LocationUtils.createLocation)(path, void 0, void 0, history.location);
                transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
                    if (ok) {
                        var path = (0, _PathUtils.createPath)(location), encodedPath = encodePath(basename + path), hashChanged = getHashPath() !== encodedPath;
                        if (hashChanged) {
                            // We cannot tell if a hashchange was caused by a PUSH, so we'd
                            // rather setState here and ignore the hashchange. The caveat here
                            // is that other hash histories in the page will consider it a POP.
                            ignorePath = path, pushHashPath(encodedPath);
                            var prevIndex = allPaths.lastIndexOf((0, _PathUtils.createPath)(history.location)), nextPaths = allPaths.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);
                            nextPaths.push(path), allPaths = nextPaths, setState({
                                action: action,
                                location: location
                            });
                        } else (0, _warning2.default)(!1, "Hash history cannot PUSH the same path; a new entry will not be added to the history stack"), 
                        setState();
                    }
                });
            }, replace = function(path, state) {
                (0, _warning2.default)(void 0 === state, "Hash history cannot replace state; it is ignored");
                var action = "REPLACE", location = (0, _LocationUtils.createLocation)(path, void 0, void 0, history.location);
                transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
                    if (ok) {
                        var path = (0, _PathUtils.createPath)(location), encodedPath = encodePath(basename + path), hashChanged = getHashPath() !== encodedPath;
                        hashChanged && (// We cannot tell if a hashchange was caused by a REPLACE, so we'd
                        // rather setState here and ignore the hashchange. The caveat here
                        // is that other hash histories in the page will consider it a POP.
                        ignorePath = path, replaceHashPath(encodedPath));
                        var prevIndex = allPaths.indexOf((0, _PathUtils.createPath)(history.location));
                        prevIndex !== -1 && (allPaths[prevIndex] = path), setState({
                            action: action,
                            location: location
                        });
                    }
                });
            }, go = function(n) {
                (0, _warning2.default)(canGoWithoutReload, "Hash history go(n) causes a full page reload in this browser"), 
                globalHistory.go(n);
            }, goBack = function() {
                return go(-1);
            }, goForward = function() {
                return go(1);
            }, listenerCount = 0, checkDOMListeners = function(delta) {
                listenerCount += delta, 1 === listenerCount ? (0, _DOMUtils.addEventListener)(window, HashChangeEvent, handleHashChange) : 0 === listenerCount && (0, 
                _DOMUtils.removeEventListener)(window, HashChangeEvent, handleHashChange);
            }, isBlocked = !1, block = function() {
                var prompt = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], unblock = transitionManager.setPrompt(prompt);
                return isBlocked || (checkDOMListeners(1), isBlocked = !0), function() {
                    return isBlocked && (isBlocked = !1, checkDOMListeners(-1)), unblock();
                };
            }, listen = function(listener) {
                var unlisten = transitionManager.appendListener(listener);
                return checkDOMListeners(1), function() {
                    checkDOMListeners(-1), unlisten();
                };
            }, history = {
                length: globalHistory.length,
                action: "POP",
                location: initialLocation,
                createHref: createHref,
                push: push,
                replace: replace,
                go: go,
                goBack: goBack,
                goForward: goForward,
                block: block,
                listen: listen
            };
            return history;
        };
        exports.default = createHashHistory;
    }, /* 208 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        exports.__esModule = !0;
        var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        }, _warning = __webpack_require__(193), _warning2 = _interopRequireDefault(_warning), _invariant = __webpack_require__(201), _invariant2 = _interopRequireDefault(_invariant), _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _propTypes = __webpack_require__(109), _propTypes2 = _interopRequireDefault(_propTypes), _matchPath = __webpack_require__(209), _matchPath2 = _interopRequireDefault(_matchPath), isEmptyChildren = function(children) {
            return 0 === _react2.default.Children.count(children);
        }, Route = function(_React$Component) {
            function Route() {
                var _temp, _this, _ret;
                _classCallCheck(this, Route);
                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                return _temp = _this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [ this ].concat(args))), 
                _this.state = {
                    match: _this.computeMatch(_this.props, _this.context.router)
                }, _ret = _temp, _possibleConstructorReturn(_this, _ret);
            }
            return _inherits(Route, _React$Component), Route.prototype.getChildContext = function() {
                return {
                    router: _extends({}, this.context.router, {
                        route: {
                            location: this.props.location || this.context.router.route.location,
                            match: this.state.match
                        }
                    })
                };
            }, Route.prototype.computeMatch = function(_ref, router) {
                var computedMatch = _ref.computedMatch, location = _ref.location, path = _ref.path, strict = _ref.strict, exact = _ref.exact, sensitive = _ref.sensitive;
                if (computedMatch) return computedMatch;
                // <Switch> already computed the match for us
                (0, _invariant2.default)(router, "You should not use <Route> or withRouter() outside a <Router>");
                var route = router.route, pathname = (location || route.location).pathname;
                return path ? (0, _matchPath2.default)(pathname, {
                    path: path,
                    strict: strict,
                    exact: exact,
                    sensitive: sensitive
                }) : route.match;
            }, Route.prototype.componentWillMount = function() {
                (0, _warning2.default)(!(this.props.component && this.props.render), "You should not use <Route component> and <Route render> in the same route; <Route render> will be ignored"), 
                (0, _warning2.default)(!(this.props.component && this.props.children && !isEmptyChildren(this.props.children)), "You should not use <Route component> and <Route children> in the same route; <Route children> will be ignored"), 
                (0, _warning2.default)(!(this.props.render && this.props.children && !isEmptyChildren(this.props.children)), "You should not use <Route render> and <Route children> in the same route; <Route children> will be ignored");
            }, Route.prototype.componentWillReceiveProps = function(nextProps, nextContext) {
                (0, _warning2.default)(!(nextProps.location && !this.props.location), '<Route> elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.'), 
                (0, _warning2.default)(!(!nextProps.location && this.props.location), '<Route> elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.'), 
                this.setState({
                    match: this.computeMatch(nextProps, nextContext.router)
                });
            }, Route.prototype.render = function render() {
                var match = this.state.match, _props = this.props, children = _props.children, component = _props.component, render = _props.render, _context$router = this.context.router, history = _context$router.history, route = _context$router.route, staticContext = _context$router.staticContext, location = this.props.location || route.location, props = {
                    match: match,
                    location: location,
                    history: history,
                    staticContext: staticContext
                };
                // component prop gets first priority, only called if there's a match
                // render prop is next, only called if there's a match
                // children come last, always called
                return component ? match ? _react2.default.createElement(component, props) : null : render ? match ? render(props) : null : children ? "function" == typeof children ? children(props) : isEmptyChildren(children) ? null : _react2.default.Children.only(children) : null;
            }, Route;
        }(_react2.default.Component);
        Route.propTypes = {
            computedMatch: _propTypes2.default.object,
            // private, from <Switch>
            path: _propTypes2.default.string,
            exact: _propTypes2.default.bool,
            strict: _propTypes2.default.bool,
            sensitive: _propTypes2.default.bool,
            component: _propTypes2.default.func,
            render: _propTypes2.default.func,
            children: _propTypes2.default.oneOfType([ _propTypes2.default.func, _propTypes2.default.node ]),
            location: _propTypes2.default.object
        }, Route.contextTypes = {
            router: _propTypes2.default.shape({
                history: _propTypes2.default.object.isRequired,
                route: _propTypes2.default.object.isRequired,
                staticContext: _propTypes2.default.object
            })
        }, Route.childContextTypes = {
            router: _propTypes2.default.object.isRequired
        }, exports.default = Route;
    }, /* 209 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0;
        var _pathToRegexp = __webpack_require__(210), _pathToRegexp2 = _interopRequireDefault(_pathToRegexp), patternCache = {}, cacheLimit = 1e4, cacheCount = 0, compilePath = function(pattern, options) {
            var cacheKey = "" + options.end + options.strict + options.sensitive, cache = patternCache[cacheKey] || (patternCache[cacheKey] = {});
            if (cache[pattern]) return cache[pattern];
            var keys = [], re = (0, _pathToRegexp2.default)(pattern, keys, options), compiledPattern = {
                re: re,
                keys: keys
            };
            return cacheCount < cacheLimit && (cache[pattern] = compiledPattern, cacheCount++), 
            compiledPattern;
        }, matchPath = function(pathname) {
            var options = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            "string" == typeof options && (options = {
                path: options
            });
            var _options = options, _options$path = _options.path, path = void 0 === _options$path ? "/" : _options$path, _options$exact = _options.exact, exact = void 0 !== _options$exact && _options$exact, _options$strict = _options.strict, strict = void 0 !== _options$strict && _options$strict, _options$sensitive = _options.sensitive, sensitive = void 0 !== _options$sensitive && _options$sensitive, _compilePath = compilePath(path, {
                end: exact,
                strict: strict,
                sensitive: sensitive
            }), re = _compilePath.re, keys = _compilePath.keys, match = re.exec(pathname);
            if (!match) return null;
            var url = match[0], values = match.slice(1), isExact = pathname === url;
            return exact && !isExact ? null : {
                path: path,
                // the path pattern used to match
                url: "/" === path && "" === url ? "/" : url,
                // the matched portion of the URL
                isExact: isExact,
                // whether or not we matched exactly
                params: keys.reduce(function(memo, key, index) {
                    return memo[key.name] = values[index], memo;
                }, {})
            };
        };
        exports.default = matchPath;
    }, /* 210 */
    /***/
    function(module, exports, __webpack_require__) {
        /**
	 * Parse a string for the raw tokens.
	 *
	 * @param  {string}  str
	 * @param  {Object=} options
	 * @return {!Array}
	 */
        function parse(str, options) {
            for (var res, tokens = [], key = 0, index = 0, path = "", defaultDelimiter = options && options.delimiter || "/"; null != (res = PATH_REGEXP.exec(str)); ) {
                var m = res[0], escaped = res[1], offset = res.index;
                // Ignore already escaped sequences.
                if (path += str.slice(index, offset), index = offset + m.length, escaped) path += escaped[1]; else {
                    var next = str[index], prefix = res[2], name = res[3], capture = res[4], group = res[5], modifier = res[6], asterisk = res[7];
                    // Push the current path onto the tokens.
                    path && (tokens.push(path), path = "");
                    var partial = null != prefix && null != next && next !== prefix, repeat = "+" === modifier || "*" === modifier, optional = "?" === modifier || "*" === modifier, delimiter = res[2] || defaultDelimiter, pattern = capture || group;
                    tokens.push({
                        name: name || key++,
                        prefix: prefix || "",
                        delimiter: delimiter,
                        optional: optional,
                        repeat: repeat,
                        partial: partial,
                        asterisk: !!asterisk,
                        pattern: pattern ? escapeGroup(pattern) : asterisk ? ".*" : "[^" + escapeString(delimiter) + "]+?"
                    });
                }
            }
            // Match any characters still remaining.
            // If the path exists, push it onto the end.
            return index < str.length && (path += str.substr(index)), path && tokens.push(path), 
            tokens;
        }
        /**
	 * Compile a string to a template function for the path.
	 *
	 * @param  {string}             str
	 * @param  {Object=}            options
	 * @return {!function(Object=, Object=)}
	 */
        function compile(str, options) {
            return tokensToFunction(parse(str, options));
        }
        /**
	 * Prettier encoding of URI path segments.
	 *
	 * @param  {string}
	 * @return {string}
	 */
        function encodeURIComponentPretty(str) {
            return encodeURI(str).replace(/[\/?#]/g, function(c) {
                return "%" + c.charCodeAt(0).toString(16).toUpperCase();
            });
        }
        /**
	 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
	 *
	 * @param  {string}
	 * @return {string}
	 */
        function encodeAsterisk(str) {
            return encodeURI(str).replace(/[?#]/g, function(c) {
                return "%" + c.charCodeAt(0).toString(16).toUpperCase();
            });
        }
        /**
	 * Expose a method for transforming tokens into the path function.
	 */
        function tokensToFunction(tokens) {
            // Compile all the patterns before compilation.
            for (var matches = new Array(tokens.length), i = 0; i < tokens.length; i++) "object" == typeof tokens[i] && (matches[i] = new RegExp("^(?:" + tokens[i].pattern + ")$"));
            return function(obj, opts) {
                for (var path = "", data = obj || {}, options = opts || {}, encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent, i = 0; i < tokens.length; i++) {
                    var token = tokens[i];
                    if ("string" != typeof token) {
                        var segment, value = data[token.name];
                        if (null == value) {
                            if (token.optional) {
                                // Prepend partial segment prefixes.
                                token.partial && (path += token.prefix);
                                continue;
                            }
                            throw new TypeError('Expected "' + token.name + '" to be defined');
                        }
                        if (isarray(value)) {
                            if (!token.repeat) throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + "`");
                            if (0 === value.length) {
                                if (token.optional) continue;
                                throw new TypeError('Expected "' + token.name + '" to not be empty');
                            }
                            for (var j = 0; j < value.length; j++) {
                                if (segment = encode(value[j]), !matches[i].test(segment)) throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + "`");
                                path += (0 === j ? token.prefix : token.delimiter) + segment;
                            }
                        } else {
                            if (segment = token.asterisk ? encodeAsterisk(value) : encode(value), !matches[i].test(segment)) throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"');
                            path += token.prefix + segment;
                        }
                    } else path += token;
                }
                return path;
            };
        }
        /**
	 * Escape a regular expression string.
	 *
	 * @param  {string} str
	 * @return {string}
	 */
        function escapeString(str) {
            return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, "\\$1");
        }
        /**
	 * Escape the capturing group by escaping special characters and meaning.
	 *
	 * @param  {string} group
	 * @return {string}
	 */
        function escapeGroup(group) {
            return group.replace(/([=!:$\/()])/g, "\\$1");
        }
        /**
	 * Attach the keys as a property of the regexp.
	 *
	 * @param  {!RegExp} re
	 * @param  {Array}   keys
	 * @return {!RegExp}
	 */
        function attachKeys(re, keys) {
            return re.keys = keys, re;
        }
        /**
	 * Get the flags for a regexp from the options.
	 *
	 * @param  {Object} options
	 * @return {string}
	 */
        function flags(options) {
            return options.sensitive ? "" : "i";
        }
        /**
	 * Pull out keys from a regexp.
	 *
	 * @param  {!RegExp} path
	 * @param  {!Array}  keys
	 * @return {!RegExp}
	 */
        function regexpToRegexp(path, keys) {
            // Use a negative lookahead to match only capturing groups.
            var groups = path.source.match(/\((?!\?)/g);
            if (groups) for (var i = 0; i < groups.length; i++) keys.push({
                name: i,
                prefix: null,
                delimiter: null,
                optional: !1,
                repeat: !1,
                partial: !1,
                asterisk: !1,
                pattern: null
            });
            return attachKeys(path, keys);
        }
        /**
	 * Transform an array into a regexp.
	 *
	 * @param  {!Array}  path
	 * @param  {Array}   keys
	 * @param  {!Object} options
	 * @return {!RegExp}
	 */
        function arrayToRegexp(path, keys, options) {
            for (var parts = [], i = 0; i < path.length; i++) parts.push(pathToRegexp(path[i], keys, options).source);
            var regexp = new RegExp("(?:" + parts.join("|") + ")", flags(options));
            return attachKeys(regexp, keys);
        }
        /**
	 * Create a path regexp from string input.
	 *
	 * @param  {string}  path
	 * @param  {!Array}  keys
	 * @param  {!Object} options
	 * @return {!RegExp}
	 */
        function stringToRegexp(path, keys, options) {
            return tokensToRegExp(parse(path, options), keys, options);
        }
        /**
	 * Expose a function for taking tokens and returning a RegExp.
	 *
	 * @param  {!Array}          tokens
	 * @param  {(Array|Object)=} keys
	 * @param  {Object=}         options
	 * @return {!RegExp}
	 */
        function tokensToRegExp(tokens, keys, options) {
            isarray(keys) || (options = /** @type {!Object} */ keys || options, keys = []), 
            options = options || {};
            // Iterate over the tokens and create our regexp string.
            for (var strict = options.strict, end = options.end !== !1, route = "", i = 0; i < tokens.length; i++) {
                var token = tokens[i];
                if ("string" == typeof token) route += escapeString(token); else {
                    var prefix = escapeString(token.prefix), capture = "(?:" + token.pattern + ")";
                    keys.push(token), token.repeat && (capture += "(?:" + prefix + capture + ")*"), 
                    capture = token.optional ? token.partial ? prefix + "(" + capture + ")?" : "(?:" + prefix + "(" + capture + "))?" : prefix + "(" + capture + ")", 
                    route += capture;
                }
            }
            var delimiter = escapeString(options.delimiter || "/"), endsWithDelimiter = route.slice(-delimiter.length) === delimiter;
            // In non-strict mode we allow a slash at the end of match. If the path to
            // match already ends with a slash, we remove it for consistency. The slash
            // is valid at the end of a path match, not in the middle. This is important
            // in non-ending mode, where "/test/" shouldn't match "/test//route".
            return strict || (route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + "(?:" + delimiter + "(?=$))?"), 
            route += end ? "$" : strict && endsWithDelimiter ? "" : "(?=" + delimiter + "|$)", 
            attachKeys(new RegExp("^" + route, flags(options)), keys);
        }
        /**
	 * Normalize the given path string, returning a regular expression.
	 *
	 * An empty array can be passed in for the keys, which will hold the
	 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
	 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
	 *
	 * @param  {(string|RegExp|Array)} path
	 * @param  {(Array|Object)=}       keys
	 * @param  {Object=}               options
	 * @return {!RegExp}
	 */
        function pathToRegexp(path, keys, options) {
            /** @type {!Object} */
            /** @type {!Array} */
            /** @type {!Array} */
            /** @type {!Array} */
            /** @type {string} */
            /** @type {!Array} */
            return isarray(keys) || (options = keys || options, keys = []), options = options || {}, 
            path instanceof RegExp ? regexpToRegexp(path, keys) : isarray(path) ? arrayToRegexp(path, keys, options) : stringToRegexp(path, keys, options);
        }
        var isarray = __webpack_require__(211);
        /**
	 * Expose `pathToRegexp`.
	 */
        module.exports = pathToRegexp, module.exports.parse = parse, module.exports.compile = compile, 
        module.exports.tokensToFunction = tokensToFunction, module.exports.tokensToRegExp = tokensToRegExp;
        /**
	 * The main path matching regexp utility.
	 *
	 * @type {RegExp}
	 */
        var PATH_REGEXP = new RegExp([ // Match escaped characters that would otherwise appear in future matches.
        // This allows the user to escape special characters that won't transform.
        "(\\\\.)", // Match Express-style parameters and un-named parameters with a prefix
        // and optional suffixes. Matches appear as:
        //
        // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
        // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
        // "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
        "([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))" ].join("|"), "g");
    }, /* 211 */
    /***/
    function(module, exports) {
        module.exports = Array.isArray || function(arr) {
            return "[object Array]" == Object.prototype.toString.call(arr);
        };
    }, /* 212 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _objectWithoutProperties(obj, keys) {
            var target = {};
            for (var i in obj) keys.indexOf(i) >= 0 || Object.prototype.hasOwnProperty.call(obj, i) && (target[i] = obj[i]);
            return target;
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        exports.__esModule = !0;
        var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        }, _warning = __webpack_require__(193), _warning2 = _interopRequireDefault(_warning), _invariant = __webpack_require__(201), _invariant2 = _interopRequireDefault(_invariant), _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _propTypes = __webpack_require__(109), _propTypes2 = _interopRequireDefault(_propTypes), _PathUtils = __webpack_require__(195), _Router = __webpack_require__(200), _Router2 = _interopRequireDefault(_Router), normalizeLocation = function(object) {
            var _object$pathname = object.pathname, pathname = void 0 === _object$pathname ? "/" : _object$pathname, _object$search = object.search, search = void 0 === _object$search ? "" : _object$search, _object$hash = object.hash, hash = void 0 === _object$hash ? "" : _object$hash;
            return {
                pathname: pathname,
                search: "?" === search ? "" : search,
                hash: "#" === hash ? "" : hash
            };
        }, addBasename = function(basename, location) {
            return basename ? _extends({}, location, {
                pathname: (0, _PathUtils.addLeadingSlash)(basename) + location.pathname
            }) : location;
        }, stripBasename = function(basename, location) {
            if (!basename) return location;
            var base = (0, _PathUtils.addLeadingSlash)(basename);
            return 0 !== location.pathname.indexOf(base) ? location : _extends({}, location, {
                pathname: location.pathname.substr(base.length)
            });
        }, createLocation = function(location) {
            return "string" == typeof location ? (0, _PathUtils.parsePath)(location) : normalizeLocation(location);
        }, createURL = function(location) {
            return "string" == typeof location ? location : (0, _PathUtils.createPath)(location);
        }, staticHandler = function(methodName) {
            return function() {
                (0, _invariant2.default)(!1, "You cannot %s with <StaticRouter>", methodName);
            };
        }, noop = function() {}, StaticRouter = function(_React$Component) {
            function StaticRouter() {
                var _temp, _this, _ret;
                _classCallCheck(this, StaticRouter);
                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                return _temp = _this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [ this ].concat(args))), 
                _this.createHref = function(path) {
                    return (0, _PathUtils.addLeadingSlash)(_this.props.basename + createURL(path));
                }, _this.handlePush = function(location) {
                    var _this$props = _this.props, basename = _this$props.basename, context = _this$props.context;
                    context.action = "PUSH", context.location = addBasename(basename, createLocation(location)), 
                    context.url = createURL(context.location);
                }, _this.handleReplace = function(location) {
                    var _this$props2 = _this.props, basename = _this$props2.basename, context = _this$props2.context;
                    context.action = "REPLACE", context.location = addBasename(basename, createLocation(location)), 
                    context.url = createURL(context.location);
                }, _this.handleListen = function() {
                    return noop;
                }, _this.handleBlock = function() {
                    return noop;
                }, _ret = _temp, _possibleConstructorReturn(_this, _ret);
            }
            return _inherits(StaticRouter, _React$Component), StaticRouter.prototype.getChildContext = function() {
                return {
                    router: {
                        staticContext: this.props.context
                    }
                };
            }, StaticRouter.prototype.componentWillMount = function() {
                (0, _warning2.default)(!this.props.history, "<StaticRouter> ignores the history prop. To use a custom history, use `import { Router }` instead of `import { StaticRouter as Router }`.");
            }, StaticRouter.prototype.render = function() {
                var _props = this.props, basename = _props.basename, location = (_props.context, 
                _props.location), props = _objectWithoutProperties(_props, [ "basename", "context", "location" ]), history = {
                    createHref: this.createHref,
                    action: "POP",
                    location: stripBasename(basename, createLocation(location)),
                    push: this.handlePush,
                    replace: this.handleReplace,
                    go: staticHandler("go"),
                    goBack: staticHandler("goBack"),
                    goForward: staticHandler("goForward"),
                    listen: this.handleListen,
                    block: this.handleBlock
                };
                return _react2.default.createElement(_Router2.default, _extends({}, props, {
                    history: history
                }));
            }, StaticRouter;
        }(_react2.default.Component);
        StaticRouter.propTypes = {
            basename: _propTypes2.default.string,
            context: _propTypes2.default.object.isRequired,
            location: _propTypes2.default.oneOfType([ _propTypes2.default.string, _propTypes2.default.object ])
        }, StaticRouter.defaultProps = {
            basename: "",
            location: "/"
        }, StaticRouter.childContextTypes = {
            router: _propTypes2.default.object.isRequired
        }, exports.default = StaticRouter;
    }, /* 213 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        exports.__esModule = !0;
        var _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _propTypes = __webpack_require__(109), _propTypes2 = _interopRequireDefault(_propTypes), _warning = __webpack_require__(193), _warning2 = _interopRequireDefault(_warning), _invariant = __webpack_require__(201), _invariant2 = _interopRequireDefault(_invariant), _matchPath = __webpack_require__(209), _matchPath2 = _interopRequireDefault(_matchPath), Switch = function(_React$Component) {
            function Switch() {
                return _classCallCheck(this, Switch), _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
            }
            return _inherits(Switch, _React$Component), Switch.prototype.componentWillMount = function() {
                (0, _invariant2.default)(this.context.router, "You should not use <Switch> outside a <Router>");
            }, Switch.prototype.componentWillReceiveProps = function(nextProps) {
                (0, _warning2.default)(!(nextProps.location && !this.props.location), '<Switch> elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.'), 
                (0, _warning2.default)(!(!nextProps.location && this.props.location), '<Switch> elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.');
            }, Switch.prototype.render = function() {
                var route = this.context.router.route, children = this.props.children, location = this.props.location || route.location, match = void 0, child = void 0;
                return _react2.default.Children.forEach(children, function(element) {
                    if (_react2.default.isValidElement(element)) {
                        var _element$props = element.props, pathProp = _element$props.path, exact = _element$props.exact, strict = _element$props.strict, sensitive = _element$props.sensitive, from = _element$props.from, path = pathProp || from;
                        null == match && (child = element, match = path ? (0, _matchPath2.default)(location.pathname, {
                            path: path,
                            exact: exact,
                            strict: strict,
                            sensitive: sensitive
                        }) : route.match);
                    }
                }), match ? _react2.default.cloneElement(child, {
                    location: location,
                    computedMatch: match
                }) : null;
            }, Switch;
        }(_react2.default.Component);
        Switch.contextTypes = {
            router: _propTypes2.default.shape({
                route: _propTypes2.default.object.isRequired
            }).isRequired
        }, Switch.propTypes = {
            children: _propTypes2.default.node,
            location: _propTypes2.default.object
        }, exports.default = Switch;
    }, /* 214 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _objectWithoutProperties(obj, keys) {
            var target = {};
            for (var i in obj) keys.indexOf(i) >= 0 || Object.prototype.hasOwnProperty.call(obj, i) && (target[i] = obj[i]);
            return target;
        }
        exports.__esModule = !0;
        var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        }, _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _propTypes = __webpack_require__(109), _propTypes2 = _interopRequireDefault(_propTypes), _hoistNonReactStatics = __webpack_require__(215), _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics), _Route = __webpack_require__(208), _Route2 = _interopRequireDefault(_Route), withRouter = function(Component) {
            var C = function(props) {
                var wrappedComponentRef = props.wrappedComponentRef, remainingProps = _objectWithoutProperties(props, [ "wrappedComponentRef" ]);
                return _react2.default.createElement(_Route2.default, {
                    render: function(routeComponentProps) {
                        return _react2.default.createElement(Component, _extends({}, remainingProps, routeComponentProps, {
                            ref: wrappedComponentRef
                        }));
                    }
                });
            };
            return C.displayName = "withRouter(" + (Component.displayName || Component.name) + ")", 
            C.WrappedComponent = Component, C.propTypes = {
                wrappedComponentRef: _propTypes2.default.func
            }, (0, _hoistNonReactStatics2.default)(C, Component);
        };
        exports.default = withRouter;
    }, /* 215 */
    /***/
    function(module, exports) {
        /**
	 * Copyright 2015, Yahoo! Inc.
	 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
	 */
        "use strict";
        var REACT_STATICS = {
            childContextTypes: !0,
            contextTypes: !0,
            defaultProps: !0,
            displayName: !0,
            getDefaultProps: !0,
            mixins: !0,
            propTypes: !0,
            type: !0
        }, KNOWN_STATICS = {
            name: !0,
            length: !0,
            prototype: !0,
            caller: !0,
            callee: !0,
            arguments: !0,
            arity: !0
        }, defineProperty = Object.defineProperty, getOwnPropertyNames = Object.getOwnPropertyNames, getOwnPropertySymbols = Object.getOwnPropertySymbols, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor, getPrototypeOf = Object.getPrototypeOf, objectPrototype = getPrototypeOf && getPrototypeOf(Object);
        module.exports = function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
            if ("string" != typeof sourceComponent) {
                // don't hoist over string (html) components
                if (objectPrototype) {
                    var inheritedComponent = getPrototypeOf(sourceComponent);
                    inheritedComponent && inheritedComponent !== objectPrototype && hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
                }
                var keys = getOwnPropertyNames(sourceComponent);
                getOwnPropertySymbols && (keys = keys.concat(getOwnPropertySymbols(sourceComponent)));
                for (var i = 0; i < keys.length; ++i) {
                    var key = keys[i];
                    if (!(REACT_STATICS[key] || KNOWN_STATICS[key] || blacklist && blacklist[key])) {
                        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
                        try {
                            // Avoid failures from read-only properties
                            defineProperty(targetComponent, key, descriptor);
                        } catch (e) {}
                    }
                }
                return targetComponent;
            }
            return targetComponent;
        };
    }, /* 216 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0, exports.withRouter = exports.matchPath = exports.Switch = exports.StaticRouter = exports.Router = exports.Route = exports.Redirect = exports.Prompt = exports.NavLink = exports.MemoryRouter = exports.Link = exports.HashRouter = exports.BrowserRouter = void 0;
        var _BrowserRouter2 = __webpack_require__(217), _BrowserRouter3 = _interopRequireDefault(_BrowserRouter2), _HashRouter2 = __webpack_require__(219), _HashRouter3 = _interopRequireDefault(_HashRouter2), _Link2 = __webpack_require__(220), _Link3 = _interopRequireDefault(_Link2), _MemoryRouter2 = __webpack_require__(221), _MemoryRouter3 = _interopRequireDefault(_MemoryRouter2), _NavLink2 = __webpack_require__(222), _NavLink3 = _interopRequireDefault(_NavLink2), _Prompt2 = __webpack_require__(224), _Prompt3 = _interopRequireDefault(_Prompt2), _Redirect2 = __webpack_require__(225), _Redirect3 = _interopRequireDefault(_Redirect2), _Route2 = __webpack_require__(223), _Route3 = _interopRequireDefault(_Route2), _Router2 = __webpack_require__(218), _Router3 = _interopRequireDefault(_Router2), _StaticRouter2 = __webpack_require__(226), _StaticRouter3 = _interopRequireDefault(_StaticRouter2), _Switch2 = __webpack_require__(227), _Switch3 = _interopRequireDefault(_Switch2), _matchPath2 = __webpack_require__(228), _matchPath3 = _interopRequireDefault(_matchPath2), _withRouter2 = __webpack_require__(229), _withRouter3 = _interopRequireDefault(_withRouter2);
        exports.BrowserRouter = _BrowserRouter3.default, exports.HashRouter = _HashRouter3.default, 
        exports.Link = _Link3.default, exports.MemoryRouter = _MemoryRouter3.default, exports.NavLink = _NavLink3.default, 
        exports.Prompt = _Prompt3.default, exports.Redirect = _Redirect3.default, exports.Route = _Route3.default, 
        exports.Router = _Router3.default, exports.StaticRouter = _StaticRouter3.default, 
        exports.Switch = _Switch3.default, exports.matchPath = _matchPath3.default, exports.withRouter = _withRouter3.default;
    }, /* 217 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        exports.__esModule = !0;
        var _warning = __webpack_require__(193), _warning2 = _interopRequireDefault(_warning), _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _propTypes = __webpack_require__(109), _propTypes2 = _interopRequireDefault(_propTypes), _createBrowserHistory = __webpack_require__(205), _createBrowserHistory2 = _interopRequireDefault(_createBrowserHistory), _Router = __webpack_require__(218), _Router2 = _interopRequireDefault(_Router), BrowserRouter = function(_React$Component) {
            function BrowserRouter() {
                var _temp, _this, _ret;
                _classCallCheck(this, BrowserRouter);
                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                return _temp = _this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [ this ].concat(args))), 
                _this.history = (0, _createBrowserHistory2.default)(_this.props), _ret = _temp, 
                _possibleConstructorReturn(_this, _ret);
            }
            return _inherits(BrowserRouter, _React$Component), BrowserRouter.prototype.componentWillMount = function() {
                (0, _warning2.default)(!this.props.history, "<BrowserRouter> ignores the history prop. To use a custom history, use `import { Router }` instead of `import { BrowserRouter as Router }`.");
            }, BrowserRouter.prototype.render = function() {
                return _react2.default.createElement(_Router2.default, {
                    history: this.history,
                    children: this.props.children
                });
            }, BrowserRouter;
        }(_react2.default.Component);
        BrowserRouter.propTypes = {
            basename: _propTypes2.default.string,
            forceRefresh: _propTypes2.default.bool,
            getUserConfirmation: _propTypes2.default.func,
            keyLength: _propTypes2.default.number,
            children: _propTypes2.default.node
        }, exports.default = BrowserRouter;
    }, /* 218 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0;
        var _Router = __webpack_require__(200), _Router2 = _interopRequireDefault(_Router);
        exports.default = _Router2.default;
    }, /* 219 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        exports.__esModule = !0;
        var _warning = __webpack_require__(193), _warning2 = _interopRequireDefault(_warning), _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _propTypes = __webpack_require__(109), _propTypes2 = _interopRequireDefault(_propTypes), _createHashHistory = __webpack_require__(207), _createHashHistory2 = _interopRequireDefault(_createHashHistory), _Router = __webpack_require__(218), _Router2 = _interopRequireDefault(_Router), HashRouter = function(_React$Component) {
            function HashRouter() {
                var _temp, _this, _ret;
                _classCallCheck(this, HashRouter);
                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                return _temp = _this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [ this ].concat(args))), 
                _this.history = (0, _createHashHistory2.default)(_this.props), _ret = _temp, _possibleConstructorReturn(_this, _ret);
            }
            return _inherits(HashRouter, _React$Component), HashRouter.prototype.componentWillMount = function() {
                (0, _warning2.default)(!this.props.history, "<HashRouter> ignores the history prop. To use a custom history, use `import { Router }` instead of `import { HashRouter as Router }`.");
            }, HashRouter.prototype.render = function() {
                return _react2.default.createElement(_Router2.default, {
                    history: this.history,
                    children: this.props.children
                });
            }, HashRouter;
        }(_react2.default.Component);
        HashRouter.propTypes = {
            basename: _propTypes2.default.string,
            getUserConfirmation: _propTypes2.default.func,
            hashType: _propTypes2.default.oneOf([ "hashbang", "noslash", "slash" ]),
            children: _propTypes2.default.node
        }, exports.default = HashRouter;
    }, /* 220 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _objectWithoutProperties(obj, keys) {
            var target = {};
            for (var i in obj) keys.indexOf(i) >= 0 || Object.prototype.hasOwnProperty.call(obj, i) && (target[i] = obj[i]);
            return target;
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        exports.__esModule = !0;
        var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        }, _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _propTypes = __webpack_require__(109), _propTypes2 = _interopRequireDefault(_propTypes), _invariant = __webpack_require__(201), _invariant2 = _interopRequireDefault(_invariant), isModifiedEvent = function(event) {
            return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
        }, Link = function(_React$Component) {
            function Link() {
                var _temp, _this, _ret;
                _classCallCheck(this, Link);
                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                return _temp = _this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [ this ].concat(args))), 
                _this.handleClick = function(event) {
                    if (_this.props.onClick && _this.props.onClick(event), !event.defaultPrevented && // onClick prevented default
                    0 === event.button && // ignore right clicks
                    !_this.props.target && // let browser handle "target=_blank" etc.
                    !isModifiedEvent(event)) {
                        event.preventDefault();
                        var history = _this.context.router.history, _this$props = _this.props, replace = _this$props.replace, to = _this$props.to;
                        replace ? history.replace(to) : history.push(to);
                    }
                }, _ret = _temp, _possibleConstructorReturn(_this, _ret);
            }
            return _inherits(Link, _React$Component), Link.prototype.render = function() {
                var _props = this.props, to = (_props.replace, _props.to), innerRef = _props.innerRef, props = _objectWithoutProperties(_props, [ "replace", "to", "innerRef" ]);
                // eslint-disable-line no-unused-vars
                (0, _invariant2.default)(this.context.router, "You should not use <Link> outside a <Router>");
                var href = this.context.router.history.createHref("string" == typeof to ? {
                    pathname: to
                } : to);
                return _react2.default.createElement("a", _extends({}, props, {
                    onClick: this.handleClick,
                    href: href,
                    ref: innerRef
                }));
            }, Link;
        }(_react2.default.Component);
        Link.propTypes = {
            onClick: _propTypes2.default.func,
            target: _propTypes2.default.string,
            replace: _propTypes2.default.bool,
            to: _propTypes2.default.oneOfType([ _propTypes2.default.string, _propTypes2.default.object ]).isRequired,
            innerRef: _propTypes2.default.oneOfType([ _propTypes2.default.string, _propTypes2.default.func ])
        }, Link.defaultProps = {
            replace: !1
        }, Link.contextTypes = {
            router: _propTypes2.default.shape({
                history: _propTypes2.default.shape({
                    push: _propTypes2.default.func.isRequired,
                    replace: _propTypes2.default.func.isRequired,
                    createHref: _propTypes2.default.func.isRequired
                }).isRequired
            }).isRequired
        }, exports.default = Link;
    }, /* 221 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0;
        var _MemoryRouter = __webpack_require__(192), _MemoryRouter2 = _interopRequireDefault(_MemoryRouter);
        exports.default = _MemoryRouter2.default;
    }, /* 222 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _objectWithoutProperties(obj, keys) {
            var target = {};
            for (var i in obj) keys.indexOf(i) >= 0 || Object.prototype.hasOwnProperty.call(obj, i) && (target[i] = obj[i]);
            return target;
        }
        exports.__esModule = !0;
        var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        }, _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
            return typeof obj;
        } : function(obj) {
            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        }, _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _propTypes = __webpack_require__(109), _propTypes2 = _interopRequireDefault(_propTypes), _Route = __webpack_require__(223), _Route2 = _interopRequireDefault(_Route), _Link = __webpack_require__(220), _Link2 = _interopRequireDefault(_Link), NavLink = function(_ref) {
            var to = _ref.to, exact = _ref.exact, strict = _ref.strict, location = _ref.location, activeClassName = _ref.activeClassName, className = _ref.className, activeStyle = _ref.activeStyle, style = _ref.style, getIsActive = _ref.isActive, ariaCurrent = _ref.ariaCurrent, rest = _objectWithoutProperties(_ref, [ "to", "exact", "strict", "location", "activeClassName", "className", "activeStyle", "style", "isActive", "ariaCurrent" ]);
            return _react2.default.createElement(_Route2.default, {
                path: "object" === ("undefined" == typeof to ? "undefined" : _typeof(to)) ? to.pathname : to,
                exact: exact,
                strict: strict,
                location: location,
                children: function(_ref2) {
                    var location = _ref2.location, match = _ref2.match, isActive = !!(getIsActive ? getIsActive(match, location) : match);
                    return _react2.default.createElement(_Link2.default, _extends({
                        to: to,
                        className: isActive ? [ className, activeClassName ].filter(function(i) {
                            return i;
                        }).join(" ") : className,
                        style: isActive ? _extends({}, style, activeStyle) : style,
                        "aria-current": isActive && ariaCurrent
                    }, rest));
                }
            });
        };
        NavLink.propTypes = {
            to: _Link2.default.propTypes.to,
            exact: _propTypes2.default.bool,
            strict: _propTypes2.default.bool,
            location: _propTypes2.default.object,
            activeClassName: _propTypes2.default.string,
            className: _propTypes2.default.string,
            activeStyle: _propTypes2.default.object,
            style: _propTypes2.default.object,
            isActive: _propTypes2.default.func,
            ariaCurrent: _propTypes2.default.oneOf([ "page", "step", "location", "true" ])
        }, NavLink.defaultProps = {
            activeClassName: "active",
            ariaCurrent: "true"
        }, exports.default = NavLink;
    }, /* 223 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0;
        var _Route = __webpack_require__(208), _Route2 = _interopRequireDefault(_Route);
        exports.default = _Route2.default;
    }, /* 224 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0;
        var _Prompt = __webpack_require__(202), _Prompt2 = _interopRequireDefault(_Prompt);
        exports.default = _Prompt2.default;
    }, /* 225 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0;
        var _Redirect = __webpack_require__(203), _Redirect2 = _interopRequireDefault(_Redirect);
        exports.default = _Redirect2.default;
    }, /* 226 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0;
        var _StaticRouter = __webpack_require__(212), _StaticRouter2 = _interopRequireDefault(_StaticRouter);
        exports.default = _StaticRouter2.default;
    }, /* 227 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0;
        var _Switch = __webpack_require__(213), _Switch2 = _interopRequireDefault(_Switch);
        exports.default = _Switch2.default;
    }, /* 228 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0;
        var _matchPath = __webpack_require__(209), _matchPath2 = _interopRequireDefault(_matchPath);
        exports.default = _matchPath2.default;
    }, /* 229 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0;
        var _withRouter = __webpack_require__(214), _withRouter2 = _interopRequireDefault(_withRouter);
        exports.default = _withRouter2.default;
    }, /* 230 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function DefaultTheme() {
            return _react2.default.createElement(_react.Fragment, null, _react2.default.createElement(GlobalStyles, null), _react2.default.createElement("link", {
                href: "https://fonts.googleapis.com/css?family=Droid+Sans|Yanone+Kaffeesatz",
                rel: "stylesheet",
                type: "text/css"
            }));
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _taggedTemplateLiteral2 = __webpack_require__(2), _taggedTemplateLiteral3 = _interopRequireDefault(_taggedTemplateLiteral2), _templateObject = (0, 
        _taggedTemplateLiteral3.default)([ "\n  html, body {\n    height: 100%;\n    box-sizing: border-box;\n    margin: 0;\n    padding: 0;\n  }\n  * {\n    box-sizing: inherit;\n  }\n\n  body {\n    font-family: 'Droid Sans', sans-serif;\n    font-size: 20px;\n  }\n  h1, h2, h3, h4 {\n    font-family: 'Yanone Kaffeesatz', sans-serif;\n    font-weight: 400;\n    margin: 0 0 1rem;\n  }\n  h1 {\n    font-size: 2.5rem;\n  }\n  h2 {\n    font-size: 1.75rem;\n  }\n  h3 {\n    font-size: 1.5rem;\n  }\n  h4 {\n    font-size: 1rem;\n  }\n\n  li {\n    margin: 0 0 0.5rem;\n  }\n\n  html, body, #root {\n    height: 100%;\n  }\n\n  a {\n    color: #F92672;\n    text-decoration: none;\n  }\n\n  p {\n    margin: 0 0 1rem;\n  }\n\n  code {\n    background: #e7e8e2;\n    border-radius: 5px;\n    font-family: monospace;\n  }\n\n  button {\n    font-family: 'Yanone Kaffeesatz';\n    padding: 0.5rem 1rem;\n    border-radius: 0.5rem;\n    border: none;\n    background-color: #F92672;\n    color: #fff;\n    font-weight: 400;\n    font-size: 20px;\n    cursor: pointer;\n  }\n\n  button:disabled {\n    opacity: 0.5;\n    cursor: default;\n  }\n" ], [ "\n  html, body {\n    height: 100%;\n    box-sizing: border-box;\n    margin: 0;\n    padding: 0;\n  }\n  * {\n    box-sizing: inherit;\n  }\n\n  body {\n    font-family: 'Droid Sans', sans-serif;\n    font-size: 20px;\n  }\n  h1, h2, h3, h4 {\n    font-family: 'Yanone Kaffeesatz', sans-serif;\n    font-weight: 400;\n    margin: 0 0 1rem;\n  }\n  h1 {\n    font-size: 2.5rem;\n  }\n  h2 {\n    font-size: 1.75rem;\n  }\n  h3 {\n    font-size: 1.5rem;\n  }\n  h4 {\n    font-size: 1rem;\n  }\n\n  li {\n    margin: 0 0 0.5rem;\n  }\n\n  html, body, #root {\n    height: 100%;\n  }\n\n  a {\n    color: #F92672;\n    text-decoration: none;\n  }\n\n  p {\n    margin: 0 0 1rem;\n  }\n\n  code {\n    background: #e7e8e2;\n    border-radius: 5px;\n    font-family: monospace;\n  }\n\n  button {\n    font-family: 'Yanone Kaffeesatz';\n    padding: 0.5rem 1rem;\n    border-radius: 0.5rem;\n    border: none;\n    background-color: #F92672;\n    color: #fff;\n    font-weight: 400;\n    font-size: 20px;\n    cursor: pointer;\n  }\n\n  button:disabled {\n    opacity: 0.5;\n    cursor: default;\n  }\n" ]);
        exports.default = DefaultTheme;
        var _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _styledComponents = __webpack_require__(129), GlobalStyles = (0, 
        _styledComponents.createGlobalStyle)(_templateObject);
    }, /* 231 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _getPrototypeOf = __webpack_require__(75), _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf), _classCallCheck2 = __webpack_require__(78), _classCallCheck3 = _interopRequireDefault(_classCallCheck2), _createClass2 = __webpack_require__(79), _createClass3 = _interopRequireDefault(_createClass2), _possibleConstructorReturn2 = __webpack_require__(83), _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2), _inherits2 = __webpack_require__(100), _inherits3 = _interopRequireDefault(_inherits2), _taggedTemplateLiteral2 = __webpack_require__(2), _taggedTemplateLiteral3 = _interopRequireDefault(_taggedTemplateLiteral2), _templateObject = (0, 
        _taggedTemplateLiteral3.default)([ "\n  position: absolute;\n  top: 1rem;\n  right: 1rem;\n\n  @media (max-width: 600px) {\n    top: 0.5rem;\n    right: 0.5rem;\n  }\n" ], [ "\n  position: absolute;\n  top: 1rem;\n  right: 1rem;\n\n  @media (max-width: 600px) {\n    top: 0.5rem;\n    right: 0.5rem;\n  }\n" ]), _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _styledComponents = __webpack_require__(129), _styledComponents2 = _interopRequireDefault(_styledComponents), _IconButton = __webpack_require__(182), _IconButton2 = _interopRequireDefault(_IconButton), _Icons = __webpack_require__(183), _PropTypes = __webpack_require__(185), ButtonGroup = _styledComponents2.default.div(_templateObject), TouchNav = function(_Component) {
            function TouchNav() {
                return (0, _classCallCheck3.default)(this, TouchNav), (0, _possibleConstructorReturn3.default)(this, (TouchNav.__proto__ || (0, 
                _getPrototypeOf2.default)(TouchNav)).apply(this, arguments));
            }
            return (0, _inherits3.default)(TouchNav, _Component), (0, _createClass3.default)(TouchNav, [ {
                key: "render",
                value: function() {
                    var presentation = this.context.presentation;
                    return _react2.default.createElement(ButtonGroup, null, _react2.default.createElement(_IconButton2.default, {
                        disabled: presentation.isAtBeginning(),
                        onClick: presentation.goBack
                    }, _react2.default.createElement(_Icons.IconLeft, null)), _react2.default.createElement(_IconButton2.default, {
                        disabled: presentation.isAtEnd(),
                        onClick: presentation.goForward
                    }, _react2.default.createElement(_Icons.IconRight, null)));
                }
            } ]), TouchNav;
        }(_react.Component);
        TouchNav.contextTypes = {
            presentation: _PropTypes.presentationContext.isRequired
        }, exports.default = TouchNav;
    }, /* 232 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _assign = __webpack_require__(69), _assign2 = _interopRequireDefault(_assign), _getPrototypeOf = __webpack_require__(75), _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf), _classCallCheck2 = __webpack_require__(78), _classCallCheck3 = _interopRequireDefault(_classCallCheck2), _createClass2 = __webpack_require__(79), _createClass3 = _interopRequireDefault(_createClass2), _possibleConstructorReturn2 = __webpack_require__(83), _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2), _inherits2 = __webpack_require__(100), _inherits3 = _interopRequireDefault(_inherits2), _cuid = __webpack_require__(233), _cuid2 = _interopRequireDefault(_cuid), _qs = __webpack_require__(234), _qs2 = _interopRequireDefault(_qs), _react = __webpack_require__(108), _PropTypes = __webpack_require__(185), parentWindowID = (0, 
        _cuid2.default)(), PresenterModePlugin = function(_Component) {
            function PresenterModePlugin(props, context) {
                (0, _classCallCheck3.default)(this, PresenterModePlugin);
                var _this = (0, _possibleConstructorReturn3.default)(this, (PresenterModePlugin.__proto__ || (0, 
                _getPrototypeOf2.default)(PresenterModePlugin)).call(this, props, context));
                return _this._parentWindowID = null, _this._presenterWindow = null, _this._onKeyDown = _this._onKeyDown.bind(_this), 
                _this._signalParent = _this._signalParent.bind(_this), _this._togglePresenterMode = _this._togglePresenterMode.bind(_this), 
                _this;
            }
            return (0, _inherits3.default)(PresenterModePlugin, _Component), (0, _createClass3.default)(PresenterModePlugin, [ {
                key: "componentDidMount",
                value: function() {
                    document.body.addEventListener("keydown", this._onKeyDown);
                }
            }, {
                key: "componentWillMount",
                value: function() {
                    var presentation = this.context.presentation;
                    this._parentWindowID = _qs2.default.parse(window.location.search.slice(1)).parentWindowID, 
                    presentation.setPluginProps({
                        isPresenterMode: !!this._parentWindowID
                    });
                    var callback = function(_ref) {
                        var slideIndex = _ref.slideIndex, stepIndex = _ref.stepIndex;
                        presentation.goToSlide({
                            slideIndex: slideIndex,
                            stepIndex: stepIndex
                        });
                    };
                    this._parentWindowID || window[parentWindowID] ? this._parentWindowID && !window[this._parentWindowID] && (window[this._parentWindowID] = callback) : window[parentWindowID] = callback;
                }
            }, {
                key: "componentWillUnmount",
                value: function() {
                    document.body.removeEventListener("keydown", this._onKeyDown);
                }
            }, {
                key: "componentWillUpdate",
                value: function(nextProps, nextState, nextContext) {
                    var presentation = this.context.presentation, slideIndex = presentation.getSlideIndex(), stepIndex = presentation.getStepIndex();
                    slideIndex === this._slideIndex && stepIndex === this._stepIndex || (this._slideIndex = slideIndex, 
                    this._stepIndex = stepIndex, this._parentWindowID ? this._signalParent({
                        slideIndex: slideIndex,
                        stepIndex: stepIndex
                    }) : this._presenterWindow && this._syncPath({
                        slideIndex: slideIndex,
                        stepIndex: stepIndex
                    }));
                }
            }, {
                key: "render",
                value: function() {
                    return null;
                }
            }, {
                key: "_onKeyDown",
                value: function(event) {
                    if ("INPUT" !== event.target.tagName) switch (event.key) {
                      case "p":
                      case "P":
                        this._parentWindowID || this._togglePresenterMode();
                    }
                }
            }, {
                key: "_signalParent",
                value: function(path) {
                    window.opener && ("function" != typeof window.opener[this._parentWindowID] ? window.close() : window.opener && window.opener[this._parentWindowID](path));
                }
            }, {
                key: "_togglePresenterMode",
                value: function(path) {
                    if (this._presenterWindow) this._presenterWindow.close(), this._presenterWindow = null; else {
                        var url = new window.URL(window.location.href);
                        url.search = "?" + _qs2.default.stringify((0, _assign2.default)(_qs2.default.parse(window.location.search.slice(1)), {
                            parentWindowID: parentWindowID
                        })), this._presenterWindow = window.open(url.toString(), "react-presents-notes");
                    }
                }
            }, {
                key: "_syncPath",
                value: function(path) {
                    this._presenterWindow && !this._presenterWindow.closed && this._presenterWindow[parentWindowID](path);
                }
            } ]), PresenterModePlugin;
        }(_react.Component);
        PresenterModePlugin.contextTypes = {
            presentation: _PropTypes.presentationContext.isRequired
        }, exports.default = PresenterModePlugin;
    }, /* 233 */
    /***/
    function(module, exports, __webpack_require__) {
        /**
	 * cuid.js
	 * Collision-resistant UID generator for browsers and node.
	 * Sequential for fast db lookups and recency sorting.
	 * Safe for element IDs and server-side lookups.
	 *
	 * Extracted from CLCTR
	 *
	 * Copyright (c) Eric Elliott 2012
	 * MIT License
	 */
        /*global window, navigator, document, require, process, module */
        !function(app) {
            "use strict";
            var namespace = "cuid", c = 0, blockSize = 4, base = 36, discreteValues = Math.pow(base, blockSize), pad = function(num, size) {
                var s = "000000000" + num;
                return s.substr(s.length - size);
            }, randomBlock = function() {
                return pad((Math.random() * discreteValues << 0).toString(base), blockSize);
            }, safeCounter = function() {
                // this is not subliminal
                return c = c < discreteValues ? c : 0, c++, c - 1;
            }, api = function() {
                // Starting with a lowercase letter makes
                // it HTML element ID friendly.
                var // Prevent same-machine collisions.
                counter, letter = "c", // hard-coded allows for sequential access
                // timestamp
                // warning: this exposes the exact date and time
                // that the uid was created.
                timestamp = new Date().getTime().toString(base), // A few chars to generate distinct ids for different
                // clients (so different computers are far less
                // likely to generate the same id)
                fingerprint = api.fingerprint(), // Grab some more chars from Math.random()
                random = randomBlock() + randomBlock();
                return counter = pad(safeCounter().toString(base), blockSize), letter + timestamp + counter + fingerprint + random;
            };
            api.slug = function() {
                var counter, date = new Date().getTime().toString(36), print = api.fingerprint().slice(0, 1) + api.fingerprint().slice(-1), random = randomBlock().slice(-2);
                return counter = safeCounter().toString(36).slice(-4), date.slice(-2) + counter + print + random;
            }, api.globalCount = function() {
                // We want to cache the results of this
                var cache = function() {
                    var i, count = 0;
                    for (i in window) count++;
                    return count;
                }();
                return api.globalCount = function() {
                    return cache;
                }, cache;
            }, api.fingerprint = function() {
                return pad((navigator.mimeTypes.length + navigator.userAgent.length).toString(36) + api.globalCount().toString(36), 4);
            }, // don't change anything from here down.
            app.register ? app.register(namespace, api) : module.exports = api;
        }(this.applitude || this);
    }, /* 234 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        var stringify = __webpack_require__(235), parse = __webpack_require__(238), formats = __webpack_require__(237);
        module.exports = {
            formats: formats,
            parse: parse,
            stringify: stringify
        };
    }, /* 235 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        var utils = __webpack_require__(236), formats = __webpack_require__(237), arrayPrefixGenerators = {
            brackets: function(prefix) {
                // eslint-disable-line func-name-matching
                return prefix + "[]";
            },
            indices: function(prefix, key) {
                // eslint-disable-line func-name-matching
                return prefix + "[" + key + "]";
            },
            repeat: function(prefix) {
                // eslint-disable-line func-name-matching
                return prefix;
            }
        }, toISO = Date.prototype.toISOString, defaults = {
            delimiter: "&",
            encode: !0,
            encoder: utils.encode,
            encodeValuesOnly: !1,
            serializeDate: function(date) {
                // eslint-disable-line func-name-matching
                return toISO.call(date);
            },
            skipNulls: !1,
            strictNullHandling: !1
        }, stringify = function stringify(// eslint-disable-line func-name-matching
        object, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly) {
            var obj = object;
            if ("function" == typeof filter) obj = filter(prefix, obj); else if (obj instanceof Date) obj = serializeDate(obj); else if (null === obj) {
                if (strictNullHandling) return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder) : prefix;
                obj = "";
            }
            if ("string" == typeof obj || "number" == typeof obj || "boolean" == typeof obj || utils.isBuffer(obj)) {
                if (encoder) {
                    var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder);
                    return [ formatter(keyValue) + "=" + formatter(encoder(obj, defaults.encoder)) ];
                }
                return [ formatter(prefix) + "=" + formatter(String(obj)) ];
            }
            var values = [];
            if ("undefined" == typeof obj) return values;
            var objKeys;
            if (Array.isArray(filter)) objKeys = filter; else {
                var keys = Object.keys(obj);
                objKeys = sort ? keys.sort(sort) : keys;
            }
            for (var i = 0; i < objKeys.length; ++i) {
                var key = objKeys[i];
                skipNulls && null === obj[key] || (values = Array.isArray(obj) ? values.concat(stringify(obj[key], generateArrayPrefix(prefix, key), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly)) : values.concat(stringify(obj[key], prefix + (allowDots ? "." + key : "[" + key + "]"), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly)));
            }
            return values;
        };
        module.exports = function(object, opts) {
            var obj = object, options = opts ? utils.assign({}, opts) : {};
            if (null !== options.encoder && void 0 !== options.encoder && "function" != typeof options.encoder) throw new TypeError("Encoder has to be a function.");
            var delimiter = "undefined" == typeof options.delimiter ? defaults.delimiter : options.delimiter, strictNullHandling = "boolean" == typeof options.strictNullHandling ? options.strictNullHandling : defaults.strictNullHandling, skipNulls = "boolean" == typeof options.skipNulls ? options.skipNulls : defaults.skipNulls, encode = "boolean" == typeof options.encode ? options.encode : defaults.encode, encoder = "function" == typeof options.encoder ? options.encoder : defaults.encoder, sort = "function" == typeof options.sort ? options.sort : null, allowDots = "undefined" != typeof options.allowDots && options.allowDots, serializeDate = "function" == typeof options.serializeDate ? options.serializeDate : defaults.serializeDate, encodeValuesOnly = "boolean" == typeof options.encodeValuesOnly ? options.encodeValuesOnly : defaults.encodeValuesOnly;
            if ("undefined" == typeof options.format) options.format = formats.default; else if (!Object.prototype.hasOwnProperty.call(formats.formatters, options.format)) throw new TypeError("Unknown format option provided.");
            var objKeys, filter, formatter = formats.formatters[options.format];
            "function" == typeof options.filter ? (filter = options.filter, obj = filter("", obj)) : Array.isArray(options.filter) && (filter = options.filter, 
            objKeys = filter);
            var keys = [];
            if ("object" != typeof obj || null === obj) return "";
            var arrayFormat;
            arrayFormat = options.arrayFormat in arrayPrefixGenerators ? options.arrayFormat : "indices" in options ? options.indices ? "indices" : "repeat" : "indices";
            var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
            objKeys || (objKeys = Object.keys(obj)), sort && objKeys.sort(sort);
            for (var i = 0; i < objKeys.length; ++i) {
                var key = objKeys[i];
                skipNulls && null === obj[key] || (keys = keys.concat(stringify(obj[key], key, generateArrayPrefix, strictNullHandling, skipNulls, encode ? encoder : null, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly)));
            }
            var joined = keys.join(delimiter), prefix = options.addQueryPrefix === !0 ? "?" : "";
            return joined.length > 0 ? prefix + joined : "";
        };
    }, /* 236 */
    /***/
    function(module, exports) {
        "use strict";
        var has = Object.prototype.hasOwnProperty, hexTable = function() {
            for (var array = [], i = 0; i < 256; ++i) array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
            return array;
        }(), compactQueue = function(queue) {
            for (var obj; queue.length; ) {
                var item = queue.pop();
                if (obj = item.obj[item.prop], Array.isArray(obj)) {
                    for (var compacted = [], j = 0; j < obj.length; ++j) "undefined" != typeof obj[j] && compacted.push(obj[j]);
                    item.obj[item.prop] = compacted;
                }
            }
            return obj;
        };
        exports.arrayToObject = function(source, options) {
            for (var obj = options && options.plainObjects ? Object.create(null) : {}, i = 0; i < source.length; ++i) "undefined" != typeof source[i] && (obj[i] = source[i]);
            return obj;
        }, exports.merge = function(target, source, options) {
            if (!source) return target;
            if ("object" != typeof source) {
                if (Array.isArray(target)) target.push(source); else {
                    if ("object" != typeof target) return [ target, source ];
                    (options.plainObjects || options.allowPrototypes || !has.call(Object.prototype, source)) && (target[source] = !0);
                }
                return target;
            }
            if ("object" != typeof target) return [ target ].concat(source);
            var mergeTarget = target;
            return Array.isArray(target) && !Array.isArray(source) && (mergeTarget = exports.arrayToObject(target, options)), 
            Array.isArray(target) && Array.isArray(source) ? (source.forEach(function(item, i) {
                has.call(target, i) ? target[i] && "object" == typeof target[i] ? target[i] = exports.merge(target[i], item, options) : target.push(item) : target[i] = item;
            }), target) : Object.keys(source).reduce(function(acc, key) {
                var value = source[key];
                return has.call(acc, key) ? acc[key] = exports.merge(acc[key], value, options) : acc[key] = value, 
                acc;
            }, mergeTarget);
        }, exports.assign = function(target, source) {
            return Object.keys(source).reduce(function(acc, key) {
                return acc[key] = source[key], acc;
            }, target);
        }, exports.decode = function(str) {
            try {
                return decodeURIComponent(str.replace(/\+/g, " "));
            } catch (e) {
                return str;
            }
        }, exports.encode = function(str) {
            // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
            // It has been adapted here for stricter adherence to RFC 3986
            if (0 === str.length) return str;
            for (var string = "string" == typeof str ? str : String(str), out = "", i = 0; i < string.length; ++i) {
                var c = string.charCodeAt(i);
                45 === c || 46 === c || 95 === c || 126 === c || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 ? out += string.charAt(i) : c < 128 ? out += hexTable[c] : c < 2048 ? out += hexTable[192 | c >> 6] + hexTable[128 | 63 & c] : c < 55296 || c >= 57344 ? out += hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | 63 & c] : (i += 1, 
                c = 65536 + ((1023 & c) << 10 | 1023 & string.charCodeAt(i)), out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | 63 & c]);
            }
            return out;
        }, exports.compact = function(value) {
            for (var queue = [ {
                obj: {
                    o: value
                },
                prop: "o"
            } ], refs = [], i = 0; i < queue.length; ++i) for (var item = queue[i], obj = item.obj[item.prop], keys = Object.keys(obj), j = 0; j < keys.length; ++j) {
                var key = keys[j], val = obj[key];
                "object" == typeof val && null !== val && refs.indexOf(val) === -1 && (queue.push({
                    obj: obj,
                    prop: key
                }), refs.push(val));
            }
            return compactQueue(queue);
        }, exports.isRegExp = function(obj) {
            return "[object RegExp]" === Object.prototype.toString.call(obj);
        }, exports.isBuffer = function(obj) {
            return null !== obj && "undefined" != typeof obj && !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
        };
    }, /* 237 */
    /***/
    function(module, exports) {
        "use strict";
        var replace = String.prototype.replace, percentTwenties = /%20/g;
        module.exports = {
            default: "RFC3986",
            formatters: {
                RFC1738: function(value) {
                    return replace.call(value, percentTwenties, "+");
                },
                RFC3986: function(value) {
                    return value;
                }
            },
            RFC1738: "RFC1738",
            RFC3986: "RFC3986"
        };
    }, /* 238 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        var utils = __webpack_require__(236), has = Object.prototype.hasOwnProperty, defaults = {
            allowDots: !1,
            allowPrototypes: !1,
            arrayLimit: 20,
            decoder: utils.decode,
            delimiter: "&",
            depth: 5,
            parameterLimit: 1e3,
            plainObjects: !1,
            strictNullHandling: !1
        }, parseValues = function(str, options) {
            for (var obj = {}, cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str, limit = options.parameterLimit === 1 / 0 ? void 0 : options.parameterLimit, parts = cleanStr.split(options.delimiter, limit), i = 0; i < parts.length; ++i) {
                var key, val, part = parts[i], bracketEqualsPos = part.indexOf("]="), pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
                pos === -1 ? (key = options.decoder(part, defaults.decoder), val = options.strictNullHandling ? null : "") : (key = options.decoder(part.slice(0, pos), defaults.decoder), 
                val = options.decoder(part.slice(pos + 1), defaults.decoder)), has.call(obj, key) ? obj[key] = [].concat(obj[key]).concat(val) : obj[key] = val;
            }
            return obj;
        }, parseObject = function(chain, val, options) {
            for (var leaf = val, i = chain.length - 1; i >= 0; --i) {
                var obj, root = chain[i];
                if ("[]" === root) obj = [], obj = obj.concat(leaf); else {
                    obj = options.plainObjects ? Object.create(null) : {};
                    var cleanRoot = "[" === root.charAt(0) && "]" === root.charAt(root.length - 1) ? root.slice(1, -1) : root, index = parseInt(cleanRoot, 10);
                    !isNaN(index) && root !== cleanRoot && String(index) === cleanRoot && index >= 0 && options.parseArrays && index <= options.arrayLimit ? (obj = [], 
                    obj[index] = leaf) : obj[cleanRoot] = leaf;
                }
                leaf = obj;
            }
            return leaf;
        }, parseKeys = function(givenKey, val, options) {
            if (givenKey) {
                // Transform dot notation to bracket notation
                var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey, brackets = /(\[[^[\]]*])/, child = /(\[[^[\]]*])/g, segment = brackets.exec(key), parent = segment ? key.slice(0, segment.index) : key, keys = [];
                if (parent) {
                    // If we aren't using plain objects, optionally prefix keys
                    // that would overwrite object prototype properties
                    if (!options.plainObjects && has.call(Object.prototype, parent) && !options.allowPrototypes) return;
                    keys.push(parent);
                }
                for (// Loop through children appending to the array until we hit depth
                var i = 0; null !== (segment = child.exec(key)) && i < options.depth; ) {
                    if (i += 1, !options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1)) && !options.allowPrototypes) return;
                    keys.push(segment[1]);
                }
                // If there's a remainder, just add whatever is left
                return segment && keys.push("[" + key.slice(segment.index) + "]"), parseObject(keys, val, options);
            }
        };
        module.exports = function(str, opts) {
            var options = opts ? utils.assign({}, opts) : {};
            if (null !== options.decoder && void 0 !== options.decoder && "function" != typeof options.decoder) throw new TypeError("Decoder has to be a function.");
            if (options.ignoreQueryPrefix = options.ignoreQueryPrefix === !0, options.delimiter = "string" == typeof options.delimiter || utils.isRegExp(options.delimiter) ? options.delimiter : defaults.delimiter, 
            options.depth = "number" == typeof options.depth ? options.depth : defaults.depth, 
            options.arrayLimit = "number" == typeof options.arrayLimit ? options.arrayLimit : defaults.arrayLimit, 
            options.parseArrays = options.parseArrays !== !1, options.decoder = "function" == typeof options.decoder ? options.decoder : defaults.decoder, 
            options.allowDots = "boolean" == typeof options.allowDots ? options.allowDots : defaults.allowDots, 
            options.plainObjects = "boolean" == typeof options.plainObjects ? options.plainObjects : defaults.plainObjects, 
            options.allowPrototypes = "boolean" == typeof options.allowPrototypes ? options.allowPrototypes : defaults.allowPrototypes, 
            options.parameterLimit = "number" == typeof options.parameterLimit ? options.parameterLimit : defaults.parameterLimit, 
            options.strictNullHandling = "boolean" == typeof options.strictNullHandling ? options.strictNullHandling : defaults.strictNullHandling, 
            "" === str || null === str || "undefined" == typeof str) return options.plainObjects ? Object.create(null) : {};
            for (var tempObj = "string" == typeof str ? parseValues(str, options) : str, obj = options.plainObjects ? Object.create(null) : {}, keys = Object.keys(tempObj), i = 0; i < keys.length; ++i) {
                var key = keys[i], newObj = parseKeys(key, tempObj[key], options);
                obj = utils.merge(obj, newObj, options);
            }
            return utils.compact(obj);
        };
    }, /* 239 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _getPrototypeOf = __webpack_require__(75), _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf), _classCallCheck2 = __webpack_require__(78), _classCallCheck3 = _interopRequireDefault(_classCallCheck2), _createClass2 = __webpack_require__(79), _createClass3 = _interopRequireDefault(_createClass2), _possibleConstructorReturn2 = __webpack_require__(83), _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2), _inherits2 = __webpack_require__(100), _inherits3 = _interopRequireDefault(_inherits2), _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _propTypes = __webpack_require__(109), _propTypes2 = _interopRequireDefault(_propTypes), _reactRouterDom = __webpack_require__(216), _styledComponents = __webpack_require__(129), _PropTypes = __webpack_require__(185), Slide = function(_Component) {
            function Slide(props, context) {
                (0, _classCallCheck3.default)(this, Slide);
                var _this = (0, _possibleConstructorReturn3.default)(this, (Slide.__proto__ || (0, 
                _getPrototypeOf2.default)(Slide)).call(this, props, context));
                return _this._stepIndex = 0, _this._renderComponent = _this._renderComponent.bind(_this), 
                _this;
            }
            return (0, _inherits3.default)(Slide, _Component), (0, _createClass3.default)(Slide, [ {
                key: "componentWillMount",
                value: function() {
                    var presentation = this.context.presentation, _presentation$getSlid = presentation.getSlideMetadata(this), path = _presentation$getSlid.path, slideIndex = _presentation$getSlid.slideIndex;
                    this._path = path, this._slideIndex = slideIndex;
                }
            }, {
                key: "componentWillUnmount",
                value: function() {
                    this._stepIndex = 0;
                }
            }, {
                key: "getChildContext",
                value: function() {
                    return {
                        slide: this
                    };
                }
            }, {
                key: "getNumSteps",
                value: function() {
                    return this._numSteps || this._stepIndex + 1;
                }
            }, {
                key: "registerStep",
                value: function(index) {
                    this._stepIndex = Math.max(this._stepIndex, index);
                }
            }, {
                key: "render",
                value: function() {
                    return _react2.default.createElement(_reactRouterDom.Route, {
                        exact: !0,
                        path: this._path,
                        render: this._renderComponent
                    });
                }
            }, {
                key: "setNumSteps",
                value: function(numSteps) {
                    this._numSteps = numSteps;
                }
            }, {
                key: "_renderComponent",
                value: function() {
                    var _context = this.context, pluginProps = _context.pluginProps, presentation = _context.presentation, _props = this.props, Component = _props.component, render = _props.render, isPresenterMode = pluginProps.isPresenterMode, slideIndex = this._slideIndex, stepIndex = presentation.getStepIndex(), rendered = void 0;
                    return rendered = "function" == typeof render ? render({
                        isPresenterMode: isPresenterMode,
                        slideIndex: slideIndex,
                        stepIndex: stepIndex
                    }) : _react2.default.createElement(Component, {
                        isPresenterMode: isPresenterMode,
                        slideIndex: slideIndex,
                        stepIndex: stepIndex
                    }), _react2.default.createElement(_styledComponents.ThemeProvider, {
                        theme: {
                            isPresenterMode: isPresenterMode
                        }
                    }, rendered);
                }
            } ]), Slide;
        }(_react.Component);
        Slide.childContextTypes = {
            slide: _PropTypes.slideContext.isRequired
        }, Slide.contextTypes = {
            pluginProps: _propTypes2.default.object.isRequired,
            presentation: _PropTypes.presentationContext.isRequired
        }, exports.default = Slide;
    }, /* 240 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _getPrototypeOf = __webpack_require__(75), _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf), _classCallCheck2 = __webpack_require__(78), _classCallCheck3 = _interopRequireDefault(_classCallCheck2), _createClass2 = __webpack_require__(79), _createClass3 = _interopRequireDefault(_createClass2), _possibleConstructorReturn2 = __webpack_require__(83), _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2), _inherits2 = __webpack_require__(100), _inherits3 = _interopRequireDefault(_inherits2), _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _propTypes = __webpack_require__(109), _propTypes2 = _interopRequireDefault(_propTypes), _PropTypes = __webpack_require__(185), Step = function(_Component) {
            function Step() {
                return (0, _classCallCheck3.default)(this, Step), (0, _possibleConstructorReturn3.default)(this, (Step.__proto__ || (0, 
                _getPrototypeOf2.default)(Step)).apply(this, arguments));
            }
            return (0, _inherits3.default)(Step, _Component), (0, _createClass3.default)(Step, [ {
                key: "componentWillMount",
                value: function() {
                    var slide = this.context.slide, _props = this.props, index = _props.index, maxIndex = _props.maxIndex;
                    maxIndex < 1 / 0 ? slide.registerStep(maxIndex) : slide.registerStep(index);
                }
            }, {
                key: "render",
                value: function() {
                    var _context = this.context, pluginProps = _context.pluginProps, presentation = _context.presentation, _props2 = this.props, children = _props2.children, exact = _props2.exact, index = _props2.index, maxIndex = _props2.maxIndex, isPresenterMode = pluginProps.isPresenterMode, stepIndex = presentation.getStepIndex(), match = void 0;
                    return match = exact ? stepIndex === index : stepIndex >= index && stepIndex <= maxIndex, 
                    match ? children : isPresenterMode ? _react2.default.createElement("div", {
                        style: {
                            opacity: .35
                        }
                    }, children) : null;
                }
            } ]), Step;
        }(_react.Component);
        Step.contextTypes = {
            pluginProps: _propTypes2.default.object.isRequired,
            presentation: _PropTypes.presentationContext.isRequired,
            slide: _PropTypes.slideContext.isRequired
        }, Step.defaultProps = {
            maxIndex: 1 / 0
        }, exports.default = Step;
    }, /* 241 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _taggedTemplateLiteral2 = __webpack_require__(2), _taggedTemplateLiteral3 = _interopRequireDefault(_taggedTemplateLiteral2), _templateObject = (0, 
        _taggedTemplateLiteral3.default)([ "\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  text-align: center;\n  height: 100%;\n  background-color: #222;\n  color: #fff;\n  padding: 1rem;\n\n  ", "\n\n  @media (max-width: 600px) {\n    padding: 0.5rem;\n  }\n" ], [ "\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  text-align: center;\n  height: 100%;\n  background-color: #222;\n  color: #fff;\n  padding: 1rem;\n\n  ", "\n\n  @media (max-width: 600px) {\n    padding: 0.5rem;\n  }\n" ]), _styledComponents = __webpack_require__(129), _styledComponents2 = _interopRequireDefault(_styledComponents), _presenterSlideStyle = __webpack_require__(142), _presenterSlideStyle2 = _interopRequireDefault(_presenterSlideStyle);
        exports.default = _styledComponents2.default.div(_templateObject, _presenterSlideStyle2.default);
    } ]);
});
//# sourceMappingURL=react-presents.js.map